!function(e){"use strict";function n(e,n,r){return r.a=e,r.f=n,r}function s(r){return n(2,r,function(n){return function(e){return r(n,e)}})}function d(t){return n(3,t,function(r){return function(n){return function(e){return t(r,n,e)}}})}function u(o){return n(4,o,function(t){return function(r){return function(n){return function(e){return o(t,r,n,e)}}}})}function R(a){return n(5,a,function(o){return function(t){return function(r){return function(n){return function(e){return a(o,t,r,n,e)}}}}})}function k(i){return n(6,i,function(a){return function(o){return function(t){return function(r){return function(n){return function(e){return i(a,o,t,r,n,e)}}}}}})}function E(c){return n(7,c,function(i){return function(a){return function(o){return function(t){return function(r){return function(n){return function(e){return c(i,a,o,t,r,n,e)}}}}}}})}function t(l){return n(8,l,function(c){return function(i){return function(a){return function(o){return function(t){return function(r){return function(n){return function(e){return l(c,i,a,o,t,r,n,e)}}}}}}}})}function z(e,n,r){return 2===e.a?e.f(n,r):e(n)(r)}function $(e,n,r,t){return 3===e.a?e.f(n,r,t):e(n)(r)(t)}function V(e,n,r,t,o){return 4===e.a?e.f(n,r,t,o):e(n)(r)(t)(o)}function S(e,n,r,t,o,a){return 5===e.a?e.f(n,r,t,o,a):e(n)(r)(t)(o)(a)}function I(e,n,r,t,o,a,i){return 6===e.a?e.f(n,r,t,o,a,i):e(n)(r)(t)(o)(a)(i)}function G(e,n,r,t,o,a,i,c){return 7===e.a?e.f(n,r,t,o,a,i,c):e(n)(r)(t)(o)(a)(i)(c)}function l(e,n){for(var r,t=[],o=j(e,n,0,t);o&&(r=t.pop());o=j(r.a,r.b,0,t));return o}function j(e,n,r,t){if(e!==n){if("object"!=typeof e||null===e||null===n)return"function"==typeof e&&ee(5),!1;if(100<r)t.push({a:e,b:n});else for(var o in e.$<0&&(e=at(e),n=at(n)),e)if(!j(e[o],n[o],r+1,t))return!1}return!0}function v(e,n,r){if("object"!=typeof e)return e===n?0:e<n?-1:1;if(void 0===e.$)return(r=(r=v(e.a,n.a))||v(e.b,n.b))||v(e.c,n.c);for(;e.b&&n.b&&!(r=v(e.a,n.a));e=e.b,n=n.b);return r||(e.b?1:n.b?-1:0)}var H=s(function(e,n){e=v(e,n);return e<0?tt:e?rt:nt}),U=0;function f(e,n){var r,t={};for(r in e)t[r]=e[r];for(r in n)t[r]=n[r];return t}function O(e,n){if("string"==typeof e)return e+n;if(!e.b)return n;var r={$:1,a:e.a,b:n};e=e.b;for(var t=r;e.b;e=e.b)t=t.b={$:1,a:e.a,b:n};return r}var m={$:0};function W(e,n){return{$:1,a:e,b:n}}var Y=s(W);function p(e){for(var n=m,r=e.length;r--;)n={$:1,a:e[r],b:n};return n}function K(e){for(var n=[];e.b;e=e.b)n.push(e.a);return n}var Q=d(function(e,n,r){for(var t=[];n.b&&r.b;n=n.b,r=r.b)t.push(z(e,n.a,r.a));return p(t)}),Z=s(function(r,e){return p(K(e).sort(function(e,n){e=z(r,e,n);return e===nt?0:e===tt?-1:1}))});var X=d(function(e,n,r){for(var t=Array(e),o=0;o<e;o++)t[o]=r(n+o);return t}),J=s(function(e,n){for(var r=Array(e),t=0;t<e&&n.b;t++)r[t]=n.a,n=n.b;return r.length=t,{a:r,b:n}});function ee(e){throw Error("https://github.com/elm/core/blob/1.0.0/hints/"+e+".md")}var ne=s(function(e,n){return e+n}),re=s(Math.pow),te=Math.cos,oe=Math.sin,ae=Math.tan;var ie=Math.ceil,ce=Math.floor,le=Math.round,ue=Math.sqrt,fe=Math.log;var se=s(function(e,n){return n.split(e)}),de=s(function(e,n){return n.join(e)});function ve(e){return e+""}var me={$:2,b:function(e){return"number"==typeof e?ft(e):ye("a FLOAT",e)}},pe={$:2,b:function(e){return"string"==typeof e?ft(e):e instanceof String?ft(e+""):ye("a STRING",e)}};var ge=s(function(e,n){return{$:6,d:e,b:n}});var be=s(function(e,n){return{$:9,f:e,g:[n]}}),he=d(function(e,n,r){return{$:9,f:e,g:[n,r]}}),xe=s(g);function g(e,n){switch(e.$){case 2:return e.b(n);case 5:return null===n?ft(e.c):ye("null",n);case 3:return Pe(n)?Ce(e.b,n,p):ye("a LIST",n);case 4:return Pe(n)?Ce(e.b,n,Te):ye("an ARRAY",n);case 6:var r=e.d;return"object"==typeof n&&null!==n&&r in n?(a=g(e.b,n[r]),T(a)?a:it(z(lt,r,a.a))):ye("an OBJECT with a field named `"+r+"`",n);case 7:r=e.e;return Pe(n)?r<n.length?(a=g(e.b,n[r]),T(a)?a:it(z(ut,r,a.a))):ye("a LONGER array. Need index "+r+" but only see "+n.length+" entries",n):ye("an ARRAY",n);case 8:if("object"!=typeof n||null===n||Pe(n))return ye("an OBJECT",n);var t,o=m;for(t in n)if(n.hasOwnProperty(t)){var a=g(e.b,n[t]);if(!T(a))return it(z(lt,t,a.a));o={$:1,a:{a:t,b:a.a},b:o}}return ft(Ct(o));case 9:for(var i=e.f,c=e.g,l=0;l<c.length;l++){a=g(c[l],n);if(!T(a))return a;i=i(a.a)}return ft(i);case 10:a=g(e.b,n);return T(a)?g(e.h(a.a),n):a;case 11:for(var u=m,f=e.g;f.b;f=f.b){a=g(f.a,n);if(T(a))return a;u={$:1,a:a.a,b:u}}return it(st(Ct(u)));case 1:return it(z(ct,e.a,n));case 0:return ft(e.a)}}function Ce(e,n,r){for(var t=n.length,o=Array(t),a=0;a<t;a++){var i=g(e,n[a]);if(!T(i))return it(z(ut,a,i.a));o[a]=i.a}return ft(r(o))}function Pe(e){return Array.isArray(e)||"undefined"!=typeof FileList&&e instanceof FileList}function Te(n){return z(qt,n.length,function(e){return n[e]})}function ye(e,n){return it(z(ct,"Expecting "+e,n))}function Le(e,n){if(e===n)return!0;if(e.$!==n.$)return!1;switch(e.$){case 0:case 1:return e.a===n.a;case 2:return e.b===n.b;case 5:return e.c===n.c;case 3:case 4:case 8:return Le(e.b,n.b);case 6:return e.d===n.d&&Le(e.b,n.b);case 7:return e.e===n.e&&Le(e.b,n.b);case 9:return e.f===n.f&&Me(e.g,n.g);case 10:return e.h===n.h&&Le(e.b,n.b);case 11:return Me(e.g,n.g)}}function Me(e,n){var r=e.length;if(r!==n.length)return!1;for(var t=0;t<r;t++)if(!Le(e[t],n[t]))return!1;return!0}function we(e){return{$:0,a:e}}var De=s(function(e,n){return{$:3,b:e,d:n}});var Ne=0;function ze(e){e={$:0,e:Ne++,f:e,g:null,h:[]};return qe(e),e}function $e(n){return{$:2,b:function(e){e({$:0,a:ze(n)})},c:null}}function Ve(e,n){e.h.push(n),qe(e)}var Se=s(function(n,r){return{$:2,b:function(e){Ve(n,r),e({$:0,a:U})},c:null}});var _e=!1,Ae=[];function qe(e){if(Ae.push(e),!_e){for(_e=!0;e=Ae.shift();)!function(n){for(;n.f;){var e=n.f.$;if(0===e||1===e){for(;n.g&&n.g.$!==e;)n.g=n.g.i;if(!n.g)return;n.f=n.g.b(n.f.a),n.g=n.g.i}else{if(2===e)return n.f.c=n.f.b(function(e){n.f=e,qe(n)});if(5===e){if(0===n.h.length)return;n.f=n.f.b(n.h.shift())}else n.g={$:3===e?0:1,b:n.f.b,i:n.g},n.f=n.f.d}}}(e);_e=!1}}function Fe(e,n,r,t,o,a){var e=z(xe,e,n?n.flags:void 0),i=(T(e)||ee(2),{}),n=r(e.a),c=n.a,l=a(u,c),r=function(e,n){var r,t;for(t in Be){var o=Be[t];o.a&&((r=r||{})[t]=o.a(t,n)),e[t]=function(e,n){var t={g:n,h:void 0},o=e.c,a=e.d,i=e.e,c=e.f;function l(r){return z(De,l,{$:5,b:function(e){var n=e.a;return 0===e.$?$(a,t,n,r):i&&c?V(o,t,n.i,n.j,r):$(o,t,i?n.i:n.j,r)}})}return t.h=ze(z(De,l,e.b))}(o,n)}return r}(i,u);function u(e,n){e=z(t,e,c);l(c=e.a,n),He(i,e.b,o(c))}return He(i,n.b,o(c)),r?{ports:r}:{}}var Be={};var Re=s(function(n,r){return{$:2,b:function(e){n.g(r),e({$:0,a:U})},c:null}}),ke=s(function(e,n){return z(Se,e.h,{$:0,a:n})});function Ee(n){return function(e){return{$:1,k:n,l:e}}}function Ie(e){return{$:2,m:e}}var Ge=[],je=!1;function He(e,n,r){if(Ge.push({p:e,q:n,r:r}),!je){je=!0;for(var t;t=Ge.shift();)!function(e,n,r){var t,o={};for(t in Ue(!0,n,o,null),Ue(!1,r,o,null),e)Ve(e[t],{$:"fx",a:o[t]||{i:m,j:m}})}(t.p,t.q,t.r);je=!1}}function Ue(e,n,r,t){switch(n.$){case 1:var o=n.k,a=function(e,n,r,t){function o(e){for(var n=r;n;n=n.t)e=n.s(e);return e}return z(e?Be[n].e:Be[n].f,o,t)}(e,o,t,n.l);return void(r[o]=function(e,n,r){return r=r||{i:m,j:m},e?r.i={$:1,a:n,b:r.i}:r.j={$:1,a:n,b:r.j},r}(e,a,r[o]));case 2:for(var i=n.m;i.b;i=i.b)Ue(e,i.a,r,t);return;case 3:Ue(e,n.o,r,{s:n.n,t:t})}}var Oe;var We="undefined"!=typeof document?document:{};function Ye(e){return{$:0,a:e}}var Ke=s(function(a,i){return s(function(e,n){for(var r=[],t=0;n.b;n=n.b){var o=n.a;t+=o.b||0,r.push(o)}return t+=r.length,{$:1,c:i,d:rn(e),e:r,f:a,b:t}})})(void 0),Qe=s(function(a,i){return s(function(e,n){for(var r=[],t=0;n.b;n=n.b){var o=n.a;t+=o.b.b||0,r.push(o)}return t+=r.length,{$:2,c:i,d:rn(e),e:r,f:a,b:t}})})(void 0);var Ze=s(function(e,n){return{$:"a0",n:e,o:n}}),Xe=s(function(e,n){return{$:"a1",n:e,o:n}}),Je=s(function(e,n){return{$:"a3",n:e,o:n}}),en=/^script$/i;var nn;function rn(e){for(var n={};e.b;e=e.b){var r,t=e.a,o=t.$,a=t.n,t=t.o;"a2"===o?"className"===a?tn(n,a,t):n[a]=t:(r=n[o]||(n[o]={}),"a3"===o&&"class"===a?tn(r,a,t):r[a]=t)}return n}function tn(e,n,r){var t=e[n];e[n]=t?t+" "+r:r}function on(e,n){var r=e.$;if(5===r)return on(e.k||(e.k=e.m()),n);if(0===r)return We.createTextNode(e.a);if(4===r){for(var t=e.k,o=e.j;4===t.$;)"object"!=typeof o?o=[o,t.j]:o.push(t.j),t=t.k;var a={j:o,p:n};(i=on(t,a)).elm_event_node_ref=a}else if(3===r)an(i=e.h(e.g),n,e.d);else{var i=e.f?We.createElementNS(e.f,e.c):We.createElement(e.c);Oe&&"a"==e.c&&i.addEventListener("click",Oe(i)),an(i,n,e.d);for(var c=e.e,l=0;l<c.length;l++)i.appendChild(on(1===r?c[l]:c[l].b,n))}return i}function an(e,n,r){for(var t in r){var o=r[t];"a1"===t?function(e,n){var r,t=e.style;for(r in n)t[r]=n[r]}(e,o):"a0"===t?function(e,n,r){var t,o=e.elmFs||(e.elmFs={});for(t in r){var a=r[t],i=o[t];if(a){if(i){if(i.q.$===a.$){i.q=a;continue}e.removeEventListener(t,i)}i=function(l,e){function u(e){var n=u.q,r=g(n.a,e);if(T(r)){for(var t,n=kt(n),r=r.a,o=n?n<3?r.a:r.aP:r,a=1==n?r.b:3==n&&r.dv,i=(a&&e.stopPropagation(),(2==n?r.b:3==n&&r.dk)&&e.preventDefault(),l);t=i.j;){if("function"==typeof t)o=t(o);else for(var c=t.length;c--;)o=t[c](o);i=i.p}i(o,a)}}return u.q=e,u}(n,a),e.addEventListener(t,i,nn&&{passive:kt(a)<2}),o[t]=i}else e.removeEventListener(t,i),o[t]=void 0}}(e,n,o):"a3"===t?function(e,n){for(var r in n){var t=n[r];void 0!==t?e.setAttribute(r,t):e.removeAttribute(r)}}(e,o):"a4"===t?function(e,n){for(var r in n){var t=n[r],o=t.f,t=t.o;void 0!==t?e.setAttributeNS(o,r,t):e.removeAttributeNS(o,r)}}(e,o):("value"!==t&&"checked"!==t||e[t]!==o)&&(e[t]=o)}}try{window.addEventListener("t",null,Object.defineProperty({},"passive",{get:function(){nn=!0}}))}catch(e){}function cn(e,n){var r=[];return A(e,n,r,0),r}function _(e,n,r,t){n={$:n,r:r,s:t,t:void 0,u:void 0};return e.push(n),n}function A(e,n,r,t){if(e!==n){var o=e.$,a=n.$;if(o!==a){if(1!==o||2!==a)return void _(r,0,t,n);n=function(e){for(var n=e.e,r=n.length,t=Array(r),o=0;o<r;o++)t[o]=n[o].b;return{$:1,c:e.c,d:e.d,e:t,f:e.f,b:e.b}}(n),a=1}switch(a){case 5:for(var i=e.l,c=n.l,l=i.length,u=l===c.length;u&&l--;)u=i[l]===c[l];if(u)return void(n.k=e.k);n.k=n.m();var f=[];return A(e.k,n.k,f,0),void(0<f.length&&_(r,1,t,f));case 4:for(var s=e.j,d=n.j,v=!1,m=e.k;4===m.$;)v=!0,"object"!=typeof s?s=[s,m.j]:s.push(m.j),m=m.k;for(var p=n.k;4===p.$;)v=!0,"object"!=typeof d?d=[d,p.j]:d.push(p.j),p=p.k;return v&&s.length!==d.length?void _(r,0,t,n):((v?function(e,n){for(var r=0;r<e.length;r++)if(e[r]!==n[r])return;return 1}(s,d):s===d)||_(r,2,t,d),void A(m,p,r,t+1));case 0:return void(e.a!==n.a&&_(r,3,t,n.a));case 1:return void ln(e,n,r,t,fn);case 2:return void ln(e,n,r,t,sn);case 3:if(e.h!==n.h)return void _(r,0,t,n);f=un(e.d,n.d),f=(f&&_(r,4,t,f),n.i(e.g,n.g));f&&_(r,5,t,f)}}}function ln(e,n,r,t,o){var a;e.c!==n.c||e.f!==n.f?_(r,0,t,n):((a=un(e.d,n.d))&&_(r,4,t,a),o(e,n,r,t))}function un(e,n,r){var t,o,a,i,c;for(o in e)"a1"===o||"a0"===o||"a3"===o||"a4"===o?(a=un(e[o],n[o]||{},o))&&((t=t||{})[o]=a):o in n?(a=e[o])===(i=n[o])&&"value"!==o&&"checked"!==o||"a0"===r&&function(e,n){return e.$==n.$&&Le(e.a,n.a)}(a,i)||((t=t||{})[o]=i):(t=t||{})[o]=r?"a1"===r?"":"a0"===r||"a3"===r?void 0:{f:e[o].f,o:void 0}:"string"==typeof e[o]?"":null;for(c in n)c in e||((t=t||{})[c]=n[c]);return t}function fn(e,n,r,t){var o=e.e,a=n.e,e=o.length,n=a.length;n<e?_(r,6,t,{v:n,i:e-n}):e<n&&_(r,7,t,{v:e,e:a});for(var i=e<n?e:n,c=0;c<i;c++){var l=o[c];A(l,a[c],r,++t),t+=l.b||0}}function sn(e,n,r,t){for(var o=[],a={},i=[],c=e.e,l=n.e,u=c.length,f=l.length,s=0,d=0,v=t;s<u&&d<f;){var m=c[s],p=l[d],g=m.a,b=p.a,h=m.b,x=p.b,C=void 0,P=void 0;if(g===b)A(h,x,o,++v),v+=h.b||0,s++,d++;else{var T,y,L,M,w=c[s+1],D=l[d+1];if(w&&(y=w.b,P=b===(T=w.a)),D&&(M=D.b,C=g===(L=D.a)),C&&P)A(h,M,o,++v),vn(a,o,g,x,d,i),v+=h.b||0,mn(a,o,g,y,++v),v+=y.b||0,s+=2,d+=2;else if(C)v++,vn(a,o,b,x,d,i),A(h,M,o,v),v+=h.b||0,s+=1,d+=2;else if(P)mn(a,o,g,h,++v),v+=h.b||0,A(y,x,o,++v),v+=y.b||0,s+=2,d+=1;else{if(!w||T!==L)break;mn(a,o,g,h,++v),vn(a,o,b,x,d,i),v+=h.b||0,A(y,M,o,++v),v+=y.b||0,s+=2,d+=2}}}for(;s<u;){h=(m=c[s]).b;mn(a,o,m.a,h,++v),v+=h.b||0,s++}for(;d<f;){var N=N||[];vn(a,o,(p=l[d]).a,p.b,void 0,N),d++}(0<o.length||0<i.length||N)&&_(r,8,t,{w:o,x:i,y:N})}var dn="_elmW6BL";function vn(e,n,r,t,o,a){var i,c=e[r];c?1===c.c?(a.push({r:o,A:c}),c.c=2,A(c.z,t,i=[],c.r),c.r=o,c.s.s={w:i,A:c}):vn(e,n,r+dn,t,o,a):(a.push({r:o,A:c={c:0,z:t,r:o,s:void 0}}),e[r]=c)}function mn(e,n,r,t,o){var a,i=e[r];i?0===i.c?(i.c=2,A(t,i.z,a=[],o),_(n,9,o,{w:a,A:i})):mn(e,n,r+dn,t,o):(a=_(n,9,o,void 0),e[r]={c:1,z:t,r:o,s:a})}function pn(e,n,r,t){!function e(n,r,t,o,a,i,c){var l=t[o];var u=l.r;for(;u===a;){var f,s=l.$;if(1===s?pn(n,r.k,l.s,c):8===s?(l.t=n,l.u=c,0<(f=l.s.w).length&&e(n,r,f,0,a,i,c)):9===s?(l.t=n,l.u=c,(s=l.s)&&(s.A.s=n,0<(f=s.w).length)&&e(n,r,f,0,a,i,c)):(l.t=n,l.u=c),!(l=t[++o])||(u=l.r)>i)return o}var d=r.$;if(4===d){for(var v=r.k;4===v.$;)v=v.k;return e(n,v,t,o,a+1,i,n.elm_event_node_ref)}var m=r.e;var p=n.childNodes;for(var g=0;g<m.length;g++){var b=1===d?m[g]:m[g].b,h=++a+(b.b||0);if(a<=u&&u<=h&&(o=e(p[g],b,t,o,a,h,c),!(l=t[o])||(u=l.r)>i))return o;a=h}return o}(e,n,r,0,0,n.b,t)}function gn(e,n,r,t){return 0===r.length?e:(pn(e,n,r,t),bn(e,r))}function bn(e,n){for(var r=0;r<n.length;r++){var t=n[r],o=t.t,t=function(e,n){switch(n.$){case 0:return function(e,n,r){var t=e.parentNode,n=on(n,r);n.elm_event_node_ref||(n.elm_event_node_ref=e.elm_event_node_ref);t&&n!==e&&t.replaceChild(n,e);return n}(e,n.s,n.u);case 4:return an(e,n.u,n.s),e;case 3:return e.replaceData(0,e.length,n.s),e;case 1:return bn(e,n.s);case 2:return e.elm_event_node_ref?e.elm_event_node_ref.j=n.s:e.elm_event_node_ref={j:n.s,p:n.u},e;case 6:for(var r=n.s,t=0;t<r.i;t++)e.removeChild(e.childNodes[r.v]);return e;case 7:for(var o=(r=n.s).e,t=r.v,a=e.childNodes[t];t<o.length;t++)e.insertBefore(on(o[t],n.u),a);return e;case 9:var i;return(r=n.s)?(void 0!==(i=r.A).r&&e.parentNode.removeChild(e),i.s=bn(e,r.w)):e.parentNode.removeChild(e),e;case 8:return function(e,n){for(var r=n.s,t=function(e,n){if(e){for(var r=We.createDocumentFragment(),t=0;t<e.length;t++){var o=e[t].A;r.appendChild(2===o.c?o.s:on(o.z,n.u))}return r}}(r.y,n),o=(e=bn(e,r.w),r.x),a=0;a<o.length;a++){var i=o[a],c=i.A,c=2===c.c?c.s:on(c.z,n.u);e.insertBefore(c,e.childNodes[i.r])}t&&e.appendChild(t);return e}(e,n);case 5:return n.s(e);default:ee(10)}}(o,t);o===e&&(e=t)}return e}function hn(e){if(3===e.nodeType)return{$:0,a:e.textContent};if(1!==e.nodeType)return{$:0,a:""};for(var n=m,r=e.attributes,t=r.length;t--;)var o=r[t],n={$:1,a:z(Je,o.name,o.value),b:n};for(var a=e.tagName.toLowerCase(),i=m,c=e.childNodes,t=c.length;t--;)i={$:1,a:hn(c[t]),b:i};return $(Ke,a,n,i)}var xn=u(function(n,e,r,i){return Fe(e,i,n.fW,n.gx,n.gr,function(r,e){var t=n.gA,o=i.node,a=hn(o);return Tn(e,function(e){var e=t(e),n=cn(a,e);o=gn(o,a,n,r),a=e})})}),Cn="undefined"!=typeof cancelAnimationFrame?cancelAnimationFrame:function(e){clearTimeout(e)},Pn="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:function(e){return setTimeout(e,1e3/60)};function Tn(r,t){t(r);var o=0;function a(){o=1===o?0:(Pn(a),t(r),1)}return function(e,n){r=e,n?(t(r),2===o&&(o=1)):(0===o&&Pn(a),o=2)}}var yn={addEventListener:function(){},removeEventListener:function(){}},Ln="undefined"!=typeof document?document:yn,Mn="undefined"!=typeof window?window:yn,wn=d(function(r,t,o){return $e({$:2,b:function(e){function n(e){ze(o(e))}return r.addEventListener(t,n,nn&&{passive:!0}),function(){r.removeEventListener(t,n)}},c:null})}),Dn=s(function(e,n){e=g(e,n);return T(e)?x(e.a):C});yn=s(function(r,t){return{$:2,b:function(e){var n=setInterval(function(){ze(t)},r);return function(){clearInterval(n)}},c:null}});var Nn=0;function zn(e,n){for(;n.b;n=n.b)e(n.a)}function $n(e){for(var n=0;e.b;e=e.b)n++;return n}function Vn(e){e.scissor.enabled&&(e.gl.disable(e.gl.SCISSOR_TEST),e.scissor.enabled=!1)}function Sn(e){var n=e.colorMask;n.a&&n.b&&n.c&&n.d||(e.gl.colorMask(!0,!0,!0,!0),n.a=!0,n.b=!0,n.c=!0,n.d=!0)}var _n="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:function(e){setTimeout(e,1e3/60)},An=R(function(e,n,r,t,o){return{$:0,a:e,b:n,c:r,d:t,e:o}}),qn=s(function(e,n){var r=e.blend;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.BLEND),r.enabled=!0),r.a===n.a&&r.d===n.d||(e.gl.blendEquationSeparate(n.a,n.d),r.a=n.a,r.d=n.d),r.b===n.b&&r.c===n.c&&r.e===n.e&&r.f===n.f||(e.gl.blendFuncSeparate(n.b,n.c,n.e,n.f),r.b=n.b,r.c=n.c,r.e=n.e,r.f=n.f),r.g===n.g&&r.h===n.h&&r.i===n.i&&r.j===n.j||(e.gl.blendColor(n.g,n.h,n.i,n.j),r.g=n.g,r.h=n.h,r.i=n.i,r.j=n.j)}),Fn=s(function(e,n){var r=e.depthTest;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.DEPTH_TEST),r.enabled=!0),r.a!==n.a&&(e.gl.depthFunc(n.a),r.a=n.a),r.b!==n.b&&(e.gl.depthMask(n.b),r.b=n.b),r.c===n.c&&r.d===n.d||(e.gl.depthRange(n.c,n.d),r.c=n.c,r.d=n.d)}),Bn=s(function(e,n){var r=e.stencilTest;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.STENCIL_TEST),r.enabled=!0),r.d===n.d&&r.a===n.a&&r.b===n.b||(e.gl.stencilFuncSeparate(e.gl.FRONT,n.d,n.a,n.b),r.d=n.d),r.e===n.e&&r.f===n.f&&r.g===n.g||(e.gl.stencilOpSeparate(e.gl.FRONT,n.e,n.f,n.g),r.e=n.e,r.f=n.f,r.g=n.g),r.c!==n.c&&(e.gl.stencilMask(n.c),r.c=n.c),r.h===n.h&&r.a===n.a&&r.b===n.b||(e.gl.stencilFuncSeparate(e.gl.BACK,n.h,n.a,n.b),r.h=n.h,r.a=n.a,r.b=n.b),r.i===n.i&&r.j===n.j&&r.k===n.k||(e.gl.stencilOpSeparate(e.gl.BACK,n.i,n.j,n.k),r.i=n.i,r.j=n.j,r.k=n.k)}),Rn=s(function(e,n){var r=e.scissor;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.SCISSOR_TEST),r.enabled=!0),r.a===n.a&&r.b===n.b&&r.c===n.c&&r.d===n.d||(e.gl.scissor(n.a,n.b,n.c,n.d),r.a=n.a,r.b=n.b,r.c=n.c,r.d=n.d)}),kn=s(function(e,n){var r=e.colorMask;r.toggle=e.toggle,r.enabled=!0,r.a===n.a&&r.b===n.b&&r.c===n.c&&r.d===n.d||(e.gl.colorMask(n.a,n.b,n.c,n.d),r.a=n.a,r.b=n.b,r.c=n.c,r.d=n.d)}),En=s(function(e,n){var r=e.cullFace;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.CULL_FACE),r.enabled=!0),r.a!==n.a&&(e.gl.cullFace(n.a),r.a=n.a)}),In=s(function(e,n){var r=e.polygonOffset;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.POLYGON_OFFSET_FILL),r.enabled=!0),r.a===n.a&&r.b===n.b||(e.gl.polygonOffset(n.a,n.b),r.a=n.a,r.b=n.b)}),Gn=s(function(e,n){var r=e.sampleCoverage;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.SAMPLE_COVERAGE),r.enabled=!0),r.a===n.a&&r.b===n.b||(e.gl.sampleCoverage(n.a,n.b),r.a=n.a,r.b=n.b)}),jn=["blend","depthTest","stencilTest","scissor","colorMask","cullFace","polygonOffset","sampleCoverage","sampleAlphaToCoverage"],Hn=[function(e){e.blend.enabled&&(e.gl.disable(e.gl.BLEND),e.blend.enabled=!1)},function(e){e.depthTest.enabled&&(e.gl.disable(e.gl.DEPTH_TEST),e.depthTest.enabled=!1)},function(e){e.stencilTest.enabled&&(e.gl.disable(e.gl.STENCIL_TEST),e.stencilTest.enabled=!1)},Vn,Sn,function(e){e.gl.disable(e.gl.CULL_FACE)},function(e){e.gl.disable(e.gl.POLYGON_OFFSET_FILL)},function(e){e.gl.disable(e.gl.SAMPLE_COVERAGE)},function(e){e.gl.disable(e.gl.SAMPLE_ALPHA_TO_COVERAGE)}];function Un(e,n,r){r=e.createShader(r);return e.shaderSource(r,"#extension GL_OES_standard_derivatives : enable\n"+n),e.compileShader(r),r}function On(e,n){switch(n){case e.FLOAT:return{size:1,arraySize:1,type:Float32Array,baseType:e.FLOAT};case e.FLOAT_VEC2:return{size:2,arraySize:1,type:Float32Array,baseType:e.FLOAT};case e.FLOAT_VEC3:return{size:3,arraySize:1,type:Float32Array,baseType:e.FLOAT};case e.FLOAT_VEC4:return{size:4,arraySize:1,type:Float32Array,baseType:e.FLOAT};case e.FLOAT_MAT4:return{size:4,arraySize:4,type:Float32Array,baseType:e.FLOAT};case e.INT:return{size:1,arraySize:1,type:Int32Array,baseType:e.INT}}}function Wn(e,n,r,t){for(var c=r.a.dR,l=[],o=0;o<c;o++)l.push(String.fromCharCode(97+o));var a=On(e,n.type);if(void 0===a)throw Error("No info available for: "+n.type);var i=0,u=a.size*a.arraySize*c,f=new a.type($n(r.b)*u),r=(zn(function(e){!function(n,r,t,o,a){var i;if(1===c)for(i=0;i<r;i++)n[t++]=1===r?o[a]:o[a][i];else l.forEach(function(e){for(i=0;i<r;i++)n[t++]=1===r?o[e][a]:o[e][a][i]})}(f,a.size*a.arraySize,i,e,t[n.name]||n.name),i+=u},r.b),e.createBuffer());return e.bindBuffer(e.ARRAY_BUFFER,r),e.bufferData(e.ARRAY_BUFFER,f,e.STATIC_DRAW),r}function Yn(e,n){var r,t;return 0<n.a.d0?(r=e.createBuffer(),t=function(e,n){var r,t=new Uint32Array($n(e)*n),o=0;return zn(function(e){if(1===n)t[o++]=e;else for(r=0;r<n;r++)t[o++]=e[String.fromCharCode(97+r)]},e),t}(n.c,n.a.d0),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,r),e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW),{numIndices:t.length,indexBuffer:r,buffers:{}}):{numIndices:n.a.dR*$n(n.b),indexBuffer:null,buffers:{}}}var Kn=s(function(h,e){var x=h.f,C=x.gl;return C&&(C.viewport(0,0,C.drawingBufferWidth,C.drawingBufferHeight),x.depthTest.b||(C.depthMask(!0),x.depthTest.b=!0),x.stencilTest.c!==x.STENCIL_WRITEMASK&&(C.stencilMask(x.STENCIL_WRITEMASK),x.stencilTest.c=x.STENCIL_WRITEMASK),Vn(x),Sn(x),C.clear(C.COLOR_BUFFER_BIT|C.DEPTH_BUFFER_BIT|C.STENCIL_BUFFER_BIT),zn(function(e){if(e.d.b.b){var n,r,t;if(!(i=e.b.id&&e.c.id?x.programs[n=e.b.id+"#"+e.c.id]:i)){e.b.id?o=x.shaders[e.b.id]:e.b.id=Nn++,o||(o=Un(C,e.b.src,C.VERTEX_SHADER),x.shaders[e.b.id]=o),e.c.id?a=x.shaders[e.c.id]:e.c.id=Nn++,a||(a=Un(C,e.c.src,C.FRAGMENT_SHADER),x.shaders[e.c.id]=a);for(var o,a,i,c=function(e,n,r){var t=e.createProgram();if(e.attachShader(t,n),e.attachShader(t,r),e.linkProgram(t),e.getProgramParameter(t,e.LINK_STATUS))return t;throw"Link failed: "+e.getProgramInfoLog(t)+"\nvs info-log: "+e.getShaderInfoLog(n)+"\nfs info-log: "+e.getShaderInfoLog(r)}(C,o,a),l=((i={glProgram:c,attributes:Object.assign({},e.b.attributes,e.c.attributes),currentUniforms:{},activeAttributes:[],activeAttributeLocations:[]}).uniformSetters=function(a,e,n,r){var t=n.glProgram,i=n.currentUniforms,c=0,l=e.f;for(var o={},u=a.getProgramParameter(t,a.ACTIVE_UNIFORMS),f=0;f<u;f++){var s=a.getActiveUniform(t,f);o[r[s.name]||s.name]=function(e,n){var r=n.name,t=a.getUniformLocation(e,r);switch(n.type){case a.INT:return function(e){i[r]!==e&&(a.uniform1i(t,e),i[r]=e)};case a.FLOAT:return function(e){i[r]!==e&&(a.uniform1f(t,e),i[r]=e)};case a.FLOAT_VEC2:return function(e){i[r]!==e&&(a.uniform2f(t,e[0],e[1]),i[r]=e)};case a.FLOAT_VEC3:return function(e){i[r]!==e&&(a.uniform3f(t,e[0],e[1],e[2]),i[r]=e)};case a.FLOAT_VEC4:return function(e){i[r]!==e&&(a.uniform4f(t,e[0],e[1],e[2],e[3]),i[r]=e)};case a.FLOAT_MAT4:return function(e){i[r]!==e&&(a.uniformMatrix4fv(t,!1,new Float32Array(e)),i[r]=e)};case a.SAMPLER_2D:var o=c++;return function(e){a.activeTexture(a.TEXTURE0+o);var n=l.textures.get(e);n||(n=e.ft(a),l.textures.set(e,n)),a.bindTexture(a.TEXTURE_2D,n),i[r]!==e&&(a.uniform1i(t,o),i[r]=e)};case a.BOOL:return function(e){i[r]!==e&&(a.uniform1i(t,e),i[r]=e)};default:return function(){}}}(t,s)}return o}(C,h,i,Object.assign({},e.b.uniforms,e.c.uniforms)),C.getProgramParameter(c,C.ACTIVE_ATTRIBUTES)),u=0;u<l;u++){var f=C.getActiveAttrib(c,u),s=C.getAttribLocation(c,f.name);i.activeAttributes.push(f),i.activeAttributeLocations.push(s)}x.programs[n=e.b.id+"#"+e.c.id]=i}x.lastProgId!==n&&(C.useProgram(i.glProgram),x.lastProgId=n),r=i.uniformSetters,Object.keys(t=e.e).forEach(function(e){var n=r[e];n&&n(t[e])});var d=x.buffers.get(e.d);for(d||(d=Yn(C,e.d),x.buffers.set(e.d,d)),u=0;u<i.activeAttributes.length;u++){s=i.activeAttributeLocations[u],void 0===d.buffers[(f=i.activeAttributes[u]).name]&&(d.buffers[f.name]=Wn(C,f,e.d,i.attributes)),C.bindBuffer(C.ARRAY_BUFFER,d.buffers[f.name]);var v=On(C,f.type);if(1===v.arraySize)C.enableVertexAttribArray(s),C.vertexAttribPointer(s,v.size,v.baseType,!1,0,0);else for(var m=4*v.size,p=m*v.arraySize,g=0;g<v.arraySize;g++)C.enableVertexAttribArray(s+g),C.vertexAttribPointer(s+g,v.size,v.baseType,!1,p,m*g)}for(x.toggle=!x.toggle,zn(pc(x),e.a),u=0;u<9;u++){var b=x[jn[u]];b.toggle!==x.toggle&&b.enabled&&(Hn[u](x),b.enabled=!1,b.toggle=x.toggle)}d.indexBuffer?(C.bindBuffer(C.ELEMENT_ARRAY_BUFFER,d.indexBuffer),C.drawElements(e.d.a.eA,d.numIndices,C.UNSIGNED_INT,0)):C.drawArrays(e.d.a.eA,0,d.numIndices)}},h.g)),e});var Qn=d(function(e,n,r){return function(e,n,r,t){return{$:3,d:rn(e),g:n,h:r,i:t}}(n,{g:r,f:{},h:e},Zn,Xn)});function Zn(e){var n={contextAttributes:{alpha:!1,depth:!1,stencil:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1},sceneSettings:[]},r=(zn(function(e){},e.h),We.createElement("canvas")),t=r.getContext&&(r.getContext("webgl",n.contextAttributes)||r.getContext("experimental-webgl",n.contextAttributes));return t&&void 0!==WeakMap?(n.sceneSettings.forEach(function(e){e(t)}),t.getExtension("OES_standard_derivatives"),t.getExtension("OES_element_index_uint"),e.f.gl=t,e.f.toggle=!1,e.f.blend={enabled:!1,toggle:!1},e.f.depthTest={enabled:!1,toggle:!1},e.f.stencilTest={enabled:!1,toggle:!1},e.f.scissor={enabled:!1,toggle:!1},e.f.colorMask={enabled:!1,toggle:!1},e.f.cullFace={enabled:!1,toggle:!1},e.f.polygonOffset={enabled:!1,toggle:!1},e.f.sampleCoverage={enabled:!1,toggle:!1},e.f.sampleAlphaToCoverage={enabled:!1,toggle:!1},e.f.shaders=[],e.f.programs={},e.f.lastProgId=null,e.f.buffers=new WeakMap,e.f.textures=new WeakMap,e.f.STENCIL_WRITEMASK=t.getParameter(t.STENCIL_WRITEMASK),_n(function(){return z(Kn,e,r)})):(r=We.createElement("div")).innerHTML='<a href="https://get.webgl.org/">Enable WebGL</a> to see this content!',r}function Xn(e,n){return n.f=e.f,Kn(n)}var Jn=s(function(e,n){return new Float64Array([e,n])});new Float64Array(3),new Float64Array(3),new Float64Array(3);var er=d(function(e,n,r){return new Float64Array([e,n,r])});var nr=s(function(e,n){return new Float64Array([n[0]*e,n[1]*e,n[2]*e])});var rr=u(function(e,n,r,t){return new Float64Array([e,n,r,t])});new Float64Array(16),new Float64Array(16),new Float64Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);function tr(e){return $(pt,s(function(e,n){return n+1}),0,e)}function or(e){return e}function ar(e){return e}function ir(e){return $(It,jt(h),y(m),e)}function cr(e){return ro(2*no*e)}function lr(e){return{$:0,a:e}}function ur(e){return{$:2,a:e}}function fr(e){return{$:3,a:e}}function sr(e){return{a:O(e.a?"w_":"d_",e.b),b:e}}function dr(e){return $(pt,s(function(e,n){return $(vo,e.a,e.b,n)}),Yt,e)}function vr(e){return e}function mr(e){return e.b?x(e.a):C}function b(e){return e}function pr(e){return e}function gr(e){return e}function br(e){var n,r=z(P,D(e.ac),z(P,D(e.ad),D(e.fb)));return r?Ko((n=e.ac/r)*n+(n=e.ad/r)*n+(n=e.fb/r)*n)*r:Qo}function hr(e){return ro(no*(e/180))}function xr(e){return e.da}function Cr(e){return e.dF}function Pr(e){return e.fx}function Tr(e){return function(e){return e}(e.ff)}function yr(e){return e.fw}function Lr(e){return xr(e)}function Mr(e){return{ac:-e.ac,ad:-e.ad,fb:-e.fb}}function wr(e){return Mr(Cr(e))}function Dr(e){var n=e.b;return z($i,1664525*e.a+n>>>0,n)}function Nr(e){return((e=277803737*((e=e.a)^e>>>4+(e>>>28)))>>>22^e)>>>0}function zr(e){return{$:7,a:e}}function $r(e){return $(Jt,e.a,e.b,0)}function Vr(e){return $(It,Ui,m,e)}function Sr(e){var n,r,t,o,a,i,c,l;return-1===e.$&&-1===e.d.$&&-1===e.e.$?-1!==e.e.d.$||e.e.d.a?(t=(l=e.e).b,o=l.c,a=l.d,l=l.e,S(w,1,e.b,e.c,S(w,0,(n=e.d).b,n.c,n.d,n.e),S(w,0,t,o,a,l))):(t=(r=e.e).b,o=r.c,i=(a=r.d).d,c=a.e,l=r.e,S(w,0,a.b,a.c,S(w,1,e.b,e.c,S(w,0,(n=e.d).b,n.c,n.d,n.e),i),S(w,1,t,o,c,l))):e}function _r(e){var n,r,t,o,a,i,c,l,u;return-1===e.$&&-1===e.d.$&&-1===e.e.$?-1!==e.d.d.$||e.d.d.a?(i=(u=e.e).b,c=u.c,l=u.d,u=u.e,S(w,1,n=e.b,r=e.c,S(w,0,(o=e.d).b,o.c,o.d,o=o.e),S(w,0,i,c,l,u))):(n=e.b,r=e.c,o=(t=e.d).e,i=(a=e.e).b,c=a.c,l=a.d,u=a.e,S(w,0,t.b,t.c,S(w,1,(a=t.d).b,a.c,a.d,a.e),S(w,1,n,r,o,S(w,0,i,c,l,u)))):e}function Ar(e){var n,r,t,o,a,i;return-1===e.$&&-1===e.d.$?(n=e.a,r=e.b,t=e.c,i=(o=e.d).d,a=e.e,1===o.a?-1!==i.$||i.a?-1===(i=Sr(e)).$?(e=i.e,S(fo,i.a,i.b,i.c,Ar(i.d),e)):Wt:S(w,n,r,t,Ar(o),a):S(w,n,r,t,Ar(o),a)):Wt}function qr(e){return Qe(function(e){return en.test(e)?"p":e}(e))}function Fr(e){function n(e){return gi(1e4*e)/100}var r=e.b,t=e.c,o=e.d;return e=p(["rgba(",mc(n(e.a)),"%,",mc(n(r)),"%,",mc(n(t)),"%,",mc(gi(1e3*o)/1e3),")"]),z(mt,"",e)}function Br(e){return e}function Rr(f){return function(u){return function(l){return function(c){return function(i){return function(a){return function(o){return function(t){return function(r){return function(n){return function(e){return{$:2,a:f,b:u,c:l,d:c,e:i,f:a,g:o,h:t,i:r,j:n,k:e}}}}}}}}}}}}function kr(e){return $(_c,{c0:e.c0,dn:e.dn,dC:e.dC},{bJ:e.bJ,bZ:e.bZ,b5:e.b5,b6:e.b6},{bJ:e.bJ,bZ:e.bZ,b5:e.b5,b6:e.b6})}function Er(e){return S(B,p([kr(e),V(Dc,!1,!1,!1,!1)]),Sc,$c,Vc,{})}function Ir(e){return Er({bJ:7680,c0:15,dn:8,bZ:516,dC:z(qc,2,e+4),b5:5386,b6:5386})}function Gr(e){return{a:z(xi,Hc(e),Ic(e)),b:z(xi,Uc(e),Gc(e)),c:z(xi,Oc(e),jc(e))}}function jr(e){return e}function Hr(e){return e}function Ur(e){return il(z(cl,e,m))}function Or(e){return V(Nc,515,e.av,e.aq,e.ap)}function Wr(e){return e}function Yr(n){var e=function(e){return e.gB}(n.fn),r=_a({da:Lr(e),dD:function(e){return Aa(e)}(e),dE:function(e){return qa(e)}(e),dF:Mr(wr(e))}),t=Ur(n.fF);if(1===(r=V(rl,r,1,C,p([t]))).$)return m;var r=r.a,o=z(hl,bl,e),a=z(ei,.99,z(Qc,N(n.fs),La(jc(r)))),i=Gr(r),i=br($(di,i.a,i.b,i.c)),r=z(ei,1.01,z(Jc,i,La(Oc(r)))),e=(a=gl(r=z(vl,n.fn,{fe:n.fe,fM:r,f5:a})).er)?Hr(Mr(wr(e))):b(Lr(e)),c=(l=function(){var e=n.aU;switch(e.$){case 0:return{a:0,b:0};case 1:return{a:1,b:0};case 2:return{a:2,b:0};case 3:return{a:3,b:e.a};case 4:return{a:4,b:e.a};default:return{a:5,b:0}}}()).a,l=l.b,u=z(Tc,n.aK,n.aX),i=Lc({ec:0,ed:e.ac,ee:tl(u),ef:n.e0,eg:0,eh:e.ad,ei:ol(u),ej:gr(i),ek:0,el:e.fb,em:al(u),en:c,eo:0,ep:a,eq:0,er:l}),f=I(wc,i,o,r,ll,t,{_:m,am:m,ao:m}),s=n.aN;switch(s.$){case 0:var d=s.a;return Vr(p([$(F,f._,{a:d,b:hc},Ec),$(F,f.am,fl,Ec)]));case 1:d=s.a;return Vr(p([$(F,f._,fl,Ec),p([ul]),$(F,f.ao,d.bP,zc),p([Ir(0)]),$(F,f._,{a:d,b:hc},sl),$(F,f.am,fl,Ec)]));default:var d=s.a,v=s.b;return Vr(p([$(F,f._,{a:v,b:hc},Ec),p([ul]),z(Bc,f.ao,d),$(pl,f._,v,tr(d)),$(F,f.am,fl,Ec)]))}}function Kr(e){return z(jl,0,{$:0,a:function(e){e=Hl(e);return $(Pc,e.dm,e.cR,e.cL)}(e)})}function Qr(e){return e}function Zr(e){return{$:5,a:e}}function Xr(e){var n=(t=Gr(e)).a,r=t.b,t=t.c;return{fp:Wr(function(e){return $(wu,yu(e),Lu(e),Mu(e))}(e)),fP:n/2,fQ:r/2,fR:t/2}}function Jr(e){return e.$?Gl:z(Ru,(e=e.a).aI,e.i)}var et,nt=1,rt=2,tt=0,h=Y,ot=d(function(e,n,r){for(;;){if(-2===r.$)return n;var t=r.d,o=e,a=$(e,r.b,r.c,$(ot,e,n,r.e));e=o,n=a,r=t}}),at=function(e){return $(ot,d(function(e,n,r){return z(h,{a:e,b:n},r)}),m,e)},it=function(e){return{$:1,a:e}},ct=s(function(e,n){return{$:3,a:e,b:n}}),lt=s(function(e,n){return{$:0,a:e,b:n}}),ut=s(function(e,n){return{$:1,a:e,b:n}}),ft=function(e){return{$:0,a:e}},st=function(e){return{$:2,a:e}},dt=ne,x=function(e){return{$:0,a:e}},C={$:1},vt=ve,mt=s(function(e,n){return z(de,e,K(n))}),Y=s(function(e,n){return p(z(se,e,n))}),pt=d(function(e,n,r){for(;;){if(!r.b)return n;var t=r.b,o=e,a=z(e,r.a,n);e=o,n=a,r=t}}),gt=Q,bt=d(function(e,n,r){for(;;){if(1<=v(e,n))return r;var t=e,o=n-1,a=z(h,n,r);e=t,n=o,r=a}}),ht=s(function(e,n){return $(bt,e,n,m)}),xt=s(function(e,n){return $(gt,e,z(ht,0,tr(n)-1),n)}),Ct=function(e){return $(pt,h,m,e)},Pt=u(function(e,n,r,t){return{$:0,a:e,b:n,c:r,d:t}}),Tt=[],yt=ie,Lt=s(function(e,n){return fe(n)/fe(e)}),Mt=yt(z(Lt,2,32)),wt=V(Pt,0,Mt,Tt,Tt),Dt=X,Nt=ce,zt=function(e){return e.length},P=s(function(e,n){return 0<v(e,n)?e:n}),$t=J,Vt=s(function(e,n){for(;;){var r=z($t,32,e),t=r.b,r=z(h,{$:0,a:r.a},n);if(!t.b)return Ct(r);e=t,n=r}}),St=s(function(e,n){for(;;){var r=yt(n/32);if(1===r)return z($t,32,e).a;e=z(Vt,e,m),n=r}}),_t=s(function(e,n){var r,t;return n.s?(t=Nt(z(Lt,32,(r=32*n.s)-1)),e=e?Ct(n.G):n.G,e=z(St,e,n.s),V(Pt,zt(n.w)+r,z(P,5,t*Mt),e,n.w)):V(Pt,zt(n.w),Mt,Tt,n.w)}),At=R(function(e,n,r,t,o){for(;;){if(n<0)return z(_t,!1,{G:t,s:r/32|0,w:o});var a={$:1,a:$(Dt,32,n,e)};e=e,n=n-32,r=r,t=z(h,a,t),o=o}}),qt=s(function(e,n){var r;return 0<e?S(At,n,e-(r=e%32)-32,e,m,$(Dt,r,e-r,n)):wt}),T=function(e){return!e.$},Ft=be,Bt=he,Rt=function(e){return{$:0,a:e}},kt=function(e){switch(e.$){case 0:return 0;case 1:return 1;case 2:return 2;default:return 3}},y=we,ne=y(0),Et=u(function(e,n,r,t){var o,a,i,c;return t.b?(o=t.a,(t=t.b).b?(a=t.a,(t=t.b).b?(i=t.a,(t=t.b).b?(c=t.b,z(e,o,z(e,a,z(e,i,z(e,t.a,500<r?$(pt,e,n,Ct(c)):V(Et,e,n,r+1,c)))))):z(e,o,z(e,a,z(e,i,n)))):z(e,o,z(e,a,n))):z(e,o,n)):n}),It=d(function(e,n,r){return V(Et,e,n,0,r)}),L=s(function(r,e){return $(It,s(function(e,n){return z(h,r(e),n)}),m,e)}),M=De,Gt=s(function(n,e){return z(M,function(e){return y(n(e))},e)}),jt=d(function(r,e,t){return z(M,function(n){return z(M,function(e){return y(z(r,n,e))},t)},e)}),Ht=Re,Ut=s(function(e,n){return $e(z(M,Ht(e),n))}),Q=d(function(e,n,r){return z(Gt,function(e){return 0},ir(z(L,Ut(e),n)))}),ie=(Be.Task={b:ne,c:Q,d:d(function(e,n,r){return y(0)}),e:s(function(e,n){return z(Gt,e,n)}),f:void 0},Ee("Task"),xn),Ot={$:0},Wt={$:-2},Yt=Wt,Kt=Yt,Qt=u(function(e,n,r,t){return{$:0,a:e,b:n,c:r,d:t}}),Zt=V(Qt,92/255,53/255,.4,1),Xt=s(function(e,n){return{$:0,a:{aI:Zt,ai:3,O:m,P:e,i:n,aj:3,aQ:"Goblin (level 2)",aB:n,I:m}}}),Jt=d(function(e,n,r){return{ac:e,ad:n,fb:r}}),eo=Ie(m),no=3.141592653589793,ro=function(e){return e},to={$:4},oo=Ie,ao=d(function(e,n,r){return n(e(r))}),io=s(function(e,n){return{$:0,a:e,b:n}}),co=s(function(e,n){return{eN:n,e1:e}}),X=y(z(co,Yt,Yt)),lo=H,uo=s(function(e,n){for(;;){if(-2===n.$)return C;var r=n.c,t=n.d,o=n.e;switch(z(lo,e,n.b)){case 0:e=e,n=t;continue;case 1:return x(r);default:e=e,n=o;continue}}}),w=R(function(e,n,r,t,o){return{$:-1,a:e,b:n,c:r,d:t,e:o}}),fo=R(function(e,n,r,t,o){var a,i,c,l;return-1!==o.$||o.a?-1!==t.$||t.a||-1!==t.d.$||t.d.a?S(w,e,n,r,t,o):(a=t.d,l=t.e,S(w,0,t.b,t.c,S(w,1,a.b,a.c,a.d,a.e),S(w,1,n,r,l,o))):(a=o.b,i=o.c,c=o.d,o=o.e,-1!==t.$||t.a?S(w,e,a,i,S(w,0,n,r,t,c),o):S(w,0,n,r,S(w,1,t.b,t.c,t.d,l=t.e),S(w,1,a,i,c,o)))}),so=d(function(e,n,r){if(-2===r.$)return S(w,0,e,n,Wt,Wt);var t=r.a,o=r.b,a=r.c,i=r.d,c=r.e;switch(z(lo,e,o)){case 0:return S(fo,t,o,a,$(so,e,n,i),c);case 1:return S(w,t,o,n,i,c);default:return S(fo,t,o,a,i,$(so,e,n,c))}}),vo=d(function(e,n,r){e=$(so,e,n,r);return-1!==e.$||e.a?e:S(w,1,e.b,e.c,e.d,e.e)}),mo=s(function(e,n){var r=e.a,e=e.b,t=z(uo,r,n);return $(vo,r,1===t.$?p([e]):z(h,e,t.a),n)}),po=function(r){return{$:2,b:function(e){var n=r.f;2===n.$&&n.c&&n.c(),r.f=null,e({$:0,a:U})},c:null}},go=d(function(e,n,r){for(;;){if(-2===r.$)return n;var t=r.e,o=e,a=$(e,r.b,r.c,$(go,e,n,r.d));e=o,n=a,r=t}}),bo=k(function(l,u,f,e,n,r){e=$(go,d(function(e,n,r){for(;;){var t=r.a,o=r.b;if(!t.b)return{a:t,b:$(f,e,n,o)};var a=t.a,i=a.a,a=a.b,c=t.b;if(0<=v(i,e))return 0<v(i,e)?{a:t,b:$(f,e,n,o)}:{a:c,b:V(u,i,a,n,o)};e=e,n=n,r={a:c,b:$(l,i,a,o)}}}),{a:at(e),b:r},n),r=e.a,n=e.b;return $(pt,s(function(e,n){return $(l,e.a,e.b,n)}),n,r)}),ho=ke,xo=yn,Co=$e,Po=d(function(n,e,r){var t,o;return e.b?(o=e.b,e=Co(z(xo,t=e.a,z(ho,n,t))),z(M,function(e){return $(Po,n,o,$(vo,t,e,r))},e)):y(r)}),ce=d(function(n,e,r){var r=r.eN,t=d(function(e,n,r){var t=r.c;return{a:r.a,b:r.b,c:z(M,function(e){return t},po(n))}}),o=$(pt,mo,Yt,e),e=I(bo,d(function(e,n,r){var t=r.b,o=r.c;return{a:z(h,e,r.a),b:t,c:o}}),u(function(e,n,r,t){var o=t.c;return{a:t.a,b:$(vo,e,r,t.b),c:o}}),t,o,r,{a:m,b:Yt,c:y(0)}),a=e.a,i=e.b;return z(M,function(e){return y(z(co,o,e))},z(M,function(e){return $(Po,n,a,i)},e.c))}),To=ar,yo=(et=To,{$:2,b:function(e){e({$:0,a:et(Date.now())})},c:null}),J=d(function(r,e,n){var t,e=z(uo,e,n.e1);return 1===e.$?y(n):(t=e.a,z(M,function(e){return y(n)},z(M,function(n){return ir(z(L,function(e){return z(Ht,r,e(n))},t))},yo)))}),Lo=d(function(e,n,r){return e(n(r))}),Mo=(Be.Time={b:X,c:ce,d:J,e:0,f:s(function(e,n){return z(io,n.a,z(Lo,e,n.b))})},Ee("Time")),wo=s(function(e,n){return Mo(z(io,e,n))}),Do=ge,No=me,zo=d(function(e,n,r){return{c9:r,eR:n,e$:e}}),$o=y($(zo,m,C,0)),Vo={$:2,b:function(e){e({$:0,a:Date.now()})},c:null},So={$:2,b:function(e){var n=Pn(function(){e({$:0,a:Date.now()})});return function(){Cn(n)}},c:null},be=d(function(e,r,n){var t=n.eR,n=n.c9,o={a:t,b:r};return 1===o.a.$?o.b.b?z(M,function(n){return z(M,function(e){return y($(zo,r,x(n),e))},Vo)},Co(z(M,ho(e),So))):$o:o.b.b?y($(zo,r,t,n)):z(M,function(e){return $o},po(o.a.a))}),he=d(function(n,r,e){function t(e){return z(Ht,n,e.$?(0,e.a)(r-a):(0,e.a)(To(r)))}var o=e.e$,a=e.c9;return z(M,function(n){return z(M,function(e){return y($(zo,o,x(n),r))},ir(z(L,t,o)))},Co(z(M,ho(n),So)))}),_o=(Be["Browser.AnimationManager"]={b:$o,c:be,d:he,e:0,f:s(function(e,n){return n.$?{$:1,a:z(Lo,e,n.a)}:{$:0,a:z(Lo,e,n.a)}})},Ee("Browser.AnimationManager")),Ao=function(e){return _o({$:0,a:e})},qo=d(function(e,n,r){return{$:0,a:e,b:n,c:r}}),Fo=s(function(e,n){return{eJ:n,e$:e}}),Re=y(z(Fo,m,Yt)),Bo=s(function(e,n){return{dU:n,d3:e}}),Ro=d(function(n,r,e){return z(Gt,function(e){return{a:r,b:e}},$(wn,e.a?Mn:Ln,e.b,function(e){return z(ho,n,z(Bo,r,e))}))}),ko=s(function(e,n){return $(go,vo,n,e)}),ne=d(function(o,e,n){var r=d(function(e,n,r){var t=r.c;return{a:r.a,b:r.b,c:z(h,$(Ro,o,e,n),t)}}),t=d(function(e,n,r){var t=r.b,o=r.c;return{a:z(h,n,r.a),b:t,c:o}}),a=u(function(e,n,r,t){var o=t.c;return{a:t.a,b:$(vo,e,n,t.b),c:o}}),i=z(L,sr,e),e=I(bo,t,a,r,n.eJ,dr(i),{a:m,b:Yt,c:m}),c=e.b,l=e.c;return z(M,function(e){return y(z(Fo,i,z(ko,c,dr(e))))},z(M,function(e){return ir(l)},ir(z(L,po,e.a))))}),Eo=d(function(e,n,r){e=e(n);return e.$?r:z(h,e.a,r)}),Io=s(function(e,n){return $(It,Eo(e),m,n)}),Q=d(function(e,n,r){var t=n.d3,o=n.dU,n=z(Io,function(e){var n=e.b,n=n.c;return l(e.a,t)?z(Dn,n,o):C},r.e$);return z(M,function(e){return y(r)},ir(z(L,Ht(e),n)))}),Go=(Be["Browser.Events"]={b:Re,c:ne,d:Q,e:0,f:s(function(e,n){return $(qo,n.a,n.b,z(Ft,e,n.c))})},Ee("Browser.Events")),xn=d(function(e,n,r){return Go($(qo,e,n,r))}),jo=z(xn,0,"keydown"),Ho=z(xn,0,"keyup"),Uo=z(xn,0,"mousedown"),Oo=s(function(e,n){return{ac:e,ad:n}}),Wo=pe,Yo=s(function(e,n){return z(lo,e,n)}),D=function(e){return e<0?-e:e},Ko=ue,Qo=0,Zo=s(function(e,n){var r=n.fb-e.fb,t=n.ad-e.ad,n=n.ac-e.ac,e=z(P,D(n),z(P,D(t),D(r)));return e?Ko((n=n/e)*n+(n=t/e)*n+(t=r/e)*t)*e:Qo}),o=d(function(e,n,r){return{ac:e,ad:n,fb:r}}),Xo=s(function(e,n){return{ac:n.ac+e.ac,ad:n.ad+e.ad,fb:n.fb+e.fb}}),Jo=s(function(e,n){return pr(z(Xo,e,b(n)))}),ea=Z,na=s(function(e,n){return n.$?e:n.a}),ra=s(function(e,r){return z(na,z(Jo,$(o,1,0,0),e),mr(z(ea,s(function(e,n){return z(Yo,z(Zo,r,e),z(Zo,r,n))}),p([z(Jo,$(o,1,0,0),e),z(Jo,$(o,-1,0,0),e),z(Jo,$(o,0,1,0),e),z(Jo,$(o,0,-1,0),e)]))))}),ta=s(function(r,e){return $(It,s(function(e,n){return r(e)?z(h,e,n):n}),m,e)}),oa=s(function(e,n){return!z(uo,e,n).$}),aa=s(function(e,n){return z(oa,e,n)}),ia=s(function(e,n){return-1<v(e,n.dp)?{$:0,a:{aI:n.aI,ai:n.aj,O:m,P:n.P,i:n.aB,aj:n.aj,aQ:n.aQ,aB:n.aB,I:m}}:{$:1,a:n}}),ca=d(function(e,n,r){return v(r,e)<0?e:0<v(r,n)?n:r}),la=s(function(e,n){return{ac:n.ac-e.ac,ad:n.ad-e.ad,fb:n.fb-e.fb}}),ua={ac:0,ad:0,fb:0},fa=s(function(e,n){var r,t;return l(e,n)?m:(r=$(ca,-1,1,b(n).ad-b(e).ad),t=$(ca,-1,1,b(n).ac-b(e).ac),t=pr(z(Xo,z(la,ua,$(Jt,t,r,0)),z(la,ua,e))),z(h,t,z(fa,t,n)))}),sa=d(function(e,n,r){for(;;){if(e<=0)return r;if(!n.b)return r;var t=n.a;e=e-1,n=n.b,r=z(h,t,r)}}),da=s(function(e,n){return Ct($(sa,e,n,m))}),va=d(function(e,n,r){if(0<n){var t,o,a,i,c,l={a:n,b:r};e:for(;;){n:for(;;){if(!l.b.b)return r;if(!l.b.b.b){if(1===l.a)break e;break}switch(l.a){case 1:break e;case 2:var u=l.b;return p([u.a,u.b.a]);case 3:if(l.b.b.b.b)return p([(u=l.b).a,(t=u.b).a,t.b.a]);break n;default:if(l.b.b.b.b&&l.b.b.b.b.b)return c=(i=(a=(o=(t=l.b).b).b).b).b,z(h,t.a,z(h,o.a,z(h,a.a,z(h,i.a,1e3<e?z(da,n-4,c):$(va,e+1,n-4,c)))));break n}}return r}return p([l.b.a])}return m}),ma=s(function(e,n){return $(va,0,e,n)}),pa=s(function(e,n){return v(e,n)<0?e:n}),ga={ac:0,ad:0,fb:0},ba=s(function(e,n){var r,t=z(P,D(n.ac),z(P,D(n.ad),D(n.fb)));return t?{ac:e*(r=n.ac/t)/(t=Ko(r*r+(r=n.ad/t)*r+(n=n.fb/t)*n)),ad:e*r/t,fb:e*n/t}:ga}),ha=s(function(r,e){function n(e){return pr(z(Xo,z(la,ua,r),(n=z(pa,.05,gr(br(e=z(la,r,e)))),z(ba,n,e))));var n}var t,o;return e.b?(o=e.b,l(r,t=e.a)?o.b?{a:n(o.a),b:o}:{a:r,b:m}:{a:n(t),b:e}):{a:r,b:e}}),xa=s(function(t,o){var e=s(function(e,n){return cr(e+n/(2*no))}),n=z(L,function(e){var n,r;return e.$?z(ia,t,n=e.a):(r=(e=z(ha,(n=e.a).i,n.I)).a,e=e.b,{$:0,a:f(n,{O:z(ta,function(e){return 0<v(e.bG,t)},n.O),i:r,I:2===(r=o.K).$&&l(n.P,r.a.P)?z(ma,1,e):e})})},o.S),r=z(ta,function(e){return 0<v(e.bG,t)},o.O),a=function(){var e=o.K;switch(e.$){case 1:case 2:var n=z(na,(n=e.a).i,mr(n.I)),n=z(ra,n,o.i);return z(ha,o.i,z(fa,o.i,n));default:return z(ha,o.i,o.I)}}(),i=a.b,c=(c={a:i,b:o.K}).a.b||1!==c.b.$?o.K:{$:2,a:c.b.a},c=f(o,{K:c,O:r,i:a.a,S:n,bT:t,I:i});return z(aa,"ArrowLeft",o.aL)?f(c,{a0:z(e,-.005,o.a0)}):z(aa,"ArrowRight",o.aL)?f(c,{a0:z(e,.005,o.a0)}):c}),Ca=s(function(n,e){return mr(z(Io,function(e){return!e.$&&l((e=e.a).P,n)?x(e):C},e))}),Pa=d(function(n,r,e){return z(L,function(e){return e.$?{$:1,a:e.a}:l((e=e.a).P,n)?r(e):{$:0,a:e}},e)}),Ta=d(function(e,r,t){var o,n,a=t.K;return 2===a.$?(o=t.bT+500,n=$(Pa,(a=a.a).P,function(e){var n=e.ai-r;return 0<n?{$:0,a:f(e,{ai:n,O:z(h,{b8:r,bG:o},e.O)})}:{$:1,a:{aI:e.aI,P:e.P,aj:e.aj,aQ:e.aQ,dp:t.bT+2e4,aB:e.aB}}},t.S),f(t,{bc:t.ax?t.bc:t.bc+r,K:1===(a=z(Ca,a.P,n)).$?Ot:{$:2,a:a.a},bf:2===t.ax?t.bf+r:t.bf,ai:z(P,1,t.ai-e),O:z(h,{b8:1===t.ai?0:e,bG:o},t.O),S:n,bt:1===t.ax?t.bt+r:t.bt})):t}),ya=d(function(e,n,r){var t;return 0<e?(t=(r.ac-n.ac)/e)*t+(t=(r.ad-n.ad)/e)*t+(t=(r.fb-n.fb)/e)*t<=1:!e&&l(n.ac,r.ac)&&l(n.ad,r.ad)&&l(n.fb,r.fb)}),La=function(e){return-e},Ma=s(function(e,n){return{ac:e.ad*n.fb-e.fb*n.ad,ad:e.fb*n.ac-e.ac*n.fb,fb:e.ac*n.ad-e.ad*n.ac}}),wa=function(e){return e.dD},Da=function(e){return e.dE},Na=function(e){return z(Ma,wa(e),Da(e))},za=te,$a=oe,Va=d(function(e,n,r){var n=.5*n,t=za(n),n=$a(n),e=e.fx,o=e.ac*n,a=t*o,i=o*o,c=e.ad*n,l=t*c,u=o*c,f=c*c,e=e.fb*n,n=t*e,t=o*e,o=c*e,c=e*e;return{ac:(1-2*(f+c))*r.ac+2*(u-n)*r.ad+2*(t+l)*r.fb,ad:2*(u+n)*r.ac+(1-2*(i+c))*r.ad+2*(o-a)*r.fb,fb:2*(t-l)*r.ac+2*(o+a)*r.ad+(1-2*(i+f))*r.fb}}),Sa=d(function(e,n,r){var n=.5*n,t=za(n),n=$a(n),o=e.da,a=r.ac-o.ac,i=r.ad-o.ad,r=r.fb-o.fb,e=e.fx,c=e.ac*n,l=t*c,u=c*c,f=e.ad*n,s=t*f,d=c*f,v=f*f,e=e.fb*n,n=t*e,t=c*e,c=f*e,f=e*e;return{ac:o.ac+(1-2*(v+f))*a+2*(d-n)*i+2*(t+s)*r,ad:o.ad+2*(d+n)*a+(1-2*(u+f))*i+2*(c-l)*r,fb:o.fb+2*(t-s)*a+2*(c+l)*i+(1-2*(u+v))*r}}),_a=function(e){return e},Aa=function(e){return e.dD},qa=function(e){return e.dE},Fa=d(function(e,n,r){return _a({da:$(Sa,e,n,xr(r)),dD:$(Va,e,n,Aa(r)),dE:$(Va,e,n,qa(r)),dF:$(Va,e,n,Cr(r))})}),Ba=d(function(e,n,r){return $(Fa,e(r),n,r)}),Ra=s(function(e,n){return{ac:n.ac+e.ac,ad:n.ad+e.ad,fb:n.fb+e.fb}}),ka=s(function(e,n){return _a({da:z(Ra,e,xr(n)),dD:Aa(n),dE:qa(n),dF:Cr(n)})}),Ea=s(function(e,n){return{ac:e*n.ac,ad:e*n.ad,fb:e*n.fb}}),Ia=d(function(e,n,r){return z(ka,z(Ea,n,e),r)}),Ga=d(function(e,n,r){return $(Ia,Pr(e(r)),n,r)}),ja=s(function(e,n){return{fx:n,da:e}}),Ha=function(e){return z(ja,e.da,e.dD)},Ua=function(e){return z(ja,e.da,e.dE)},Oa=function(e){return z(ja,e.da,e.dF)},Wa=function(e){return{$:0,a:e}},N=function(e){return D(e)},Ya=function(e){return.5*e},Ka=ae,Qa=function(e){return Ka(e)},H={ac:1,ad:0,fb:0},ke={ac:0,ad:1,fb:0},Za=ar({da:ua,dD:H,dE:ke}),Xa=function(e){return function(e){var n=Ya(N(e.gz)),n=Qa(n);return{dl:Wa(n),gB:e.gB}}({gz:hr(30),gB:(e={fg:e.a0,fy:15,fD:hr(30),fN:e.i,fO:Za},n=_a({da:e.fN,dD:Da(e.fO),dE:Na(e.fO),dF:wa(e.fO)}),$(Ga,Oa,e.fy,$(Ba,Ha,La(e.fD),$(Ba,Ua,e.fg,n))))});var n},Ja=s(function(e,n){return n.ac*e.ac+n.ad*e.ad+n.fb*e.fb}),ei=s(function(e,n){return e*n}),ni=s(function(e,n){var r=e.da,e=e.gd;return(n.ac-r.ac)*e.ac+(n.ad-r.ad)*e.ad+(n.fb-r.fb)*e.fb}),ri=d(function(e,n,r){return{ac:r.ac+n*e.ac,ad:r.ad+n*e.ad,fb:r.fb+n*e.fb}}),ti=s(function(e,n){var r=Pr(n),t=z(Ja,e.gd,r);return t?(n=function(e){return e.da}(n),x($(ri,r,z(ei,-1/t,z(ni,e,n)),n))):C}),oi=s(function(e,n){return n.$?C:x(e(n.a))}),ai=s(function(e,n){return n=b(n),r=n.ad,t=n.fb,{ac:e(n.ac),ad:e(r),fb:e(t)};var r,t}),ii=s(function(e,n){return e*n}),ci=s(function(e,n){return n/e}),li={ac:0,ad:0,fb:-1},ui=s(function(e,n){return n/e}),fi=s(function(e,n){var r=e.dF,t=e.dE,e=e.dD;return{ac:e.ac*n.ac+t.ac*n.ad+r.ac*n.fb,ad:e.ad*n.ac+t.ad*n.ad+r.ad*n.fb,fb:e.fb*n.ac+t.fb*n.ad+r.fb*n.fb}}),si=s(function(e,n){var r=e.da,e=e.dD;return(n.ac-r.ac)*e.ac+(n.ad-r.ad)*e.ad}),di=d(function(e,n,r){return{ac:e,ad:n,fb:r}}),vi=u(function(e,n,r,t){var o=e.da,a=e.dF,i=e.dE,e=e.dD;return{ac:o.ac+n*e.ac+r*i.ac+t*a.ac,ad:o.ad+n*e.ad+r*i.ad+t*a.ad,fb:o.fb+n*e.fb+r*i.fb+t*a.fb}}),mi=s(function(e,n){var r=e.da,e=e.dE;return(n.ac-r.ac)*e.ac+(n.ad-r.ad)*e.ad}),pi=d(function(e,n,r){var t,o=z(mi,Tr(n),r),r=z(si,Tr(n),r),a=e.gB,n=yr(n),n=n.b,i=e.dl;return i.$?z(ja,V(vi,a,z(ii,t=z(ui,n,i.a),r),z(ii,t,o),Qo),wr(e.gB)):(t=La(z(ci,i.a,z(ei,.5,n))),i=z(fi,a,z(na,li,function(e){var n,r,t=z(P,D(e.ac),z(P,D(e.ad),D(e.fb)));return t?(t=Ko((r=e.ac/t)*r+(n=e.ad/t)*n+(e=e.fb/t)*e),x({ac:r/t,ad:n/t,fb:e/t})):C}($(di,r,o,t)))),z(ja,Lr(e.gB),i))}),gi=le,bi=s(function(e,n){return-1<v(n,e)}),hi=s(function(e,n){return e+.5*(n-e)}),xi=s(function(e,n){return n-e}),Ci={ac:-1,ad:0},Pi={ac:0,ad:-1},Ti={ac:1,ad:0},yi={ac:0,ad:1},Li=s(function(e,n){return{ac:e,ad:n}}),Mi=V(u(function(e,n,r,t){var o=z(bi,n,t)?yi:Pi,a=z(bi,e,r)?Ti:Ci,i={a:N(z(xi,e,r)),b:N(z(xi,n,t))};return{ff:{da:z(Li,z(hi,e,r),z(hi,n,t)),dD:a,dE:o},fw:i}}),(yn={gE:0,gF:800,gH:600,gI:0}).gE,yn.gH,yn.gF,yn.gI),wi=function(e){return e},X={ac:0,ad:0,fb:1},Di=z(s(function(e,n){return{gd:n,da:e}}),ua,X),Ni=s(function(e,n){var r,t,o=$(pi,Xa(n),Mi,e),o=z(oi,ai(z(ao,gi,or)),z(ti,Di,o));return 0<v(wi(e).ac,800)||0<v(wi(e).ad,600)||1===o.$?n:(r=o.a,e=z(na,n.i,mr(n.I)),o=mr(z(ta,function(e){return!e.$&&$(ya,.5,r,e.a.i)},n.S)),f(n,o.$||o.a.$?{K:Ot,I:(t=z(fa,e,r)).b?t:p([r])}:{K:{$:1,a:o.a.a},I:z(ta,function(e){return!l(e,n.i)},z(h,e,z(fa,e,z(ra,r,n.i))))}))}),zi=s(function(e,n){return{$:5,a:e,b:n}}),$i=s(function(e,n){return{$:0,a:e,b:n}}),ce=z(M,function(e){return y((e=vr(e),n=Dr(z($i,0,1013904223)),Dr(z($i,n.a+e>>>0,n.b))));var n},yo),Vi=s(function(e,n){return e(n)}),Si=d(function(n,e,r){var t,o;return e.b?(t=e.b,o=(e=z(Vi,e.a,r)).b,z(M,function(e){return $(Si,n,t,o)},z(Ht,n,e.a))):y(r)}),J=d(function(e,n,r){return y(r)}),_i=s(function(r,e){var t=e;return function(e){var e=t(e),n=e.b;return{a:r(e.a),b:n}}}),Ai=(Be.Random={b:ce,c:Si,d:J,e:s(function(e,n){return z(_i,e,n)}),f:void 0},Ee("Random")),qi=s(function(e,n){return Ai(z(_i,e,n))}),ge=s(function(l,u){return function(e){var n=v(l,u)<0?{a:l,b:u}:{a:u,b:l},r=n.a,t=n.b-r+1;if(!(t-1&t))return{a:((t-1&Nr(e))>>>0)+r,b:Dr(e)};for(var o=(-t>>>0)%t>>>0,a=e;;){var i=Nr(a),c=Dr(a);if(0<=v(i,o))return{a:i%t+r,b:c};a=c}}}),Fi=d(function(t,e,n){var o=e,a=n;return function(e){var e=o(e),n=e.a,e=a(e.b),r=e.b;return{a:z(t,n,e.a),b:r}}}),Bi=z(qi,function(e){return z(zi,e.a,e.b)},z(s(function(e,n){return $(Fi,s(function(e,n){return{a:e,b:n}}),e,n)}),z(ge,0,1),z(ge,0,1))),Ri=s(function(e,n){return pr(z(Xo,z(la,ua,e),z(la,ua,n)))}),ki=u(function(e,n,r,t){for(;;){if(n<1)return{a:e,b:t};var o=r(t),a=o.b;e=z(h,o.a,e),n=n-1,r=r,t=a}}),Ei=s(function(n,e){var r=e;return function(e){return V(ki,m,n,r,e)}}),Ii=s(function(e,n){return{a:n.a,b:e(n.b)}}),Gi=s(function(o,a){return function(e){var n=Dr(e),r=D(a-o),t=Nr(n);return{a:(134217728*(67108863&Nr(e))+(134217727&t))/9007199254740992*r+o,b:Dr(n)}}}),ji=d(function(e,n,r){for(;;){var t=e.a,o=e.b;if(!n.b)return o;var a=n.a,i=n.b;if(v(r,D(t))<1)return o;e=a,n=i,r=r-D(t)}}),Hi=s(function(e,n){function r(e){return D(e.a)}var t=r(e)+$(pt,dt,0,z(L,r,n));return z(_i,z(ji,e,n),z(Gi,0,t))}),Ui=s(function(e,n){return n.b?$(It,h,n,e):e}),Oi=s(function(e,n){return Vr(z(L,e,n))}),Wi=s(function(e,r){return z(Oi,function(n){return z(L,function(e){return{a:e,b:n}},z(ht,e,r))},z(ht,e,r))}),Yi=s(function(e,n){return z(L,function(e){return{a:1,b:e}},z(Wi,e,n))}),Ki=s(function(e,n){return $(vo,e,0,n)}),Qi=E(function(e,n,r,t,o,a,i){if(-1!==a.$||a.a){for(;;){if(-1!==i.$||1!==i.a)break;if(-1!==i.d.$)return _r(n);if(1===i.d.a)return _r(n);break}return n}return S(w,r,a.b,a.c,a.d,S(w,0,t,o,a.e,i))}),Zi=s(function(e,n){var r,t,o,a,i,c,l;return-2===n.$?Wt:(r=n.a,o=n.c,a=n.d,i=n.e,v(e,t=n.b)<0?-1===a.$&&1===a.a?-1!==(c=a.d).$||c.a?-1===(c=Sr(n)).$?(l=c.e,S(fo,c.a,c.b,c.c,z(Zi,e,c.d),l)):Wt:S(w,r,t,o,z(Zi,e,a),i):S(w,r,t,o,z(Zi,e,a),i):z(Xi,e,G(Qi,e,n,r,t,o,a,i)))}),Xi=s(function(e,n){var r,t,o,a,i;return-1===n.$?(r=n.a,t=n.c,o=n.d,a=n.e,l(e,n=n.b)?-1===(i=function(e){for(;;){if(-1!==e.$||-1!==e.d.$)return e;e=e.d}}(a)).$?S(fo,r,i.b,i.c,o,Ar(a)):Wt:S(fo,r,n,t,o,z(Zi,e,a))):Wt}),Ji=s(function(e,n){e=z(Zi,e,n);return-1!==e.$||e.a?e:S(w,1,e.b,e.c,e.d,e.e)}),ec=s(function(e,n){return z(Ji,e,n)}),me=s(function(e,o){switch(e.$){case 0:return{a:z(xa,e.a,o),b:(r=o.S,z(qi,zr,z(_i,function(e){return $(gt,s(function(e,n){e={a:e,b:n};return e.a.$||e.b.$?C:x(z(fa,(n=e.b.a).i,z(Ri,e.a.a,n.aB)))}),e,r)},z(_i,L(oi($r)),z(Ei,tr(r),z(Hi,{a:300,b:C},z(L,Ii(x),z(Yi,-1,1))))))))};case 1:return{a:z(Ni,e.a,o),b:eo};case 2:return{a:f(o,{aL:z(Ki,e.a,o.aL)}),b:eo};case 3:return{a:f(o,{aL:z(ec,e.a,o.aL)}),b:eo};case 4:return{a:o,b:Bi};case 5:return{a:$(Ta,e.a,e.b,o),b:eo};case 6:return{a:f(o,{ax:e.a}),b:eo};default:var n=e.a,n=$(gt,s(function(e,n){var r,t,n={a:e,b:n};return n.a.$||n.b.$||(r=n.a.a,n=n.b.a,2===(t=o.K).$&&l(t.a.P,r.P))?e:{$:0,a:f(r,{I:n})}}),o.S,n);return{a:f(o,{S:n}),b:eo}}var r}),nc=V(Qt,186/255,189/255,182/255,1),rc=V(Qt,78/255,154/255,6/255,1),a=Ke("div"),be=s(function(e,n){switch(n){case"G":return 0;case"R":return 1;default:return e}}),tc=z(L,z(ao,Y(""),L(be(0))),p(["GGGGRRGGGG","GGGGRRGGGG","GGGGRRGGGG","GGGGRRGGGG","GGGGRRGGGG","GGGGRRRRRR","GGGGRRRRRR","GGGGRRGGGG","GGGGRRGGGG","GGGGRRGGGG"])),oc=tr(tc)/2,ac=V(Qt,52/255,101/255,164/255,1),ic=V(Qt,32/255,74/255,135/255,1),cc=V(Qt,164/255,0,0,1),q=Xe,i=Ye,lc=V(u(function(e,n,r,t){return V(Qt,e,n,r,t)}),0,0,0,0),uc=function(e){return{$:0,a:e}},fc={$:3},sc=u(function(e,n,r,t){return{$:4,a:e,b:n,c:r,d:t}}),dc=function(e){return{$:1,a:e}},vc=function(e){return{$:2,a:e}},mc=ve,pc=s(function(e,n){switch(n.$){case 0:return z(qn,e,n);case 1:return z(Fn,e,n);case 2:return z(Bn,e,n);case 3:return z(Rn,e,n);case 4:return z(kn,e,n);case 5:return z(En,e,n);case 6:return z(In,e,n);case 7:return z(Gn,e,n);default:return function(e){var n=e.sampleAlphaToCoverage;n.toggle=e.toggle,n.enabled||(e.gl.enable(e.gl.SAMPLE_ALPHA_TO_COVERAGE),n.enabled=!0)}(e)}}),gc=d(function(e,n,r){return $(Qn,e,n,r)}),bc=rr,hc=V(bc,1,1,1,1),F=d(function(e,n,r){return z(L,function(e){return z(e,n,r)},e)}),xc=d(function(e,n,r){return{$:0,a:e,b:n,c:r}}),Cc=s(function(e,n){var r=n.ac,n=n.ad;return $(xc,e*r/n,e,e*(1-r-n)/n)}),Pc=er,Tc=s(function(e,n){return $(Pc,3.2406*(n=(e=z(Cc,e,n)).a)-1.5372*(r=e.b)-.4986*(e=e.c),-.9689*n+1.8758*r+.0415*e,.0557*n-.204*r+1.057*e);var r}),yc=s(function(e,n){return{d2:l(e.d2,n.d2),x:e.x*n.x+e.y*n.A+e.z*n.D,y:e.x*n.y+e.y*n.B+e.z*n.E,z:e.x*n.z+e.y*n.C+e.z*n.F,A:e.A*n.x+e.B*n.A+e.C*n.D,B:e.A*n.y+e.B*n.B+e.C*n.E,C:e.A*n.z+e.B*n.C+e.C*n.F,D:e.D*n.x+e.E*n.A+e.F*n.D,E:e.D*n.y+e.E*n.B+e.F*n.E,F:e.D*n.z+e.E*n.C+e.F*n.F,T:n.T+(e.T*n.x+e.U*n.A+e.V*n.D)*n.cC,U:n.U+(e.T*n.y+e.U*n.B+e.V*n.E)*n.cC,V:n.V+(e.T*n.z+e.U*n.C+e.V*n.F)*n.cC,cC:e.cC*n.cC}}),Lc=function(e){var n=new Float64Array(16);return n[0]=e.ec,n[1]=e.eg,n[2]=e.ek,n[3]=e.eo,n[4]=e.ed,n[5]=e.eh,n[6]=e.el,n[7]=e.ep,n[8]=e.ee,n[9]=e.ei,n[10]=e.em,n[11]=e.eq,n[12]=e.ef,n[13]=e.ej,n[14]=e.en,n[15]=e.er,n},Mc=R(function(e,n,r,t,o){return I(o,e,V(bc,t.cC,t.cC,t.cC,t.d2?1:-1),function(e){return Lc({ec:e.x,ed:e.A,ee:e.D,ef:e.T,eg:e.y,eh:e.B,ei:e.E,ej:e.U,ek:e.z,el:e.C,em:e.F,en:e.V,eo:0,ep:0,eq:0,er:1})}(t),t.d2,n,r)}),wc=k(function(e,n,r,t,o,a){for(;;)switch(o.$){case 0:return a;case 5:var i=o.b;e=e,n=n,r=r,t=z(yc,o.a,t),o=i,a=a;continue;case 1:return{_:z(h,S(Mc,e,n,r,t,o.b),a._),am:a.am,ao:a.ao};case 3:i=z(h,S(Mc,e,n,r,t,o.b),a.am);return{_:a._,am:i,ao:a.ao};case 2:var c=z(h,S(Mc,e,n,r,t,o.a),a.ao);return{_:a._,am:a.am,ao:c};default:c=o.a;return $(pt,V(wc,e,n,r,t),a,c)}}),Dc=u(function(e,n,r,t){return{$:4,a:e,b:n,c:r,d:t}}),Nc=u(function(e,n,r,t){return{$:1,a:e,b:n,c:r,d:t}}),he=s(function(e,n){return{$:6,a:e,b:n}}),zc=p([function(e){return V(Nc,518,e.av,e.aq,e.ap)}({ap:1,aq:0,av:!1}),V(Dc,!1,!1,!1,!1),z(he,0,1)]),$c={src:"\n        precision lowp float;\n\n        void main() {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n    ",attributes:{},uniforms:{}},B=An,Re=s(function(e,n){return{$:0,a:e,b:n}}),ne=Re({dR:1,d0:0,eA:5}),r=Jn,Vc=ne(p([{cv:z(r,-1,-1)},{cv:z(r,1,-1)},{cv:z(r,-1,1)},{cv:z(r,1,1)}])),Sc={src:"\n        precision lowp float;\n\n        attribute vec2 position;\n\n        void main() {\n            gl_Position = vec4(position, 0.0, 1.0);\n        }\n    ",attributes:{position:"cv"},uniforms:{}},_c=d(function(e,n,r){function t(e){return z(ao,i(e.bZ),z(ao,c(e.bJ),z(ao,c(e.b5),c(e.b6))))}var o=e.dn,a=e.c0,e=e.dC,i=s(function(e,n){return n(e)}),c=s(function(e,n){return n(e)});return z(t,r,z(t,n,$(Rr,o,a,e)))}),Ac=Er({bJ:7681,c0:0,dn:8,bZ:519,dC:15,b5:7681,b6:7681}),qc=re,Fc=d(function(e,n,r){return Vr(p([$(F,e,r,zc),p([Ir(n),Ac])]))}),Bc=s(function(e,n){return Vr(z(xt,Fc(e),n))}),Q=function(e){return V(Nc,513,e.av,e.aq,e.ap)}({ap:1,aq:0,av:!0}),Rc=d(function(e,n,r){return{$:0,a:e,b:n,c:r}}),xn=s(function(e,n){return $(Rc,32774,e,n)}),kc=function(e){var a=e.cx,i=e.ch,c=e.ca,l=e.b7,n=e.aI,e=e.bd;return z(s(function(e,n){var r=e.c,t=n.a,o=n.b,n=n.c;return function(u){return function(l){return function(c){return function(i){return function(a){return function(o){return function(t){return function(r){return function(n){return function(e){return{$:0,a:u,b:l,c:c,d:i,e:a,f:o,g:t,h:r,i:n,j:e}}}}}}}}}}}(e.a)(e.b)(r)(t)(o)(n)(a)(i)(c)(l)}),n,e)}({b7:0,bd:z(xn,1,771),ca:0,aI:z(xn,770,771),ch:0,cx:0}),Ec=p([Q,kc]),Ic=function(e){return e.et},Gc=function(e){return e.eu},jc=function(e){return e.ev},Hc=function(e){return e.ew},Uc=function(e){return e.ex},Oc=function(e){return e.ey},Wc=s(function(e,n){var r=e.dF,t=e.dE,e=e.dD;return{ac:n.ac*e.ac+n.ad*e.ad+n.fb*e.fb,ad:n.ac*t.ac+n.ad*t.ad+n.fb*t.fb,fb:n.ac*r.ac+n.ad*r.ad+n.fb*r.fb}}),Yc=s(function(e,n){var r=e.da,t=n.ac-r.ac,o=n.ad-r.ad,n=n.fb-r.fb,r=e.dF,a=e.dE,e=e.dD;return{ac:t*e.ac+o*e.ad+n*e.fb,ad:t*a.ac+o*a.ad+n*a.fb,fb:t*r.ac+o*r.ad+n*r.fb}}),Kc=s(function(e,n){return{da:z(Yc,e,xr(n)),dD:z(Wc,e,Aa(n)),dE:z(Wc,e,qa(n)),dF:z(Wc,e,Cr(n))}}),Qc=s(function(e,n){return z(P,e,n)}),Zc=s(function(e,n){return z(pa,e,n)}),Xc=s(function(e,n){n=jr(n),e=jr(e);return{et:z(Qc,e.et,n.et),eu:z(Qc,e.eu,n.eu),ev:z(Qc,e.ev,n.ev),ew:z(Zc,e.ew,n.ew),ex:z(Zc,e.ex,n.ex),ey:z(Zc,e.ey,n.ey)}}),Jc=s(function(e,n){return n+e}),el=s(function(e,n){var r=e.a,t=e.c,e=Ya(N(e.b)),r=Ya(N(r)),t=Ya(N(t)),n=function(e){return{a:e.ac,b:e.ad,c:e.fb}}(n),o=n.a,a=n.b,n=n.c;return{et:z(Jc,r,o),eu:z(Jc,e,a),ev:z(Jc,t,n),ew:z(xi,r,o),ex:z(xi,e,a),ey:z(xi,t,n)}}),nl=u(function(e,n,r,t){var o=r.fp,a=2*r.fR*n,i=2*r.fQ*n,r=2*r.fP*n,c=o.fb*n,l=o.ad*n,o=o.ac*n,n=Hr(Cr(e)),n=D(r*n.ac)+D(i*n.ad)+D(a*n.fb),u=Hr(qa(e)),u=D(r*u.ac)+D(i*u.ad)+D(a*u.fb),f=Hr(Aa(e)),r=D(r*f.ac)+D(i*f.ad)+D(a*f.fb),i=z(el,{a:r,b:u,c:n},z(Yc,e,$(Jt,o,l,c)));return x(t.$?i:z(Xc,t.a,i))}),rl=u(function(e,n,r,t){for(;;){if(!t.b)return r;var o=t.a,a=t.b;switch(o.$){case 0:e=c=e,n=l=n,r=u=r,t=a;continue;case 1:var i=V(nl,e,n,o.a,r);e=c=e,n=l=n,r=u=i,t=a;continue;case 2:e=c=e,n=l=n,r=u=r,t=a;continue;case 3:i=V(nl,e,n,o.a,r);e=c=e,n=l=n,r=u=i,t=a;continue;case 4:var c=e,l=n,u=V(rl,e,n,r,o.a);e=c,n=l,r=u,t=a;continue;default:var f=o.a,s=o.b,d=z(Kc,function(e){return _a({da:{ac:e.T,ad:e.U,fb:e.V},dD:{ac:e.x,ad:e.y,fb:e.z},dE:{ac:e.A,ad:e.B,fb:e.C},dF:{ac:e.D,ad:e.E,fb:e.F}})}(f),e),f=n*f.cC;e=c=e,n=l=n,r=u=V(rl,d,f,r,p([s])),t=a;continue}}}),tl=function(e){return e[0]},ol=function(e){return e[1]},al=function(e){return e[2]},il=function(e){return{$:4,a:e}},cl=s(function(e,n){for(;;){if(!e.b)return n;var r=e.a;e=e.b,n=z(h,r,n)}}),ll={d2:!0,x:1,y:0,z:0,A:0,B:1,C:0,D:0,E:0,F:1,T:0,U:0,V:0,cC:1},ul=Er({bJ:7681,c0:0,dn:8,bZ:519,dC:255,b5:7681,b6:7681}),pe={ca:0,fo:!1,ch:0,dj:0,cx:0,gw:0,ac:0,ad:0,fb:0},ue=s(function(e,n){return Lc({ec:e.ac,ed:e.cx,ee:n.ac,ef:n.cx,eg:e.ad,eh:e.ch,ei:n.ad,ej:n.ch,ek:e.fb,el:e.ca,em:n.fb,en:n.ca,eo:e.gw,ep:e.dj,eq:n.gw,er:n.dj})}),fl={a:{bP:z(ue,pe,pe),cl:z(ue,pe,pe),cm:z(ue,pe,pe),cn:z(ue,pe,pe)},b:V(bc,0,0,0,0)},sl=p([Or({ap:1,aq:0,av:!0}),kr({bJ:7680,c0:240,dn:0,bZ:514,dC:0,b5:7680,b6:7680}),kc]),dl=function(e){return e===1/0||e===-1/0},vl=s(function(e,n){var r,t=n.fM,o=n.fe,n=N(n.f5),t=N(t),e=e.dl;return e.$?(r=e.a,dl(t)?Lc({ec:2/(o*r),ed:0,ee:0,ef:0,eg:0,eh:2/r,ei:0,ej:0,ek:0,el:0,em:0,en:-1,eo:0,ep:0,eq:0,er:1}):Lc({ec:2/(o*r),ed:0,ee:0,ef:0,eg:0,eh:2/r,ei:0,ej:0,ek:0,el:0,em:-2/(t-n),en:-(t+n)/(t-n),eo:0,ep:0,eq:0,er:1})):(r=e.a,dl(t)?Lc({ec:1/(o*r),ed:0,ee:0,ef:0,eg:0,eh:1/r,ei:0,ej:0,ek:0,el:0,em:-1,en:-2*n,eo:0,ep:0,eq:-1,er:0}):Lc({ec:1/(o*r),ed:0,ee:0,ef:0,eg:0,eh:1/r,ei:0,ej:0,ek:0,el:0,em:-(t+n)/(t-n),en:-2*t*n/(t-n),eo:0,ep:0,eq:-1,er:0}))}),ml=s(function(e,n){return 1==(1&e>>n)?0:1}),pl=d(function(r,t,e){return Vr(z(L,function(e){var n=e<<4;return $(F,r,{a:t,b:V(bc,z(ml,e,0),z(ml,e,1),z(ml,e,2),z(ml,e,3))},function(e){return p([Or({ap:1,aq:0,av:!0}),kr({bJ:7680,c0:240,dn:e,bZ:514,dC:0,b5:7680,b6:7680}),kc])}(n))},z(ht,1,z(qc,2,e)-1)))}),gl=function(e){return{ec:e[0],eg:e[1],ek:e[2],eo:e[3],ed:e[4],eh:e[5],el:e[6],ep:e[7],ee:e[8],ei:e[9],em:e[10],eq:e[11],ef:e[12],ej:e[13],en:e[14],er:e[15]}},bl={da:ua,dD:H,dE:ke,dF:X},hl=s(function(e,n){var r,t;return e=Wr(xr(n=z(Kc,n,e))),r=Hr(Cr(n)),t=Hr(qa(n)),n=Hr(Aa(n)),Lc({ec:n.ac,ed:t.ac,ee:r.ac,ef:e.ac,eg:n.ad,eh:t.ad,ei:r.ad,ej:e.ad,ek:n.fb,el:t.fb,em:r.fb,en:e.fb,eo:0,ep:0,eq:0,er:1})}),xl=s(function(n,e){var r=p([dc(1),vc(0),uc(!0),V(sc,0,0,0,0)]),t=function(){var e=n.be;switch(e.$){case 0:return{a:r,b:"0",c:1};case 1:return{a:z(h,fc,r),b:"1",c:1};default:return{a:r,b:"0",c:e.a}}}(),o=t.a,a=t.b,i=t.c,t=n.fw,c=t.a,t=Br(t.b),l=z(q,"height",vt(t)+"px"),c=Br(c),u=c/t,e=z(Oi,function(e){return Yr({fe:u,fn:n.fn,fs:n.fs,fF:e.fF,aK:e.aK,aN:e.aN,e0:i,aU:e.aU,aX:e.aX})},e),f=z(q,"width",vt(c)+"px"),s=Fr(n.fh);return $(qr,"div",p([z(q,"padding","0px"),f,l]),p([{a:a,b:$(gc,o,p([(a=gi(c*i),z(Je,"width",vt(a))),function(e){return z(Je,"height",vt(e))}(gi(t*i)),f,l,z(q,"display","block"),z(q,"background-color",s)]),e)}]))}),Cl=function(e){return z(xl,{be:e.be,fh:e.fh,fn:e.fn,fs:e.fs,fw:e.fw},p([{fF:e.fF,aK:e.aK,aN:e.aN,aU:e.aU,aX:e.aX}]))},Pl={ac:.31271,ad:.32902},Tl=function(e){return N(e)},yl={$:1},Ll=function(e){return e},Ml={$:0,a:fl.a},wl={$:0},Dl=function(e){return{$:6,a:e}},Nl=function(e){return e?z(q,"background-color","#d33030"):z(q,"","")},zl=Ke("button"),$l=Ze,Vl=s(function(e,n){return z($l,e,{$:0,a:n})}),Sl=function(e){return z(Vl,"click",Rt(e))},c=function(e){return mc(e)+"px"},_l=s(function(e,n){return e/n}),Al=s(function(e,n){var r=e.da,e=e.dD;return(n.ac-r.ac)*e.ac+(n.ad-r.ad)*e.ad+(n.fb-r.fb)*e.fb}),ql=d(function(e,n,r){var t=e.da,o=e.dE,e=e.dD;return{ac:t.ac+n*e.ac+r*o.ac,ad:t.ad+n*e.ad+r*o.ad}}),Fl=s(function(e,n){var r=e.da,e=e.dE;return(n.ac-r.ac)*e.ac+(n.ad-r.ad)*e.ad+(n.fb-r.fb)*e.fb}),Bl=s(function(e,n){var r=e.da,e=e.dF;return(n.ac-r.ac)*e.ac+(n.ad-r.ad)*e.ad+(n.fb-r.fb)*e.fb}),Rl=d(function(e,n,r){var t,o,a=e.gB,i=z(Al,a,r),c=z(Fl,a,r),a=La(z(Bl,a,r)),r=yr(n),l=r.a,r=r.b,u=z(_l,l,r),e=e.dl;return e.$?(o=z(_l,c,t=e.a),$(ql,Tr(n),z(ei,z(_l,i,z(ei,u,t)),l),z(ei,o,r))):(t=e.a,o=z(_l,c,a)/t,$(ql,Tr(n),z(ei,z(_l,i,a)/(u*t)/2,l),z(ei,o/2,r)))}),kl=u(function(e,n,r,t){e=wi($(Rl,e,Mi,z(Jo,$(o,0,0,1.2),t)));return z(a,p([z(q,"position","absolute"),z(q,"left",c(e.ac-45)),z(q,"top",c(e.ad)),z(q,"width",c(90)),z(q,"height",c(15)),z(q,"background-color","#d33030")]),p([z(a,p([z(q,"position","absolute"),z(q,"left","0"),z(q,"top","0"),z(q,"width",mc(n/r*100)+"%"),z(q,"height",c(15)),z(q,"background-color","lime")]),m)]))}),El=d(function(e,n,r){var e=wi($(Rl,e,Mi,r)),r=e.ac,e=e.ad,n=mr(n);return 1===n.$?i(""):(n=n.a.b8,z(a,p([z(q,"position","absolute"),z(q,"left",c(r-15)),z(q,"top",c(e-15)),z(q,"width",c(30)),z(q,"height",c(30)),z(q,"background-color","#d33030"),z(q,"color","white"),z(q,"display","flex"),z(q,"justify-content","center"),z(q,"align-items","center"),z(q,"border-radius","100%"),z(q,"font-weight","bold")]),p([z(a,m,p([i(vt(n))]))])))}),Il={$:0},Gl=Il,jl=s(function(e,n){return{$:0,a:e,b:n}}),Hl=function(e){return{bd:e.d,cL:e.c,cR:e.b,dm:e.a}},Ul=s(function(e,n){return{$:1,a:e,b:n}}),Ol={src:"\n        precision mediump float;\n        \n        uniform mediump sampler2D colorTexture;\n        \n        varying mediump vec2 interpolatedUv;\n        \n        void main () {\n            gl_FragColor = texture2D(colorTexture, interpolatedUv);\n        }\n    ",attributes:{},uniforms:{colorTexture:"cd"}},Wl={src:"\n        precision lowp float;\n        \n        uniform lowp vec3 constantColor;\n        \n        void main () {\n            gl_FragColor = vec4(constantColor, 1.0);\n        }\n    ",attributes:{},uniforms:{constantColor:"a1"}},Yl={src:"\n        precision mediump float;\n        \n        uniform mediump vec3 emissiveColor;\n        uniform highp mat4 sceneProperties;\n        \n        float gammaCorrect(float u) {\n            if (u <= 0.0031308) {\n                return 12.92 * u;\n            } else {\n                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;\n            }\n        }\n        \n        vec3 gammaCorrectedColor(vec3 color) {\n            float red = gammaCorrect(color.r);\n            float green = gammaCorrect(color.g);\n            float blue = gammaCorrect(color.b);\n            return vec3(red, green, blue);\n        }\n        \n        vec3 reinhardLuminanceToneMap(vec3 color) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scale = 1.0 / (1.0 + luminance);\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 reinhardPerChannelToneMap(vec3 color) {\n            return gammaCorrectedColor(color / (color + 1.0));\n        }\n        \n        float extendedReinhardToneMap(float x, float xMax) {\n            return x * (1.0 + (x / (xMax * xMax))) / (1.0 + x);\n        }\n        \n        vec3 extendedReinhardLuminanceToneMap(vec3 color, float overexposureLimit) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scaledLuminance = extendedReinhardToneMap(luminance, overexposureLimit);\n            float scale = scaledLuminance / luminance;\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 extendedReinhardPerChannelToneMap(vec3 color, float overexposureLimit) {\n            float red = extendedReinhardToneMap(color.r, overexposureLimit);\n            float green = extendedReinhardToneMap(color.g, overexposureLimit);\n            float blue = extendedReinhardToneMap(color.b, overexposureLimit);\n            return gammaCorrectedColor(vec3(red, green, blue));\n        }\n        \n        vec3 hableFilmicHelper(vec3 color) {\n            float a = 0.15;\n            float b = 0.5;\n            float c = 0.1;\n            float d = 0.2;\n            float e = 0.02;\n            float f = 0.3;\n            return (color * (a * color + c * b) + d * e) / (color * (a * color + b) + d * f) - e / f;\n        }\n        \n        vec3 hableFilmicToneMap(vec3 color) {\n            float exposureBias = 2.0;\n            vec3 unscaled = hableFilmicHelper(exposureBias * color);\n            vec3 scale = 1.0 / hableFilmicHelper(vec3(11.2));\n            return gammaCorrectedColor(scale * unscaled);\n        }\n        \n        vec3 toneMap(vec3 color, float toneMapType, float toneMapParam) {\n            if (toneMapType == 0.0) {\n                return gammaCorrectedColor(color);\n            } else if (toneMapType == 1.0) {\n                return reinhardLuminanceToneMap(color);\n            } else if (toneMapType == 2.0) {\n                return reinhardPerChannelToneMap(color);\n            } else if (toneMapType == 3.0) {\n                return extendedReinhardLuminanceToneMap(color, toneMapParam);\n            } else if (toneMapType == 4.0) {\n                return extendedReinhardPerChannelToneMap(color, toneMapParam);\n            } else if (toneMapType == 5.0) {\n                return hableFilmicToneMap(color);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {\n            vec3 referenceWhite = sceneProperties[2].rgb;\n            float unitR = linearColor.r / referenceWhite.r;\n            float unitG = linearColor.g / referenceWhite.g;\n            float unitB = linearColor.b / referenceWhite.b;\n            float toneMapType = sceneProperties[3][2];\n            float toneMapParam = sceneProperties[3][3];\n            vec3 toneMapped = toneMap(vec3(unitR, unitG, unitB), toneMapType, toneMapParam);\n            return vec4(toneMapped, 1.0);\n        }\n        \n        void main () {\n            gl_FragColor = toSrgb(emissiveColor, sceneProperties);\n        }\n    ",attributes:{},uniforms:{emissiveColor:"bh",sceneProperties:"g"}},Kl={src:"\n        precision mediump float;\n        \n        uniform mediump sampler2D colorTexture;\n        uniform mediump float backlight;\n        uniform highp mat4 sceneProperties;\n        \n        varying mediump vec2 interpolatedUv;\n        \n        float inverseGamma(float u) {\n            if (u <= 0.04045) {\n                return clamp(u / 12.92, 0.0, 1.0);\n            } else {\n                return clamp(pow((u + 0.055) / 1.055, 2.4), 0.0, 1.0);\n            }\n        }\n        \n        vec3 fromSrgb(vec3 srgbColor) {\n            return vec3(\n                inverseGamma(srgbColor.r),\n                inverseGamma(srgbColor.g),\n                inverseGamma(srgbColor.b)\n            );\n        }\n        \n        float gammaCorrect(float u) {\n            if (u <= 0.0031308) {\n                return 12.92 * u;\n            } else {\n                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;\n            }\n        }\n        \n        vec3 gammaCorrectedColor(vec3 color) {\n            float red = gammaCorrect(color.r);\n            float green = gammaCorrect(color.g);\n            float blue = gammaCorrect(color.b);\n            return vec3(red, green, blue);\n        }\n        \n        vec3 reinhardLuminanceToneMap(vec3 color) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scale = 1.0 / (1.0 + luminance);\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 reinhardPerChannelToneMap(vec3 color) {\n            return gammaCorrectedColor(color / (color + 1.0));\n        }\n        \n        float extendedReinhardToneMap(float x, float xMax) {\n            return x * (1.0 + (x / (xMax * xMax))) / (1.0 + x);\n        }\n        \n        vec3 extendedReinhardLuminanceToneMap(vec3 color, float overexposureLimit) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scaledLuminance = extendedReinhardToneMap(luminance, overexposureLimit);\n            float scale = scaledLuminance / luminance;\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 extendedReinhardPerChannelToneMap(vec3 color, float overexposureLimit) {\n            float red = extendedReinhardToneMap(color.r, overexposureLimit);\n            float green = extendedReinhardToneMap(color.g, overexposureLimit);\n            float blue = extendedReinhardToneMap(color.b, overexposureLimit);\n            return gammaCorrectedColor(vec3(red, green, blue));\n        }\n        \n        vec3 hableFilmicHelper(vec3 color) {\n            float a = 0.15;\n            float b = 0.5;\n            float c = 0.1;\n            float d = 0.2;\n            float e = 0.02;\n            float f = 0.3;\n            return (color * (a * color + c * b) + d * e) / (color * (a * color + b) + d * f) - e / f;\n        }\n        \n        vec3 hableFilmicToneMap(vec3 color) {\n            float exposureBias = 2.0;\n            vec3 unscaled = hableFilmicHelper(exposureBias * color);\n            vec3 scale = 1.0 / hableFilmicHelper(vec3(11.2));\n            return gammaCorrectedColor(scale * unscaled);\n        }\n        \n        vec3 toneMap(vec3 color, float toneMapType, float toneMapParam) {\n            if (toneMapType == 0.0) {\n                return gammaCorrectedColor(color);\n            } else if (toneMapType == 1.0) {\n                return reinhardLuminanceToneMap(color);\n            } else if (toneMapType == 2.0) {\n                return reinhardPerChannelToneMap(color);\n            } else if (toneMapType == 3.0) {\n                return extendedReinhardLuminanceToneMap(color, toneMapParam);\n            } else if (toneMapType == 4.0) {\n                return extendedReinhardPerChannelToneMap(color, toneMapParam);\n            } else if (toneMapType == 5.0) {\n                return hableFilmicToneMap(color);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {\n            vec3 referenceWhite = sceneProperties[2].rgb;\n            float unitR = linearColor.r / referenceWhite.r;\n            float unitG = linearColor.g / referenceWhite.g;\n            float unitB = linearColor.b / referenceWhite.b;\n            float toneMapType = sceneProperties[3][2];\n            float toneMapParam = sceneProperties[3][3];\n            vec3 toneMapped = toneMap(vec3(unitR, unitG, unitB), toneMapType, toneMapParam);\n            return vec4(toneMapped, 1.0);\n        }\n        \n        void main () {\n            vec3 emissiveColor = fromSrgb(texture2D(colorTexture, interpolatedUv).rgb) * backlight;\n            gl_FragColor = toSrgb(emissiveColor, sceneProperties);\n        }\n    ",attributes:{},uniforms:{backlight:"cH",colorTexture:"cd",sceneProperties:"g"}},Ql=E(function(e,n,r,t,o,a,i){for(;;){if(!i.b)return{et:n,eu:t,ev:a,ew:e,ex:r,ey:o};var c=i.a,l=i.b,u=c.ac,f=c.ad,c=c.fb;e=z(pa,u,e),n=z(P,u,n),r=z(pa,f,r),t=z(P,f,t),o=z(pa,c,o),a=z(P,c,a),i=l}}),Zl=s(function(e,n){var r=e.ac,t=e.ad,e=e.fb;return G(Ql,r,r,t,t,e,e,n)}),Xl={src:"\n        precision highp float;\n        \n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 lights12;\n        uniform highp mat4 lights34;\n        uniform highp mat4 lights56;\n        uniform highp mat4 lights78;\n        uniform lowp vec4 enabledLights;\n        uniform lowp vec3 materialColor;\n        uniform highp mat4 viewMatrix;\n        \n        varying highp vec3 interpolatedPosition;\n        varying highp vec3 interpolatedNormal;\n        \n        const lowp float kPerspectiveProjection = 0.0;\n        const lowp float kOrthographicProjection = 1.0;\n        const lowp float kDirectionalLight = 1.0;\n        const lowp float kPointLight = 2.0;\n        const highp float kPi = 3.14159265359;\n        const lowp float kDisabledLight = 0.0;\n        const lowp float kSoftLighting = 3.0;\n        \n        float getNormalSign() {\n            return 2.0 * float(gl_FrontFacing) - 1.0;\n        }\n        \n        vec3 getDirectionToCamera(vec3 surfacePosition, mat4 sceneProperties) {\n            float projectionType = sceneProperties[1].w;\n            if (projectionType == kPerspectiveProjection) {\n                vec3 cameraPoint = sceneProperties[1].xyz;\n                return normalize(cameraPoint - surfacePosition);\n            } else if (projectionType == kOrthographicProjection) {\n                return sceneProperties[1].xyz;\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        void getDirectionToLightAndNormalIlluminance(\n            vec4 xyz_type,\n            vec4 rgb_parameter,\n            vec3 surfacePosition,\n            out vec3 directionToLight,\n            out vec3 normalIlluminance\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDirectionalLight) {\n                directionToLight = xyz_type.xyz;\n                normalIlluminance = rgb_parameter.rgb;\n            } else if (lightType == kPointLight) {\n                vec3 lightPosition = xyz_type.xyz;\n                vec3 displacement = lightPosition - surfacePosition;\n                float distance = length(displacement);\n                directionToLight = displacement / distance;\n                normalIlluminance = rgb_parameter.rgb / (4.0 * kPi * distance * distance);\n            }\n        }\n        \n        float positiveDotProduct(vec3 v1, vec3 v2) {\n            return clamp(dot(v1, v2), 0.0, 1.0);\n        }\n        \n        vec3 softLightingLuminance(\n            vec3 aboveLuminance,\n            vec3 belowLuminance,\n            vec3 localUpDirection,\n            vec3 localLightDirection\n        ) {\n            float sinElevation = dot(localLightDirection, localUpDirection);\n            float t = (sinElevation + 1.0) / 2.0;\n            return aboveLuminance * t + belowLuminance * (1.0 - t);\n        }\n        \n        vec3 lambertianLight(\n            vec3 surfacePosition,\n            vec3 surfaceNormal,\n            vec3 materialColor,\n            vec4 xyz_type,\n            vec4 rgb_parameter\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDisabledLight) {\n                return vec3(0.0, 0.0, 0.0);\n            } else if (lightType == kSoftLighting) {\n                vec3 upDirection = xyz_type.xyz;\n                vec3 aboveLuminance = rgb_parameter.rgb;\n                vec3 belowLuminance = rgb_parameter.a * aboveLuminance;\n                vec3 luminance = softLightingLuminance(aboveLuminance, belowLuminance, upDirection, surfaceNormal);\n                return luminance * materialColor;\n            }\n        \n            vec3 directionToLight = vec3(0.0, 0.0, 0.0);\n            vec3 normalIlluminance = vec3(0.0, 0.0, 0.0);\n            getDirectionToLightAndNormalIlluminance(\n                xyz_type,\n                rgb_parameter,\n                surfacePosition,\n                directionToLight,\n                normalIlluminance\n            );\n        \n            float dotNL = positiveDotProduct(directionToLight, surfaceNormal);\n            return (normalIlluminance * dotNL) * (materialColor / kPi);\n        }\n        \n        vec3 lambertianLighting(\n            vec3 surfacePosition,\n            vec3 surfaceNormal,\n            vec3 materialColor,\n            mat4 lights12,\n            mat4 lights34,\n            mat4 lights56,\n            mat4 lights78,\n            vec4 enabledLights\n        ) {\n            vec3 litColor1 = enabledLights[0] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights12[0], lights12[1]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor2 = enabledLights[1] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights12[2], lights12[3]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor3 = enabledLights[2] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights34[0], lights34[1]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor4 = enabledLights[3] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights34[2], lights34[3]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor5 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights56[0], lights56[1]);\n            vec3 litColor6 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights56[2], lights56[3]);\n            vec3 litColor7 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights78[0], lights78[1]);\n            vec3 litColor8 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights78[2], lights78[3]);\n            return litColor1 + litColor2 + litColor3 + litColor4 + litColor5 + litColor6 + litColor7 + litColor8;\n        }\n        \n        float gammaCorrect(float u) {\n            if (u <= 0.0031308) {\n                return 12.92 * u;\n            } else {\n                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;\n            }\n        }\n        \n        vec3 gammaCorrectedColor(vec3 color) {\n            float red = gammaCorrect(color.r);\n            float green = gammaCorrect(color.g);\n            float blue = gammaCorrect(color.b);\n            return vec3(red, green, blue);\n        }\n        \n        vec3 reinhardLuminanceToneMap(vec3 color) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scale = 1.0 / (1.0 + luminance);\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 reinhardPerChannelToneMap(vec3 color) {\n            return gammaCorrectedColor(color / (color + 1.0));\n        }\n        \n        float extendedReinhardToneMap(float x, float xMax) {\n            return x * (1.0 + (x / (xMax * xMax))) / (1.0 + x);\n        }\n        \n        vec3 extendedReinhardLuminanceToneMap(vec3 color, float overexposureLimit) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scaledLuminance = extendedReinhardToneMap(luminance, overexposureLimit);\n            float scale = scaledLuminance / luminance;\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 extendedReinhardPerChannelToneMap(vec3 color, float overexposureLimit) {\n            float red = extendedReinhardToneMap(color.r, overexposureLimit);\n            float green = extendedReinhardToneMap(color.g, overexposureLimit);\n            float blue = extendedReinhardToneMap(color.b, overexposureLimit);\n            return gammaCorrectedColor(vec3(red, green, blue));\n        }\n        \n        vec3 hableFilmicHelper(vec3 color) {\n            float a = 0.15;\n            float b = 0.5;\n            float c = 0.1;\n            float d = 0.2;\n            float e = 0.02;\n            float f = 0.3;\n            return (color * (a * color + c * b) + d * e) / (color * (a * color + b) + d * f) - e / f;\n        }\n        \n        vec3 hableFilmicToneMap(vec3 color) {\n            float exposureBias = 2.0;\n            vec3 unscaled = hableFilmicHelper(exposureBias * color);\n            vec3 scale = 1.0 / hableFilmicHelper(vec3(11.2));\n            return gammaCorrectedColor(scale * unscaled);\n        }\n        \n        vec3 toneMap(vec3 color, float toneMapType, float toneMapParam) {\n            if (toneMapType == 0.0) {\n                return gammaCorrectedColor(color);\n            } else if (toneMapType == 1.0) {\n                return reinhardLuminanceToneMap(color);\n            } else if (toneMapType == 2.0) {\n                return reinhardPerChannelToneMap(color);\n            } else if (toneMapType == 3.0) {\n                return extendedReinhardLuminanceToneMap(color, toneMapParam);\n            } else if (toneMapType == 4.0) {\n                return extendedReinhardPerChannelToneMap(color, toneMapParam);\n            } else if (toneMapType == 5.0) {\n                return hableFilmicToneMap(color);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {\n            vec3 referenceWhite = sceneProperties[2].rgb;\n            float unitR = linearColor.r / referenceWhite.r;\n            float unitG = linearColor.g / referenceWhite.g;\n            float unitB = linearColor.b / referenceWhite.b;\n            float toneMapType = sceneProperties[3][2];\n            float toneMapParam = sceneProperties[3][3];\n            vec3 toneMapped = toneMap(vec3(unitR, unitG, unitB), toneMapType, toneMapParam);\n            return vec4(toneMapped, 1.0);\n        }\n        \n        void main() {\n            vec3 normalDirection = normalize(interpolatedNormal) * getNormalSign();\n            vec3 directionToCamera = getDirectionToCamera(interpolatedPosition, sceneProperties);\n        \n            vec3 linearColor = lambertianLighting(\n                interpolatedPosition,\n                normalDirection,\n                materialColor,\n                lights12,\n                lights34,\n                lights56,\n                lights78,\n                enabledLights\n            );\n        \n            gl_FragColor = toSrgb(linearColor, sceneProperties);\n        }\n    ",attributes:{},uniforms:{enabledLights:"af",lights12:"bP",lights34:"cl",lights56:"cm",lights78:"cn",materialColor:"c1",sceneProperties:"g",viewMatrix:"h"}},Jl={src:"\n        precision highp float;\n        \n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 lights12;\n        uniform highp mat4 lights34;\n        uniform highp mat4 lights56;\n        uniform highp mat4 lights78;\n        uniform lowp vec4 enabledLights;\n        uniform mediump sampler2D materialColorTexture;\n        uniform mediump sampler2D normalMapTexture;\n        uniform lowp float useNormalMap;\n        uniform highp mat4 viewMatrix;\n        \n        varying highp vec3 interpolatedPosition;\n        varying highp vec3 interpolatedNormal;\n        varying mediump vec2 interpolatedUv;\n        varying highp vec3 interpolatedTangent;\n        \n        const lowp float kPerspectiveProjection = 0.0;\n        const lowp float kOrthographicProjection = 1.0;\n        const lowp float kDirectionalLight = 1.0;\n        const lowp float kPointLight = 2.0;\n        const highp float kPi = 3.14159265359;\n        const lowp float kDisabledLight = 0.0;\n        const lowp float kSoftLighting = 3.0;\n        \n        vec3 getLocalNormal(sampler2D normalMap, float useNormalMap, vec2 uv) {\n            vec3 rgb = useNormalMap * texture2D(normalMap, uv).rgb + (1.0 - useNormalMap) * vec3(0.5, 0.5, 1.0);\n            float x = 2.0 * (rgb.r - 0.5);\n            float y = 2.0 * (rgb.g - 0.5);\n            float z = 2.0 * (rgb.b - 0.5);\n            return normalize(vec3(-x, -y, z));\n        }\n        \n        float getNormalSign() {\n            return 2.0 * float(gl_FrontFacing) - 1.0;\n        }\n        \n        vec3 getMappedNormal(vec3 normal, vec3 tangent, float normalSign, vec3 localNormal) {\n            vec3 bitangent = cross(normal, tangent) * normalSign;\n            return normalize(localNormal.x * tangent + localNormal.y * bitangent + localNormal.z * normal);\n        }\n        \n        vec3 getDirectionToCamera(vec3 surfacePosition, mat4 sceneProperties) {\n            float projectionType = sceneProperties[1].w;\n            if (projectionType == kPerspectiveProjection) {\n                vec3 cameraPoint = sceneProperties[1].xyz;\n                return normalize(cameraPoint - surfacePosition);\n            } else if (projectionType == kOrthographicProjection) {\n                return sceneProperties[1].xyz;\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        void getDirectionToLightAndNormalIlluminance(\n            vec4 xyz_type,\n            vec4 rgb_parameter,\n            vec3 surfacePosition,\n            out vec3 directionToLight,\n            out vec3 normalIlluminance\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDirectionalLight) {\n                directionToLight = xyz_type.xyz;\n                normalIlluminance = rgb_parameter.rgb;\n            } else if (lightType == kPointLight) {\n                vec3 lightPosition = xyz_type.xyz;\n                vec3 displacement = lightPosition - surfacePosition;\n                float distance = length(displacement);\n                directionToLight = displacement / distance;\n                normalIlluminance = rgb_parameter.rgb / (4.0 * kPi * distance * distance);\n            }\n        }\n        \n        float positiveDotProduct(vec3 v1, vec3 v2) {\n            return clamp(dot(v1, v2), 0.0, 1.0);\n        }\n        \n        vec3 softLightingLuminance(\n            vec3 aboveLuminance,\n            vec3 belowLuminance,\n            vec3 localUpDirection,\n            vec3 localLightDirection\n        ) {\n            float sinElevation = dot(localLightDirection, localUpDirection);\n            float t = (sinElevation + 1.0) / 2.0;\n            return aboveLuminance * t + belowLuminance * (1.0 - t);\n        }\n        \n        vec3 lambertianLight(\n            vec3 surfacePosition,\n            vec3 surfaceNormal,\n            vec3 materialColor,\n            vec4 xyz_type,\n            vec4 rgb_parameter\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDisabledLight) {\n                return vec3(0.0, 0.0, 0.0);\n            } else if (lightType == kSoftLighting) {\n                vec3 upDirection = xyz_type.xyz;\n                vec3 aboveLuminance = rgb_parameter.rgb;\n                vec3 belowLuminance = rgb_parameter.a * aboveLuminance;\n                vec3 luminance = softLightingLuminance(aboveLuminance, belowLuminance, upDirection, surfaceNormal);\n                return luminance * materialColor;\n            }\n        \n            vec3 directionToLight = vec3(0.0, 0.0, 0.0);\n            vec3 normalIlluminance = vec3(0.0, 0.0, 0.0);\n            getDirectionToLightAndNormalIlluminance(\n                xyz_type,\n                rgb_parameter,\n                surfacePosition,\n                directionToLight,\n                normalIlluminance\n            );\n        \n            float dotNL = positiveDotProduct(directionToLight, surfaceNormal);\n            return (normalIlluminance * dotNL) * (materialColor / kPi);\n        }\n        \n        vec3 lambertianLighting(\n            vec3 surfacePosition,\n            vec3 surfaceNormal,\n            vec3 materialColor,\n            mat4 lights12,\n            mat4 lights34,\n            mat4 lights56,\n            mat4 lights78,\n            vec4 enabledLights\n        ) {\n            vec3 litColor1 = enabledLights[0] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights12[0], lights12[1]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor2 = enabledLights[1] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights12[2], lights12[3]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor3 = enabledLights[2] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights34[0], lights34[1]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor4 = enabledLights[3] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights34[2], lights34[3]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor5 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights56[0], lights56[1]);\n            vec3 litColor6 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights56[2], lights56[3]);\n            vec3 litColor7 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights78[0], lights78[1]);\n            vec3 litColor8 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights78[2], lights78[3]);\n            return litColor1 + litColor2 + litColor3 + litColor4 + litColor5 + litColor6 + litColor7 + litColor8;\n        }\n        \n        float inverseGamma(float u) {\n            if (u <= 0.04045) {\n                return clamp(u / 12.92, 0.0, 1.0);\n            } else {\n                return clamp(pow((u + 0.055) / 1.055, 2.4), 0.0, 1.0);\n            }\n        }\n        \n        vec3 fromSrgb(vec3 srgbColor) {\n            return vec3(\n                inverseGamma(srgbColor.r),\n                inverseGamma(srgbColor.g),\n                inverseGamma(srgbColor.b)\n            );\n        }\n        \n        float gammaCorrect(float u) {\n            if (u <= 0.0031308) {\n                return 12.92 * u;\n            } else {\n                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;\n            }\n        }\n        \n        vec3 gammaCorrectedColor(vec3 color) {\n            float red = gammaCorrect(color.r);\n            float green = gammaCorrect(color.g);\n            float blue = gammaCorrect(color.b);\n            return vec3(red, green, blue);\n        }\n        \n        vec3 reinhardLuminanceToneMap(vec3 color) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scale = 1.0 / (1.0 + luminance);\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 reinhardPerChannelToneMap(vec3 color) {\n            return gammaCorrectedColor(color / (color + 1.0));\n        }\n        \n        float extendedReinhardToneMap(float x, float xMax) {\n            return x * (1.0 + (x / (xMax * xMax))) / (1.0 + x);\n        }\n        \n        vec3 extendedReinhardLuminanceToneMap(vec3 color, float overexposureLimit) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scaledLuminance = extendedReinhardToneMap(luminance, overexposureLimit);\n            float scale = scaledLuminance / luminance;\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 extendedReinhardPerChannelToneMap(vec3 color, float overexposureLimit) {\n            float red = extendedReinhardToneMap(color.r, overexposureLimit);\n            float green = extendedReinhardToneMap(color.g, overexposureLimit);\n            float blue = extendedReinhardToneMap(color.b, overexposureLimit);\n            return gammaCorrectedColor(vec3(red, green, blue));\n        }\n        \n        vec3 hableFilmicHelper(vec3 color) {\n            float a = 0.15;\n            float b = 0.5;\n            float c = 0.1;\n            float d = 0.2;\n            float e = 0.02;\n            float f = 0.3;\n            return (color * (a * color + c * b) + d * e) / (color * (a * color + b) + d * f) - e / f;\n        }\n        \n        vec3 hableFilmicToneMap(vec3 color) {\n            float exposureBias = 2.0;\n            vec3 unscaled = hableFilmicHelper(exposureBias * color);\n            vec3 scale = 1.0 / hableFilmicHelper(vec3(11.2));\n            return gammaCorrectedColor(scale * unscaled);\n        }\n        \n        vec3 toneMap(vec3 color, float toneMapType, float toneMapParam) {\n            if (toneMapType == 0.0) {\n                return gammaCorrectedColor(color);\n            } else if (toneMapType == 1.0) {\n                return reinhardLuminanceToneMap(color);\n            } else if (toneMapType == 2.0) {\n                return reinhardPerChannelToneMap(color);\n            } else if (toneMapType == 3.0) {\n                return extendedReinhardLuminanceToneMap(color, toneMapParam);\n            } else if (toneMapType == 4.0) {\n                return extendedReinhardPerChannelToneMap(color, toneMapParam);\n            } else if (toneMapType == 5.0) {\n                return hableFilmicToneMap(color);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {\n            vec3 referenceWhite = sceneProperties[2].rgb;\n            float unitR = linearColor.r / referenceWhite.r;\n            float unitG = linearColor.g / referenceWhite.g;\n            float unitB = linearColor.b / referenceWhite.b;\n            float toneMapType = sceneProperties[3][2];\n            float toneMapParam = sceneProperties[3][3];\n            vec3 toneMapped = toneMap(vec3(unitR, unitG, unitB), toneMapType, toneMapParam);\n            return vec4(toneMapped, 1.0);\n        }\n        \n        void main() {\n            vec3 localNormal = getLocalNormal(normalMapTexture, useNormalMap, interpolatedUv);\n            float normalSign = getNormalSign();\n            vec3 originalNormal = normalize(interpolatedNormal) * normalSign;\n            vec3 normalDirection = getMappedNormal(originalNormal, interpolatedTangent, normalSign, localNormal);\n            vec3 directionToCamera = getDirectionToCamera(interpolatedPosition, sceneProperties);\n            vec3 materialColor = fromSrgb(texture2D(materialColorTexture, interpolatedUv).rgb);\n        \n            vec3 linearColor = lambertianLighting(\n                interpolatedPosition,\n                normalDirection,\n                materialColor,\n                lights12,\n                lights34,\n                lights56,\n                lights78,\n                enabledLights\n            );\n        \n            gl_FragColor = toSrgb(linearColor, sceneProperties);\n        }\n    ",attributes:{},uniforms:{enabledLights:"af",lights12:"bP",lights34:"cl",lights56:"cm",lights78:"cn",materialColorTexture:"c2",normalMapTexture:"bp",sceneProperties:"g",useNormalMap:"bv",viewMatrix:"h"}},eu=Zr(1029),nu=Zr(1028),ru=d(function(e,n,r){return 1===n?z(h,e?eu:nu,r):r}),tu={src:"\n        precision highp float;\n        \n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 lights12;\n        uniform highp mat4 lights34;\n        uniform highp mat4 lights56;\n        uniform highp mat4 lights78;\n        uniform lowp vec4 enabledLights;\n        uniform lowp vec3 baseColor;\n        uniform lowp float roughness;\n        uniform lowp float metallic;\n        \n        varying highp vec3 interpolatedPosition;\n        varying highp vec3 interpolatedNormal;\n        \n        const lowp float kPerspectiveProjection = 0.0;\n        const lowp float kOrthographicProjection = 1.0;\n        const lowp float kDirectionalLight = 1.0;\n        const lowp float kPointLight = 2.0;\n        const highp float kPi = 3.14159265359;\n        const mediump float kMediumpFloatMax = 65504.0;\n        const lowp float kDisabledLight = 0.0;\n        const lowp float kSoftLighting = 3.0;\n        \n        float getNormalSign() {\n            return 2.0 * float(gl_FrontFacing) - 1.0;\n        }\n        \n        vec3 getDirectionToCamera(vec3 surfacePosition, mat4 sceneProperties) {\n            float projectionType = sceneProperties[1].w;\n            if (projectionType == kPerspectiveProjection) {\n                vec3 cameraPoint = sceneProperties[1].xyz;\n                return normalize(cameraPoint - surfacePosition);\n            } else if (projectionType == kOrthographicProjection) {\n                return sceneProperties[1].xyz;\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        void getDirectionToLightAndNormalIlluminance(\n            vec4 xyz_type,\n            vec4 rgb_parameter,\n            vec3 surfacePosition,\n            out vec3 directionToLight,\n            out vec3 normalIlluminance\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDirectionalLight) {\n                directionToLight = xyz_type.xyz;\n                normalIlluminance = rgb_parameter.rgb;\n            } else if (lightType == kPointLight) {\n                vec3 lightPosition = xyz_type.xyz;\n                vec3 displacement = lightPosition - surfacePosition;\n                float distance = length(displacement);\n                directionToLight = displacement / distance;\n                normalIlluminance = rgb_parameter.rgb / (4.0 * kPi * distance * distance);\n            }\n        }\n        \n        float positiveDotProduct(vec3 v1, vec3 v2) {\n            return clamp(dot(v1, v2), 0.0, 1.0);\n        }\n        \n        // Adapted from https://google.github.io/filament/Filament.md.html#materialsystem/specularbrdf/normaldistributionfunction(speculard)\n        float specularD(float alpha, float dotNH, vec3 normalDirection, vec3 halfDirection) {\n            vec3 crossNH = cross(normalDirection, halfDirection);\n            float a = dotNH * alpha;\n            float k = alpha / (dot(crossNH, crossNH) + a * a);\n            float d = k * k * (1.0 / kPi);\n            return min(d, kMediumpFloatMax);\n        }\n        \n        float safeQuotient(float numerator, float denominator) {\n            if (denominator == 0.0) {\n                return 0.0;\n            } else {\n                return numerator / denominator;\n            }\n        }\n        \n        float g1(float dotNV, float alphaSquared) {\n            return safeQuotient(2.0 * dotNV, dotNV + sqrt(alphaSquared + (1.0 - alphaSquared) * dotNV * dotNV));\n        }\n        \n        float specularG(float dotNL, float dotNV, float alphaSquared) {\n            return g1(dotNV, alphaSquared) * g1(dotNL, alphaSquared);\n        }\n        \n        vec3 fresnelColor(vec3 specularBaseColor, float dotVH) {\n            vec3 one = vec3(1.0, 1.0, 1.0);\n            float scale = exp2((-5.55473 * dotVH - 6.98316) * dotVH);\n            return specularBaseColor + (one - specularBaseColor) * scale;\n        }\n        \n        vec3 brdf(vec3 normalDirection, vec3 directionToCamera, vec3 directionToLight, float alpha, float dotNV, float dotNL, vec3 specularBaseColor, vec3 normalIlluminance) {\n            vec3 halfDirection = normalize(directionToCamera + directionToLight);\n            float dotVH = positiveDotProduct(directionToCamera, halfDirection);\n            float dotNH = positiveDotProduct(normalDirection, halfDirection);\n            float dotNHSquared = dotNH * dotNH;\n        \n            float d = specularD(alpha, dotNH, normalDirection, halfDirection);\n            float g = specularG(dotNL, dotNV, alpha * alpha);\n            vec3 f = fresnelColor(specularBaseColor, dotVH);\n            return safeQuotient(d * g, 4.0 * dotNL * dotNV) * f;\n        }\n        \n        vec3 sampleFacetNormal(vec3 vH, vec3 vT1, vec3 vT2, float s, float alpha) {\n            float t2 = (1.0 - s);\n            vec3 vNh = t2 * vT2 + sqrt(max(0.0, 1.0 - t2 * t2)) * vH;\n            return normalize(vec3(alpha * vNh.x, alpha * vNh.y, max(0.0, vNh.z)));\n        }\n        \n        vec3 softLightingLuminance(\n            vec3 aboveLuminance,\n            vec3 belowLuminance,\n            vec3 localUpDirection,\n            vec3 localLightDirection\n        ) {\n            float sinElevation = dot(localLightDirection, localUpDirection);\n            float t = (sinElevation + 1.0) / 2.0;\n            return aboveLuminance * t + belowLuminance * (1.0 - t);\n        }\n        \n        vec3 softLightingSpecularSample(\n            vec3 aboveLuminance,\n            vec3 belowLuminance,\n            vec3 localUpDirection,\n            vec3 localViewDirection,\n            vec3 localLightDirection,\n            vec3 localHalfDirection,\n            float alphaSquared,\n            vec3 specularBaseColor\n        ) {\n            vec3 luminance = softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection);\n            float dotVH = positiveDotProduct(localViewDirection, localHalfDirection);\n            float dotNL = localLightDirection.z;\n            return luminance * (fresnelColor(specularBaseColor, dotVH) * g1(dotNL, alphaSquared));\n        }\n        \n        vec3 softLighting(\n            vec3 normalDirection,\n            vec3 diffuseBaseColor,\n            vec3 specularBaseColor,\n            float alpha,\n            vec3 directionToCamera,\n            vec3 viewY,\n            vec4 xyz_type,\n            vec4 rgb_parameter\n        ) {\n            float alphaSquared = alpha * alpha;\n            vec3 upDirection = xyz_type.xyz;\n            vec3 luminanceAbove = rgb_parameter.rgb;\n            vec3 luminanceBelow = rgb_parameter.a * luminanceAbove;\n            vec3 crossProduct = cross(normalDirection, directionToCamera);\n            float crossMagnitude = length(crossProduct);\n            vec3 xDirection = vec3(0.0, 0.0, 0.0);\n            vec3 yDirection = vec3(0.0, 0.0, 0.0);\n            if (crossMagnitude > 1.0e-6) {\n                yDirection = (1.0 / crossMagnitude) * crossProduct;\n                xDirection = cross(yDirection, normalDirection);\n            } else {\n                vec3 viewY = vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]);\n                xDirection = normalize(cross(viewY, normalDirection));\n                yDirection = cross(normalDirection, xDirection);\n            }\n            float localViewX = dot(directionToCamera, xDirection);\n            float localViewZ = dot(directionToCamera, normalDirection);\n            vec3 localViewDirection = vec3(localViewX, 0, localViewZ);\n            float localUpX = dot(upDirection, xDirection);\n            float localUpY = dot(upDirection, yDirection);\n            float localUpZ = dot(upDirection, normalDirection);\n            vec3 localUpDirection = vec3(localUpX, localUpY, localUpZ);\n        \n            vec3 vH = normalize(vec3(alpha * localViewX, 0.0, localViewZ));\n            vec3 vT1 = vec3(0.0, 1.0, 0.0);\n            vec3 vT2 = cross(vH, vT1);\n            float s = 0.5 * (1.0 + vH.z);\n            \n            vec3 localHalfDirection = sampleFacetNormal(vH, vT1, vT2, s, alpha);\n            vec3 localLightDirection = vec3(0.0, 0.0, 0.0);\n            \n            localLightDirection = -reflect(localViewDirection, localHalfDirection);\n            vec3 specular = softLightingSpecularSample(luminanceAbove, luminanceBelow, localUpDirection, localViewDirection, localLightDirection, localHalfDirection, alphaSquared, specularBaseColor);\n            \n            localLightDirection = vec3(0.000000, 0.000000, 1.000000);\n            vec3 diffuse = softLightingLuminance(luminanceAbove, luminanceBelow, localUpDirection, localLightDirection) * localLightDirection.z;\n            \n            return specular + diffuse * diffuseBaseColor;\n        }\n        \n        vec3 physicalLight(\n            vec4 xyz_type,\n            vec4 rgb_parameter,\n            vec3 surfacePosition,\n            vec3 normalDirection,\n            vec3 directionToCamera,\n            vec3 viewY,\n            float dotNV,\n            vec3 diffuseBaseColor,\n            vec3 specularBaseColor,\n            float alpha\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDisabledLight) {\n                return vec3(0.0, 0.0, 0.0);\n            } else if (lightType == kSoftLighting) {\n                return softLighting(normalDirection, diffuseBaseColor, specularBaseColor, alpha, directionToCamera, viewY, xyz_type, rgb_parameter);\n            }\n        \n            vec3 directionToLight = vec3(0.0, 0.0, 0.0);\n            vec3 normalIlluminance = vec3(0.0, 0.0, 0.0);\n            getDirectionToLightAndNormalIlluminance(xyz_type, rgb_parameter, surfacePosition, directionToLight, normalIlluminance);\n        \n            float dotNL = positiveDotProduct(normalDirection, directionToLight);\n            vec3 specularColor = brdf(normalDirection, directionToCamera, directionToLight, alpha, dotNV, dotNL, specularBaseColor, normalIlluminance);\n            return (normalIlluminance * dotNL) * ((diffuseBaseColor / kPi) + specularColor);\n        }\n        \n        vec3 physicalLighting(\n            vec3 surfacePosition,\n            vec3 surfaceNormal,\n            vec3 baseColor,\n            vec3 directionToCamera,\n            mat4 viewMatrix,\n            float roughness,\n            float metallic,\n            mat4 lights12,\n            mat4 lights34,\n            mat4 lights56,\n            mat4 lights78,\n            vec4 enabledLights\n        ) {\n            float dotNV = positiveDotProduct(surfaceNormal, directionToCamera);\n            float alpha = roughness * roughness;\n            float nonmetallic = 1.0 - metallic;\n            vec3 diffuseBaseColor = nonmetallic * 0.96 * baseColor;\n            vec3 specularBaseColor = nonmetallic * 0.04 * vec3(1.0, 1.0, 1.0) + metallic * baseColor;\n            vec3 viewY = vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]);\n        \n            vec3 litColor1 = enabledLights[0] == 1.0 ? physicalLight(lights12[0], lights12[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor2 = enabledLights[1] == 1.0 ? physicalLight(lights12[2], lights12[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor3 = enabledLights[2] == 1.0 ? physicalLight(lights34[0], lights34[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor4 = enabledLights[3] == 1.0 ? physicalLight(lights34[2], lights34[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor5 = physicalLight(lights56[0], lights56[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            vec3 litColor6 = physicalLight(lights56[2], lights56[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            vec3 litColor7 = physicalLight(lights78[0], lights78[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            vec3 litColor8 = physicalLight(lights78[2], lights78[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            return litColor1 + litColor2 + litColor3 + litColor4 + litColor5 + litColor6 + litColor7 + litColor8;\n        }\n        \n        float gammaCorrect(float u) {\n            if (u <= 0.0031308) {\n                return 12.92 * u;\n            } else {\n                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;\n            }\n        }\n        \n        vec3 gammaCorrectedColor(vec3 color) {\n            float red = gammaCorrect(color.r);\n            float green = gammaCorrect(color.g);\n            float blue = gammaCorrect(color.b);\n            return vec3(red, green, blue);\n        }\n        \n        vec3 reinhardLuminanceToneMap(vec3 color) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scale = 1.0 / (1.0 + luminance);\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 reinhardPerChannelToneMap(vec3 color) {\n            return gammaCorrectedColor(color / (color + 1.0));\n        }\n        \n        float extendedReinhardToneMap(float x, float xMax) {\n            return x * (1.0 + (x / (xMax * xMax))) / (1.0 + x);\n        }\n        \n        vec3 extendedReinhardLuminanceToneMap(vec3 color, float overexposureLimit) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scaledLuminance = extendedReinhardToneMap(luminance, overexposureLimit);\n            float scale = scaledLuminance / luminance;\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 extendedReinhardPerChannelToneMap(vec3 color, float overexposureLimit) {\n            float red = extendedReinhardToneMap(color.r, overexposureLimit);\n            float green = extendedReinhardToneMap(color.g, overexposureLimit);\n            float blue = extendedReinhardToneMap(color.b, overexposureLimit);\n            return gammaCorrectedColor(vec3(red, green, blue));\n        }\n        \n        vec3 hableFilmicHelper(vec3 color) {\n            float a = 0.15;\n            float b = 0.5;\n            float c = 0.1;\n            float d = 0.2;\n            float e = 0.02;\n            float f = 0.3;\n            return (color * (a * color + c * b) + d * e) / (color * (a * color + b) + d * f) - e / f;\n        }\n        \n        vec3 hableFilmicToneMap(vec3 color) {\n            float exposureBias = 2.0;\n            vec3 unscaled = hableFilmicHelper(exposureBias * color);\n            vec3 scale = 1.0 / hableFilmicHelper(vec3(11.2));\n            return gammaCorrectedColor(scale * unscaled);\n        }\n        \n        vec3 toneMap(vec3 color, float toneMapType, float toneMapParam) {\n            if (toneMapType == 0.0) {\n                return gammaCorrectedColor(color);\n            } else if (toneMapType == 1.0) {\n                return reinhardLuminanceToneMap(color);\n            } else if (toneMapType == 2.0) {\n                return reinhardPerChannelToneMap(color);\n            } else if (toneMapType == 3.0) {\n                return extendedReinhardLuminanceToneMap(color, toneMapParam);\n            } else if (toneMapType == 4.0) {\n                return extendedReinhardPerChannelToneMap(color, toneMapParam);\n            } else if (toneMapType == 5.0) {\n                return hableFilmicToneMap(color);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {\n            vec3 referenceWhite = sceneProperties[2].rgb;\n            float unitR = linearColor.r / referenceWhite.r;\n            float unitG = linearColor.g / referenceWhite.g;\n            float unitB = linearColor.b / referenceWhite.b;\n            float toneMapType = sceneProperties[3][2];\n            float toneMapParam = sceneProperties[3][3];\n            vec3 toneMapped = toneMap(vec3(unitR, unitG, unitB), toneMapType, toneMapParam);\n            return vec4(toneMapped, 1.0);\n        }\n        \n        void main() {\n            vec3 normalDirection = normalize(interpolatedNormal) * getNormalSign();\n            vec3 directionToCamera = getDirectionToCamera(interpolatedPosition, sceneProperties);\n        \n            vec3 linearColor = physicalLighting(\n                interpolatedPosition,\n                normalDirection,\n                baseColor,\n                directionToCamera,\n                viewMatrix,\n                roughness,\n                metallic,\n                lights12,\n                lights34,\n                lights56,\n                lights78,\n                enabledLights\n            );\n        \n            gl_FragColor = toSrgb(linearColor, sceneProperties);\n        }\n    ",attributes:{},uniforms:{baseColor:"cJ",enabledLights:"af",lights12:"bP",lights34:"cl",lights56:"cm",lights78:"cn",metallic:"c4",roughness:"dr",sceneProperties:"g",viewMatrix:"h"}},ou={src:"\n        precision highp float;\n        \n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 lights12;\n        uniform highp mat4 lights34;\n        uniform highp mat4 lights56;\n        uniform highp mat4 lights78;\n        uniform lowp vec4 enabledLights;\n        uniform mediump sampler2D baseColorTexture;\n        uniform lowp vec4 constantBaseColor;\n        uniform mediump sampler2D roughnessTexture;\n        uniform lowp vec2 constantRoughness;\n        uniform mediump sampler2D metallicTexture;\n        uniform lowp vec2 constantMetallic;\n        uniform mediump sampler2D normalMapTexture;\n        uniform lowp float useNormalMap;\n        \n        varying highp vec3 interpolatedPosition;\n        varying highp vec3 interpolatedNormal;\n        varying mediump vec2 interpolatedUv;\n        varying highp vec3 interpolatedTangent;\n        \n        const lowp float kPerspectiveProjection = 0.0;\n        const lowp float kOrthographicProjection = 1.0;\n        const lowp float kDirectionalLight = 1.0;\n        const lowp float kPointLight = 2.0;\n        const highp float kPi = 3.14159265359;\n        const mediump float kMediumpFloatMax = 65504.0;\n        const lowp float kDisabledLight = 0.0;\n        const lowp float kSoftLighting = 3.0;\n        \n        float getFloatValue(sampler2D texture, vec2 uv, vec2 constantValue) {\n            if (constantValue.y == 1.0) {\n                return constantValue.x;\n            } else {\n                vec4 textureColor = texture2D(texture, uv);\n                return dot(textureColor, vec4(0.2126, 0.7152, 0.0722, 0.0));\n            }\n        }\n        \n        vec3 getLocalNormal(sampler2D normalMap, float useNormalMap, vec2 uv) {\n            vec3 rgb = useNormalMap * texture2D(normalMap, uv).rgb + (1.0 - useNormalMap) * vec3(0.5, 0.5, 1.0);\n            float x = 2.0 * (rgb.r - 0.5);\n            float y = 2.0 * (rgb.g - 0.5);\n            float z = 2.0 * (rgb.b - 0.5);\n            return normalize(vec3(-x, -y, z));\n        }\n        \n        float getNormalSign() {\n            return 2.0 * float(gl_FrontFacing) - 1.0;\n        }\n        \n        vec3 getMappedNormal(vec3 normal, vec3 tangent, float normalSign, vec3 localNormal) {\n            vec3 bitangent = cross(normal, tangent) * normalSign;\n            return normalize(localNormal.x * tangent + localNormal.y * bitangent + localNormal.z * normal);\n        }\n        \n        vec3 getDirectionToCamera(vec3 surfacePosition, mat4 sceneProperties) {\n            float projectionType = sceneProperties[1].w;\n            if (projectionType == kPerspectiveProjection) {\n                vec3 cameraPoint = sceneProperties[1].xyz;\n                return normalize(cameraPoint - surfacePosition);\n            } else if (projectionType == kOrthographicProjection) {\n                return sceneProperties[1].xyz;\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        void getDirectionToLightAndNormalIlluminance(\n            vec4 xyz_type,\n            vec4 rgb_parameter,\n            vec3 surfacePosition,\n            out vec3 directionToLight,\n            out vec3 normalIlluminance\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDirectionalLight) {\n                directionToLight = xyz_type.xyz;\n                normalIlluminance = rgb_parameter.rgb;\n            } else if (lightType == kPointLight) {\n                vec3 lightPosition = xyz_type.xyz;\n                vec3 displacement = lightPosition - surfacePosition;\n                float distance = length(displacement);\n                directionToLight = displacement / distance;\n                normalIlluminance = rgb_parameter.rgb / (4.0 * kPi * distance * distance);\n            }\n        }\n        \n        float positiveDotProduct(vec3 v1, vec3 v2) {\n            return clamp(dot(v1, v2), 0.0, 1.0);\n        }\n        \n        // Adapted from https://google.github.io/filament/Filament.md.html#materialsystem/specularbrdf/normaldistributionfunction(speculard)\n        float specularD(float alpha, float dotNH, vec3 normalDirection, vec3 halfDirection) {\n            vec3 crossNH = cross(normalDirection, halfDirection);\n            float a = dotNH * alpha;\n            float k = alpha / (dot(crossNH, crossNH) + a * a);\n            float d = k * k * (1.0 / kPi);\n            return min(d, kMediumpFloatMax);\n        }\n        \n        float safeQuotient(float numerator, float denominator) {\n            if (denominator == 0.0) {\n                return 0.0;\n            } else {\n                return numerator / denominator;\n            }\n        }\n        \n        float g1(float dotNV, float alphaSquared) {\n            return safeQuotient(2.0 * dotNV, dotNV + sqrt(alphaSquared + (1.0 - alphaSquared) * dotNV * dotNV));\n        }\n        \n        float specularG(float dotNL, float dotNV, float alphaSquared) {\n            return g1(dotNV, alphaSquared) * g1(dotNL, alphaSquared);\n        }\n        \n        vec3 fresnelColor(vec3 specularBaseColor, float dotVH) {\n            vec3 one = vec3(1.0, 1.0, 1.0);\n            float scale = exp2((-5.55473 * dotVH - 6.98316) * dotVH);\n            return specularBaseColor + (one - specularBaseColor) * scale;\n        }\n        \n        vec3 brdf(vec3 normalDirection, vec3 directionToCamera, vec3 directionToLight, float alpha, float dotNV, float dotNL, vec3 specularBaseColor, vec3 normalIlluminance) {\n            vec3 halfDirection = normalize(directionToCamera + directionToLight);\n            float dotVH = positiveDotProduct(directionToCamera, halfDirection);\n            float dotNH = positiveDotProduct(normalDirection, halfDirection);\n            float dotNHSquared = dotNH * dotNH;\n        \n            float d = specularD(alpha, dotNH, normalDirection, halfDirection);\n            float g = specularG(dotNL, dotNV, alpha * alpha);\n            vec3 f = fresnelColor(specularBaseColor, dotVH);\n            return safeQuotient(d * g, 4.0 * dotNL * dotNV) * f;\n        }\n        \n        vec3 sampleFacetNormal(vec3 vH, vec3 vT1, vec3 vT2, float s, float alpha) {\n            float t2 = (1.0 - s);\n            vec3 vNh = t2 * vT2 + sqrt(max(0.0, 1.0 - t2 * t2)) * vH;\n            return normalize(vec3(alpha * vNh.x, alpha * vNh.y, max(0.0, vNh.z)));\n        }\n        \n        vec3 softLightingLuminance(\n            vec3 aboveLuminance,\n            vec3 belowLuminance,\n            vec3 localUpDirection,\n            vec3 localLightDirection\n        ) {\n            float sinElevation = dot(localLightDirection, localUpDirection);\n            float t = (sinElevation + 1.0) / 2.0;\n            return aboveLuminance * t + belowLuminance * (1.0 - t);\n        }\n        \n        vec3 softLightingSpecularSample(\n            vec3 aboveLuminance,\n            vec3 belowLuminance,\n            vec3 localUpDirection,\n            vec3 localViewDirection,\n            vec3 localLightDirection,\n            vec3 localHalfDirection,\n            float alphaSquared,\n            vec3 specularBaseColor\n        ) {\n            vec3 luminance = softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection);\n            float dotVH = positiveDotProduct(localViewDirection, localHalfDirection);\n            float dotNL = localLightDirection.z;\n            return luminance * (fresnelColor(specularBaseColor, dotVH) * g1(dotNL, alphaSquared));\n        }\n        \n        vec3 softLighting(\n            vec3 normalDirection,\n            vec3 diffuseBaseColor,\n            vec3 specularBaseColor,\n            float alpha,\n            vec3 directionToCamera,\n            vec3 viewY,\n            vec4 xyz_type,\n            vec4 rgb_parameter\n        ) {\n            float alphaSquared = alpha * alpha;\n            vec3 upDirection = xyz_type.xyz;\n            vec3 luminanceAbove = rgb_parameter.rgb;\n            vec3 luminanceBelow = rgb_parameter.a * luminanceAbove;\n            vec3 crossProduct = cross(normalDirection, directionToCamera);\n            float crossMagnitude = length(crossProduct);\n            vec3 xDirection = vec3(0.0, 0.0, 0.0);\n            vec3 yDirection = vec3(0.0, 0.0, 0.0);\n            if (crossMagnitude > 1.0e-6) {\n                yDirection = (1.0 / crossMagnitude) * crossProduct;\n                xDirection = cross(yDirection, normalDirection);\n            } else {\n                vec3 viewY = vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]);\n                xDirection = normalize(cross(viewY, normalDirection));\n                yDirection = cross(normalDirection, xDirection);\n            }\n            float localViewX = dot(directionToCamera, xDirection);\n            float localViewZ = dot(directionToCamera, normalDirection);\n            vec3 localViewDirection = vec3(localViewX, 0, localViewZ);\n            float localUpX = dot(upDirection, xDirection);\n            float localUpY = dot(upDirection, yDirection);\n            float localUpZ = dot(upDirection, normalDirection);\n            vec3 localUpDirection = vec3(localUpX, localUpY, localUpZ);\n        \n            vec3 vH = normalize(vec3(alpha * localViewX, 0.0, localViewZ));\n            vec3 vT1 = vec3(0.0, 1.0, 0.0);\n            vec3 vT2 = cross(vH, vT1);\n            float s = 0.5 * (1.0 + vH.z);\n            \n            vec3 localHalfDirection = sampleFacetNormal(vH, vT1, vT2, s, alpha);\n            vec3 localLightDirection = vec3(0.0, 0.0, 0.0);\n            \n            localLightDirection = -reflect(localViewDirection, localHalfDirection);\n            vec3 specular = softLightingSpecularSample(luminanceAbove, luminanceBelow, localUpDirection, localViewDirection, localLightDirection, localHalfDirection, alphaSquared, specularBaseColor);\n            \n            localLightDirection = vec3(0.000000, 0.000000, 1.000000);\n            vec3 diffuse = softLightingLuminance(luminanceAbove, luminanceBelow, localUpDirection, localLightDirection) * localLightDirection.z;\n            \n            return specular + diffuse * diffuseBaseColor;\n        }\n        \n        vec3 physicalLight(\n            vec4 xyz_type,\n            vec4 rgb_parameter,\n            vec3 surfacePosition,\n            vec3 normalDirection,\n            vec3 directionToCamera,\n            vec3 viewY,\n            float dotNV,\n            vec3 diffuseBaseColor,\n            vec3 specularBaseColor,\n            float alpha\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDisabledLight) {\n                return vec3(0.0, 0.0, 0.0);\n            } else if (lightType == kSoftLighting) {\n                return softLighting(normalDirection, diffuseBaseColor, specularBaseColor, alpha, directionToCamera, viewY, xyz_type, rgb_parameter);\n            }\n        \n            vec3 directionToLight = vec3(0.0, 0.0, 0.0);\n            vec3 normalIlluminance = vec3(0.0, 0.0, 0.0);\n            getDirectionToLightAndNormalIlluminance(xyz_type, rgb_parameter, surfacePosition, directionToLight, normalIlluminance);\n        \n            float dotNL = positiveDotProduct(normalDirection, directionToLight);\n            vec3 specularColor = brdf(normalDirection, directionToCamera, directionToLight, alpha, dotNV, dotNL, specularBaseColor, normalIlluminance);\n            return (normalIlluminance * dotNL) * ((diffuseBaseColor / kPi) + specularColor);\n        }\n        \n        vec3 physicalLighting(\n            vec3 surfacePosition,\n            vec3 surfaceNormal,\n            vec3 baseColor,\n            vec3 directionToCamera,\n            mat4 viewMatrix,\n            float roughness,\n            float metallic,\n            mat4 lights12,\n            mat4 lights34,\n            mat4 lights56,\n            mat4 lights78,\n            vec4 enabledLights\n        ) {\n            float dotNV = positiveDotProduct(surfaceNormal, directionToCamera);\n            float alpha = roughness * roughness;\n            float nonmetallic = 1.0 - metallic;\n            vec3 diffuseBaseColor = nonmetallic * 0.96 * baseColor;\n            vec3 specularBaseColor = nonmetallic * 0.04 * vec3(1.0, 1.0, 1.0) + metallic * baseColor;\n            vec3 viewY = vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]);\n        \n            vec3 litColor1 = enabledLights[0] == 1.0 ? physicalLight(lights12[0], lights12[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor2 = enabledLights[1] == 1.0 ? physicalLight(lights12[2], lights12[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor3 = enabledLights[2] == 1.0 ? physicalLight(lights34[0], lights34[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor4 = enabledLights[3] == 1.0 ? physicalLight(lights34[2], lights34[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor5 = physicalLight(lights56[0], lights56[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            vec3 litColor6 = physicalLight(lights56[2], lights56[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            vec3 litColor7 = physicalLight(lights78[0], lights78[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            vec3 litColor8 = physicalLight(lights78[2], lights78[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            return litColor1 + litColor2 + litColor3 + litColor4 + litColor5 + litColor6 + litColor7 + litColor8;\n        }\n        \n        float inverseGamma(float u) {\n            if (u <= 0.04045) {\n                return clamp(u / 12.92, 0.0, 1.0);\n            } else {\n                return clamp(pow((u + 0.055) / 1.055, 2.4), 0.0, 1.0);\n            }\n        }\n        \n        vec3 fromSrgb(vec3 srgbColor) {\n            return vec3(\n                inverseGamma(srgbColor.r),\n                inverseGamma(srgbColor.g),\n                inverseGamma(srgbColor.b)\n            );\n        }\n        \n        float gammaCorrect(float u) {\n            if (u <= 0.0031308) {\n                return 12.92 * u;\n            } else {\n                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;\n            }\n        }\n        \n        vec3 gammaCorrectedColor(vec3 color) {\n            float red = gammaCorrect(color.r);\n            float green = gammaCorrect(color.g);\n            float blue = gammaCorrect(color.b);\n            return vec3(red, green, blue);\n        }\n        \n        vec3 reinhardLuminanceToneMap(vec3 color) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scale = 1.0 / (1.0 + luminance);\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 reinhardPerChannelToneMap(vec3 color) {\n            return gammaCorrectedColor(color / (color + 1.0));\n        }\n        \n        float extendedReinhardToneMap(float x, float xMax) {\n            return x * (1.0 + (x / (xMax * xMax))) / (1.0 + x);\n        }\n        \n        vec3 extendedReinhardLuminanceToneMap(vec3 color, float overexposureLimit) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scaledLuminance = extendedReinhardToneMap(luminance, overexposureLimit);\n            float scale = scaledLuminance / luminance;\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 extendedReinhardPerChannelToneMap(vec3 color, float overexposureLimit) {\n            float red = extendedReinhardToneMap(color.r, overexposureLimit);\n            float green = extendedReinhardToneMap(color.g, overexposureLimit);\n            float blue = extendedReinhardToneMap(color.b, overexposureLimit);\n            return gammaCorrectedColor(vec3(red, green, blue));\n        }\n        \n        vec3 hableFilmicHelper(vec3 color) {\n            float a = 0.15;\n            float b = 0.5;\n            float c = 0.1;\n            float d = 0.2;\n            float e = 0.02;\n            float f = 0.3;\n            return (color * (a * color + c * b) + d * e) / (color * (a * color + b) + d * f) - e / f;\n        }\n        \n        vec3 hableFilmicToneMap(vec3 color) {\n            float exposureBias = 2.0;\n            vec3 unscaled = hableFilmicHelper(exposureBias * color);\n            vec3 scale = 1.0 / hableFilmicHelper(vec3(11.2));\n            return gammaCorrectedColor(scale * unscaled);\n        }\n        \n        vec3 toneMap(vec3 color, float toneMapType, float toneMapParam) {\n            if (toneMapType == 0.0) {\n                return gammaCorrectedColor(color);\n            } else if (toneMapType == 1.0) {\n                return reinhardLuminanceToneMap(color);\n            } else if (toneMapType == 2.0) {\n                return reinhardPerChannelToneMap(color);\n            } else if (toneMapType == 3.0) {\n                return extendedReinhardLuminanceToneMap(color, toneMapParam);\n            } else if (toneMapType == 4.0) {\n                return extendedReinhardPerChannelToneMap(color, toneMapParam);\n            } else if (toneMapType == 5.0) {\n                return hableFilmicToneMap(color);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {\n            vec3 referenceWhite = sceneProperties[2].rgb;\n            float unitR = linearColor.r / referenceWhite.r;\n            float unitG = linearColor.g / referenceWhite.g;\n            float unitB = linearColor.b / referenceWhite.b;\n            float toneMapType = sceneProperties[3][2];\n            float toneMapParam = sceneProperties[3][3];\n            vec3 toneMapped = toneMap(vec3(unitR, unitG, unitB), toneMapType, toneMapParam);\n            return vec4(toneMapped, 1.0);\n        }\n        \n        void main() {\n            vec3 baseColor = fromSrgb(texture2D(baseColorTexture, interpolatedUv).rgb) * (1.0 - constantBaseColor.w) + constantBaseColor.rgb * constantBaseColor.w;\n            float roughness = getFloatValue(roughnessTexture, interpolatedUv, constantRoughness);\n            float metallic = getFloatValue(metallicTexture, interpolatedUv, constantMetallic);\n        \n            vec3 localNormal = getLocalNormal(normalMapTexture, useNormalMap, interpolatedUv);\n            float normalSign = getNormalSign();\n            vec3 originalNormal = normalize(interpolatedNormal) * normalSign;\n            vec3 normalDirection = getMappedNormal(originalNormal, interpolatedTangent, normalSign, localNormal);\n            vec3 directionToCamera = getDirectionToCamera(interpolatedPosition, sceneProperties);\n        \n            vec3 linearColor = physicalLighting(\n                interpolatedPosition,\n                normalDirection,\n                baseColor,\n                directionToCamera,\n                viewMatrix,\n                roughness,\n                metallic,\n                lights12,\n                lights34,\n                lights56,\n                lights78,\n                enabledLights\n            );\n        \n            gl_FragColor = toSrgb(linearColor, sceneProperties);\n        }\n    ",attributes:{},uniforms:{baseColorTexture:"cK",constantBaseColor:"cM",constantMetallic:"cN",constantRoughness:"cO",enabledLights:"af",lights12:"bP",lights34:"cl",lights56:"cm",lights78:"cn",metallicTexture:"c5",normalMapTexture:"bp",roughnessTexture:"ds",sceneProperties:"g",useNormalMap:"bv",viewMatrix:"h"}},au={src:"\n        precision highp float;\n        \n        attribute highp vec3 quadVertex;\n        \n        uniform highp vec4 modelScale;\n        uniform highp mat4 modelMatrix;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 projectionMatrix;\n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 quadVertexPositions;\n        \n        void getQuadVertex(int quadVertexIndex, mat4 quadVertexPositions, out vec3 position, out vec3 normal, out vec3 tangent) {\n            vec3 next = vec3(0.0, 0.0, 0.0);\n            vec3 prev = vec3(0.0, 0.0, 0.0);\n            if (quadVertexIndex == 0) {\n                prev = quadVertexPositions[3].xyz;\n                position = quadVertexPositions[0].xyz;\n                next = quadVertexPositions[1].xyz;\n                tangent = normalize(next - position);\n            } else if (quadVertexIndex == 1) {\n                prev = quadVertexPositions[0].xyz;\n                position = quadVertexPositions[1].xyz;\n                next = quadVertexPositions[2].xyz;\n                tangent = normalize(position - prev);\n            } else if (quadVertexIndex == 2) {\n                prev = quadVertexPositions[1].xyz;\n                position = quadVertexPositions[2].xyz;\n                next = quadVertexPositions[3].xyz;\n                tangent = normalize(position - next);\n            } else {\n                prev = quadVertexPositions[2].xyz;\n                position = quadVertexPositions[3].xyz;\n                next = quadVertexPositions[0].xyz;\n                tangent = normalize(prev - position);\n            }\n            normal = normalize(cross(next - position, prev - position));\n        }\n        \n        vec4 getWorldPosition(vec3 modelPosition, vec4 modelScale, mat4 modelMatrix) {\n            vec4 scaledPosition = vec4(modelScale.xyz * modelPosition, 1.0);\n            return modelMatrix * scaledPosition;\n        }\n        \n        void main() {\n            vec3 position = vec3(0.0, 0.0, 0.0);\n            vec3 normal = vec3(0.0, 0.0, 0.0);\n            vec3 tangent = vec3(0.0, 0.0, 0.0);\n            getQuadVertex(int(quadVertex.z), quadVertexPositions, position, normal, tangent);\n            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);\n            gl_Position = projectionMatrix * (viewMatrix * worldPosition);\n        }\n    ",attributes:{quadVertex:"cw"},uniforms:{modelMatrix:"d",modelScale:"e",projectionMatrix:"f",quadVertexPositions:"aA",sceneProperties:"g",viewMatrix:"h"}},iu=u(function(e,n,r,t){t=b(t),r=b(r),n=b(n),e=b(e);return Lc({ec:e.ac,ed:n.ac,ee:r.ac,ef:t.ac,eg:e.ad,eh:n.ad,ei:r.ad,ej:t.ad,ek:e.fb,el:n.fb,em:r.fb,en:t.fb,eo:0,ep:0,eq:0,er:0})}),cu=Re({dR:1,d0:0,eA:6})(p([{cw:$(Pc,0,0,0)},{cw:$(Pc,1,0,1)},{cw:$(Pc,1,1,2)},{cw:$(Pc,0,1,3)}])),lu=s(function(e,n){return{$:1,a:e,b:n}}),uu=s(function(e,n){return n.$?{a:n.a.q,b:1}:{a:e,b:0}}),fu=V(bc,0,0,0,0),su=s(function(e,n){return n.$?{a:n.a.q,b:fu}:{a:e,b:V(bc,tl(e=n.a),ol(e),al(e),1)}}),du=s(function(e,n){var r,t={a:e,b:n};return t.a.$?z(lu,{a:r=t.a.a.q,b:fu},z(uu,r,n)):t.b.$?z(lu,z(su,r=t.b.a.q,e),z(uu,r,n)):{$:0,a:t.a.a}}),vu=d(function(e,n,r){return{$:0,a:e,b:n,c:r}}),mu=u(function(e,n,r,t){return{$:1,a:e,b:n,c:r,d:t}}),pu=u(function(e,n,r,t){return{$:0,a:e,b:n,c:r,d:t}}),gu=z(r,0,0),bu=s(function(e,n){return n.$?{a:n.a.q,b:gu}:{a:e,b:z(r,n.a,1)}}),hu=u(function(e,n,r,t){var o,a=V(pu,e,n,r,t);return a.a.$?V(mu,{a:o=a.a.a.q,b:fu},z(bu,o,n),z(bu,o,r),z(uu,o,t)):a.b.$?V(mu,z(su,o=a.b.a.q,e),{a:o,b:gu},z(bu,o,r),z(uu,o,t)):a.c.$?V(mu,z(su,o=a.c.a.q,e),z(bu,o,n),{a:o,b:gu},z(uu,o,t)):a.d.$?V(mu,z(su,o=a.d.a.q,e),z(bu,o,n),z(bu,o,r),{a:o,b:1}):$(vu,a.a.a,a.b.a,a.c.a)}),xu=nr,Cu={src:"\n        precision highp float;\n        \n        attribute highp vec3 quadVertex;\n        \n        uniform highp vec4 modelScale;\n        uniform highp mat4 modelMatrix;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 projectionMatrix;\n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 quadVertexPositions;\n        \n        varying highp vec3 interpolatedPosition;\n        varying highp vec3 interpolatedNormal;\n        \n        void getQuadVertex(int quadVertexIndex, mat4 quadVertexPositions, out vec3 position, out vec3 normal, out vec3 tangent) {\n            vec3 next = vec3(0.0, 0.0, 0.0);\n            vec3 prev = vec3(0.0, 0.0, 0.0);\n            if (quadVertexIndex == 0) {\n                prev = quadVertexPositions[3].xyz;\n                position = quadVertexPositions[0].xyz;\n                next = quadVertexPositions[1].xyz;\n                tangent = normalize(next - position);\n            } else if (quadVertexIndex == 1) {\n                prev = quadVertexPositions[0].xyz;\n                position = quadVertexPositions[1].xyz;\n                next = quadVertexPositions[2].xyz;\n                tangent = normalize(position - prev);\n            } else if (quadVertexIndex == 2) {\n                prev = quadVertexPositions[1].xyz;\n                position = quadVertexPositions[2].xyz;\n                next = quadVertexPositions[3].xyz;\n                tangent = normalize(position - next);\n            } else {\n                prev = quadVertexPositions[2].xyz;\n                position = quadVertexPositions[3].xyz;\n                next = quadVertexPositions[0].xyz;\n                tangent = normalize(prev - position);\n            }\n            normal = normalize(cross(next - position, prev - position));\n        }\n        \n        vec4 getWorldPosition(vec3 modelPosition, vec4 modelScale, mat4 modelMatrix) {\n            vec4 scaledPosition = vec4(modelScale.xyz * modelPosition, 1.0);\n            return modelMatrix * scaledPosition;\n        }\n        \n        vec3 safeNormalize(vec3 vector) {\n            if (vector == vec3(0.0, 0.0, 0.0)) {\n                return vector;\n            } else {\n                return normalize(vector);\n            }\n        }\n        \n        vec3 getWorldNormal(vec3 modelNormal, vec4 modelScale, mat4 modelMatrix) {\n            vec3 normalScale = vec3(modelScale.w / modelScale.x, modelScale.w / modelScale.y, modelScale.w / modelScale.z);\n            return (modelMatrix * vec4(safeNormalize(normalScale * modelNormal), 0.0)).xyz;\n        }\n        \n        void main() {\n            vec3 position = vec3(0.0, 0.0, 0.0);\n            vec3 normal = vec3(0.0, 0.0, 0.0);\n            vec3 tangent = vec3(0.0, 0.0, 0.0);\n            getQuadVertex(int(quadVertex.z), quadVertexPositions, position, normal, tangent);\n            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);\n            gl_Position = projectionMatrix * (viewMatrix * worldPosition);\n            interpolatedPosition = worldPosition.xyz;\n            interpolatedNormal = getWorldNormal(normal, modelScale, modelMatrix);\n        }\n    ",attributes:{quadVertex:"cw"},uniforms:{modelMatrix:"d",modelScale:"e",projectionMatrix:"f",quadVertexPositions:"aA",sceneProperties:"g",viewMatrix:"h"}},Pu={src:"\n        precision highp float;\n        \n        attribute highp vec3 quadVertex;\n        \n        uniform highp vec4 modelScale;\n        uniform highp mat4 modelMatrix;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 projectionMatrix;\n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 quadVertexPositions;\n        \n        varying highp vec3 interpolatedPosition;\n        varying highp vec3 interpolatedNormal;\n        varying mediump vec2 interpolatedUv;\n        varying highp vec3 interpolatedTangent;\n        \n        void getQuadVertex(int quadVertexIndex, mat4 quadVertexPositions, out vec3 position, out vec3 normal, out vec3 tangent) {\n            vec3 next = vec3(0.0, 0.0, 0.0);\n            vec3 prev = vec3(0.0, 0.0, 0.0);\n            if (quadVertexIndex == 0) {\n                prev = quadVertexPositions[3].xyz;\n                position = quadVertexPositions[0].xyz;\n                next = quadVertexPositions[1].xyz;\n                tangent = normalize(next - position);\n            } else if (quadVertexIndex == 1) {\n                prev = quadVertexPositions[0].xyz;\n                position = quadVertexPositions[1].xyz;\n                next = quadVertexPositions[2].xyz;\n                tangent = normalize(position - prev);\n            } else if (quadVertexIndex == 2) {\n                prev = quadVertexPositions[1].xyz;\n                position = quadVertexPositions[2].xyz;\n                next = quadVertexPositions[3].xyz;\n                tangent = normalize(position - next);\n            } else {\n                prev = quadVertexPositions[2].xyz;\n                position = quadVertexPositions[3].xyz;\n                next = quadVertexPositions[0].xyz;\n                tangent = normalize(prev - position);\n            }\n            normal = normalize(cross(next - position, prev - position));\n        }\n        \n        vec4 getWorldPosition(vec3 modelPosition, vec4 modelScale, mat4 modelMatrix) {\n            vec4 scaledPosition = vec4(modelScale.xyz * modelPosition, 1.0);\n            return modelMatrix * scaledPosition;\n        }\n        \n        vec3 safeNormalize(vec3 vector) {\n            if (vector == vec3(0.0, 0.0, 0.0)) {\n                return vector;\n            } else {\n                return normalize(vector);\n            }\n        }\n        \n        vec3 getWorldNormal(vec3 modelNormal, vec4 modelScale, mat4 modelMatrix) {\n            vec3 normalScale = vec3(modelScale.w / modelScale.x, modelScale.w / modelScale.y, modelScale.w / modelScale.z);\n            return (modelMatrix * vec4(safeNormalize(normalScale * modelNormal), 0.0)).xyz;\n        }\n        \n        void main() {\n            vec3 position = vec3(0.0, 0.0, 0.0);\n            vec3 normal = vec3(0.0, 0.0, 0.0);\n            vec3 tangent = vec3(0.0, 0.0, 0.0);\n            getQuadVertex(int(quadVertex.z), quadVertexPositions, position, normal, tangent);\n            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);\n            gl_Position = projectionMatrix * (viewMatrix * worldPosition);\n            interpolatedPosition = worldPosition.xyz;\n            interpolatedNormal = getWorldNormal(normal, modelScale, modelMatrix);\n            interpolatedUv = quadVertex.xy;\n            interpolatedTangent = tangent;\n        }\n    ",attributes:{quadVertex:"cw"},uniforms:{modelMatrix:"d",modelScale:"e",projectionMatrix:"f",quadVertexPositions:"aA",sceneProperties:"g",viewMatrix:"h"}},Tu=d(function(e,n,r){return.5<r?n+(1-r)*(e-n):e+r*(n-e)}),yu=function(e){return $(Tu,e.ew,e.et,.5)},Lu=function(e){return $(Tu,e.ex,e.eu,.5)},Mu=function(e){return $(Tu,e.ey,e.ev,.5)},wu=d(function(e,n,r){return{ac:e,ad:n,fb:r}}),Du={src:"\n        precision highp float;\n        \n        attribute highp vec3 quadVertex;\n        \n        uniform highp vec4 modelScale;\n        uniform highp mat4 modelMatrix;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 projectionMatrix;\n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 quadVertexPositions;\n        \n        varying mediump vec2 interpolatedUv;\n        \n        void getQuadVertex(int quadVertexIndex, mat4 quadVertexPositions, out vec3 position, out vec3 normal, out vec3 tangent) {\n            vec3 next = vec3(0.0, 0.0, 0.0);\n            vec3 prev = vec3(0.0, 0.0, 0.0);\n            if (quadVertexIndex == 0) {\n                prev = quadVertexPositions[3].xyz;\n                position = quadVertexPositions[0].xyz;\n                next = quadVertexPositions[1].xyz;\n                tangent = normalize(next - position);\n            } else if (quadVertexIndex == 1) {\n                prev = quadVertexPositions[0].xyz;\n                position = quadVertexPositions[1].xyz;\n                next = quadVertexPositions[2].xyz;\n                tangent = normalize(position - prev);\n            } else if (quadVertexIndex == 2) {\n                prev = quadVertexPositions[1].xyz;\n                position = quadVertexPositions[2].xyz;\n                next = quadVertexPositions[3].xyz;\n                tangent = normalize(position - next);\n            } else {\n                prev = quadVertexPositions[2].xyz;\n                position = quadVertexPositions[3].xyz;\n                next = quadVertexPositions[0].xyz;\n                tangent = normalize(prev - position);\n            }\n            normal = normalize(cross(next - position, prev - position));\n        }\n        \n        vec4 getWorldPosition(vec3 modelPosition, vec4 modelScale, mat4 modelMatrix) {\n            vec4 scaledPosition = vec4(modelScale.xyz * modelPosition, 1.0);\n            return modelMatrix * scaledPosition;\n        }\n        \n        void main() {\n            vec3 position = vec3(0.0, 0.0, 0.0);\n            vec3 normal = vec3(0.0, 0.0, 0.0);\n            vec3 tangent = vec3(0.0, 0.0, 0.0);\n            getQuadVertex(int(quadVertex.z), quadVertexPositions, position, normal, tangent);\n            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);\n            gl_Position = projectionMatrix * (viewMatrix * worldPosition);\n            interpolatedUv = quadVertex.xy;\n        }\n    ",attributes:{quadVertex:"cw"},uniforms:{modelMatrix:"d",modelScale:"e",projectionMatrix:"f",quadVertexPositions:"aA",sceneProperties:"g",viewMatrix:"h"}},Nu=R(function(r,M,w,D,N){var e=z(Zl,M,p([w,D,N])),e=Xr(e);return z(Ul,e,function(){switch(r.$){case 0:var l;return r.b.$?(u=r.b.a.q,t(function(e,n,r,t,o,a,i,c){return S(B,$(ru,t,0,c),Du,Ol,cu,{cd:u,d:r,e:n,f:a,aA:V(iu,M,w,D,N),g:e,h:o})})):(l=r.b.a,t(function(e,n,r,t,o,a,i,c){return S(B,$(ru,t,0,c),au,Wl,cu,{a1:l,d:r,e:n,f:a,aA:V(iu,M,w,D,N),g:e,h:o})}));case 1:var u,f,s;return r.b.$?(u=r.b.a.q,s=r.c,t(function(e,n,r,t,o,a,i,c){return S(B,$(ru,t,0,c),Du,Kl,cu,{cH:Qr(s),cd:u,d:r,e:n,f:a,aA:V(iu,M,w,D,N),g:e,h:o})})):(f=r.b.a,s=r.c,t(function(e,n,r,t,o,a,i,c){return S(B,$(ru,t,0,c),au,Yl,cu,{cH:s,bh:z(xu,Qr(s),f),d:r,e:n,f:a,aA:V(iu,M,w,D,N),g:e,h:o})}));case 2:var d,v,e=z(du,r.b,r.c);return e.$?(d=e.a.a,C=(n=e.b).a,P=n.b,t(function(e,n,r,t,o,a,i,c){var l=i.a,i=i.b;return S(B,$(ru,t,0,c),Pu,Jl,cu,{af:i,bP:l.bP,cl:l.cl,cm:l.cm,cn:l.cn,c2:d,d:r,e:n,bp:C,f:a,aA:V(iu,M,w,D,N),g:e,bv:P,h:o})})):(v=e.a,t(function(e,n,r,t,o,a,i,c){var l=i.a,i=i.b;return S(B,$(ru,t,0,c),Cu,Xl,cu,{af:i,bP:l.bP,cl:l.cl,cm:l.cm,cn:l.cn,c1:v,d:r,e:n,f:a,aA:V(iu,M,w,D,N),g:e,h:o})}));default:var m,p,g,b,h,x,C,P,T,y,L,n=V(hu,r.b,r.c,r.d,r.e);return n.$?(m=(e=n.a).a,p=e.b,g=(e=n.b).a,b=e.b,h=(e=n.c).a,x=e.b,C=(e=n.d).a,P=e.b,t(function(e,n,r,t,o,a,i,c){var l=i.a,i=i.b;return S(B,$(ru,t,0,c),Pu,ou,cu,{cK:m,cM:p,cN:x,cO:b,af:i,bP:l.bP,cl:l.cl,cm:l.cm,cn:l.cn,c5:h,d:r,e:n,bp:C,f:a,aA:V(iu,M,w,D,N),ds:g,g:e,bv:P,h:o})})):(T=n.a,y=n.b,L=n.c,t(function(e,n,r,t,o,a,i,c){var l=i.a,i=i.b;return S(B,$(ru,t,0,c),Cu,tu,cu,{cJ:T,af:i,bP:l.bP,cl:l.cl,cm:l.cm,cn:l.cn,c4:L,d:r,e:n,f:a,aA:V(iu,M,w,D,N),dr:y,g:e,h:o})}))}}())}),Z=d(function(e,n,r){return{$:3,a:e,b:n,c:r}})({dR:1,d0:3,eA:4}),zu=(te=p([{aT:z(r,0,1)},{aT:z(r,1,1)},{aT:z(r,2,1)},{aT:z(r,3,1)},{aT:z(r,0,-1)},{aT:z(r,1,-1)},{aT:z(r,2,-1)},{aT:z(r,3,-1)}]),oe=p([{a:0,b:1,c:2},{a:0,b:2,c:3},{a:4,b:6,c:5},{a:4,b:7,c:6},{a:4,b:5,c:1},{a:1,b:0,c:4},{a:5,b:6,c:2},{a:2,b:1,c:5},{a:6,b:7,c:3},{a:3,b:2,c:6},{a:7,b:4,c:0},{a:0,b:3,c:7}]),z(Z,te,oe)),$u={src:"\n        precision highp float;\n        \n        attribute highp vec2 quadShadowVertex;\n        \n        uniform highp vec4 modelScale;\n        uniform highp mat4 modelMatrix;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 projectionMatrix;\n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 shadowLight;\n        uniform highp mat4 quadVertexPositions;\n        \n        const lowp float kDirectionalLight = 1.0;\n        const lowp float kPointLight = 2.0;\n        \n        void getQuadVertex(int quadVertexIndex, mat4 quadVertexPositions, out vec3 position, out vec3 normal, out vec3 tangent) {\n            vec3 next = vec3(0.0, 0.0, 0.0);\n            vec3 prev = vec3(0.0, 0.0, 0.0);\n            if (quadVertexIndex == 0) {\n                prev = quadVertexPositions[3].xyz;\n                position = quadVertexPositions[0].xyz;\n                next = quadVertexPositions[1].xyz;\n                tangent = normalize(next - position);\n            } else if (quadVertexIndex == 1) {\n                prev = quadVertexPositions[0].xyz;\n                position = quadVertexPositions[1].xyz;\n                next = quadVertexPositions[2].xyz;\n                tangent = normalize(position - prev);\n            } else if (quadVertexIndex == 2) {\n                prev = quadVertexPositions[1].xyz;\n                position = quadVertexPositions[2].xyz;\n                next = quadVertexPositions[3].xyz;\n                tangent = normalize(position - next);\n            } else {\n                prev = quadVertexPositions[2].xyz;\n                position = quadVertexPositions[3].xyz;\n                next = quadVertexPositions[0].xyz;\n                tangent = normalize(prev - position);\n            }\n            normal = normalize(cross(next - position, prev - position));\n        }\n        \n        vec4 getWorldPosition(vec3 modelPosition, vec4 modelScale, mat4 modelMatrix) {\n            vec4 scaledPosition = vec4(modelScale.xyz * modelPosition, 1.0);\n            return modelMatrix * scaledPosition;\n        }\n        \n        vec3 safeNormalize(vec3 vector) {\n            if (vector == vec3(0.0, 0.0, 0.0)) {\n                return vector;\n            } else {\n                return normalize(vector);\n            }\n        }\n        \n        vec3 getWorldNormal(vec3 modelNormal, vec4 modelScale, mat4 modelMatrix) {\n            vec3 normalScale = vec3(modelScale.w / modelScale.x, modelScale.w / modelScale.y, modelScale.w / modelScale.z);\n            return (modelMatrix * vec4(safeNormalize(normalScale * modelNormal), 0.0)).xyz;\n        }\n        \n        vec3 getDirectionToLight(vec3 surfacePosition, vec4 xyz_type, vec4 rgb_parameter) {\n            float lightType = xyz_type.w;\n            if (lightType == kDirectionalLight) {\n                return xyz_type.xyz;\n            } else if (lightType == kPointLight) {\n                vec3 lightPosition = xyz_type.xyz;\n                return normalize(lightPosition - surfacePosition);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 shadowVertexPosition(vec3 position, vec3 normal, mat4 shadowLight, vec4 modelScale, mat4 modelMatrix, mat4 viewMatrix, mat4 projectionMatrix, mat4 sceneProperties) {\n            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);\n            vec3 worldNormal = getWorldNormal(normal, vec4(modelScale.xyz, 1.0), modelMatrix);\n            vec4 xyz_type = shadowLight[0];\n            vec4 rgb_parameter = shadowLight[1];\n            vec3 directionToLight = getDirectionToLight(worldPosition.xyz, xyz_type, rgb_parameter);\n            vec3 offset = vec3(0.0, 0.0, 0.0);\n            float sceneDiameter = sceneProperties[3][1];\n            if (dot(directionToLight, worldNormal) <= 0.0) {\n                offset = -sceneDiameter * directionToLight;\n            } else {\n                offset = -0.001 * sceneDiameter * directionToLight;\n            }\n            vec4 offsetPosition = worldPosition + vec4(offset, 0.0);\n            return projectionMatrix * (viewMatrix * offsetPosition);\n        }\n        \n        void main () {\n            vec3 position = vec3(0.0, 0.0, 0.0);\n            vec3 normal = vec3(0.0, 0.0, 0.0);\n            vec3 tangent = vec3(0.0, 0.0, 0.0);\n            getQuadVertex(int(quadShadowVertex.x), quadVertexPositions, position, normal, tangent);\n            normal *= quadShadowVertex.y;\n            gl_Position = shadowVertexPosition(\n                position,\n                normal,\n                shadowLight,\n                modelScale,\n                modelMatrix,\n                viewMatrix,\n                projectionMatrix,\n                sceneProperties\n            );\n        }\n    ",attributes:{quadShadowVertex:"aT"},uniforms:{modelMatrix:"d",modelScale:"e",projectionMatrix:"f",quadVertexPositions:"aA",sceneProperties:"g",shadowLight:"cD",viewMatrix:"h"}},Vu={src:"\n        precision lowp float;\n        \n        void main () {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    ",attributes:{},uniforms:{}},Su=$(_c,{c0:0,dn:0,dC:15},{bJ:7680,bZ:519,b5:7680,b6:7683},{bJ:7680,bZ:519,b5:7680,b6:7682}),_u=$(_c,{c0:0,dn:0,dC:15},{bJ:7680,bZ:519,b5:7680,b6:7682},{bJ:7680,bZ:519,b5:7680,b6:7683}),Au=s(function(e,n){return z(h,e?_u:Su,n)}),qu=u(function(l,u,f,s){return{$:2,a:t(function(e,n,r,t,o,a,i,c){return S(B,z(Au,t,c),$u,Vu,zu,{d:r,e:n,f:a,aA:V(iu,l,u,f,s),g:e,cD:i,h:o})})}}),Fu=E(function(e,n,r,t,o,a,i){r=S(Nu,r,t,o,a,i),e={a:e,b:n};return e.a?e.b?Ur(p([r,V(qu,t,o,a,i)])):r:e.b?V(qu,t,o,a,i):Il}),Bu=R(function(e,n,r,t,o){return G(Fu,!0,!1,e,n,r,t,o)}),Ru=s(function(e,n){return S(Bu,Kr(e),z(Ra,$(o,-.5,-.5,0),n),z(Ra,$(o,.5,-.5,0),n),z(Ra,$(o,.5,.5,0),n),z(Ra,$(o,-.5,.5,0),n))}),ku=s(function(e,n){return n.$?i(""):(n=f(n=wi($(Rl,e,Mi,(e=n.a).i)),{ac:n.ac-75,ad:n.ad-10}),z(a,p([z(q,"position","absolute"),z(q,"left",c(n.ac)),z(q,"top",c(n.ad)),z(q,"width",c(150)),z(q,"text-align","center"),z(q,"color","white"),z(q,"font-size","12px"),z(q,"font-weight","bold")]),p([i(e.aQ)])))}),Eu=function(e){switch(e.K.$){case 0:return e.I.b?"Walking":"Standing";case 1:return"Attacking";default:return"Fighting"}},Iu=s(function(e,n){return z(a,m,p([i(e+(" XP: "+vt(n)))]))}),ae=ie({fW:function(e){return{a:{bc:0,K:Ot,ax:0,a0:cr(0),bf:0,ai:10,O:m,aL:Kt,i:$(Jt,0,0,0),aj:10,S:z(xt,Xt,p([$(Jt,-3,3,0),$(Jt,-3,-3,0),$(Jt,3,3,0),$(Jt,3,-3,0)])),bT:-1,bt:0,I:m},b:eo}},gr:function(e){return oo(O(p([jo(z(Ft,ur,z(Do,"key",Wo))),Ho(z(Ft,fr,z(Do,"key",Wo))),Uo($(Bt,s(function(e,n){return{$:1,a:z(Oo,e,n)}}),z(Do,"clientX",No),z(Do,"clientY",No))),Ao(z(ao,vr,lr))]),2===e.K.$?p([z(wo,1e3,function(e){return to})]):m))},gx:me,gA:function(n){return z(a,m,p([z(a,p([z(q,"border","1px solid white"),z(q,"display","inline-block"),z(q,"position","relative"),z(q,"overflow","hidden"),z(q,"user-select","none")]),p([(e={fh:lc,fn:Xa(n),fs:1,fw:{a:gi(800),b:gi(600)},fF:O(Vr(z(xt,s(function(r,e){return z(xt,s(function(e,n){return z(Ru,n?nc:rc,$(Jt,e-oc,r-oc,-.01))}),e)}),tc)),z(h,z(Ru,function(e){switch(e.$){case 0:return ac;case 1:return ic;default:return cc}}(n.K),n.i),z(L,Jr,n.S)))},Cl({be:yl,fh:e.fh,fn:e.fn,fs:e.fs,fw:e.fw,fF:e.fF,aK:Tl(Ll(80)),aN:Ml,aU:wl,aX:Pl})),z(a,m,z(L,function(e){return e.$?i(""):(e=e.a,V(kl,Xa(n),e.ai,e.aj,e.i))},n.S)),function(e){var n=f(n=wi($(Rl,Xa(e),Mi,e.i)),{ac:n.ac-75,ad:n.ad-10});return z(a,p([z(q,"position","absolute"),z(q,"left",c(n.ac)),z(q,"top",c(n.ad)),z(q,"width",c(150)),z(q,"text-align","center"),z(q,"color","white"),z(q,"font-size","12px"),z(q,"font-weight","bold")]),p([i(Eu(e))]))}(n),V(kl,Xa(n),n.ai,n.aj,n.i),$(El,Xa(n),n.O,n.i),z(a,m,z(L,ku(Xa(n)),n.S)),z(a,m,z(L,function(e){return e.$?i(""):(e=e.a,$(El,Xa(n),e.O,e.i))},n.S))])),z(a,p([z(q,"margin-bottom","20px")]),p([function(e){return z(a,m,p([z(zl,p([Sl(Dl(0)),Nl(!e.ax)]),p([i("Accuracy")])),z(zl,p([Sl(Dl(1)),Nl(1===e.ax)]),p([i("Strength")])),z(zl,p([Sl(Dl(2)),Nl(2===e.ax)]),p([i("Defense")]))]))}(n),function(e){return z(a,m,p([z(Iu,"Accuracy",e.bc),z(Iu,"Strength",e.bt),z(Iu,"Defense",e.bf)]))}(n)])),z(a,m,p([i("Use left and right arrow keys to rotate the screen.")])),z(a,m,p([i("Click on the screen to move to that location.")])),z(a,m,p([i("Click on a monster to attack it.")]))]));var e}});le={Main:{init:ae(Rt(0))(0)}},e.Elm?function e(n,r){for(var t in r)t in n?"init"==t?ee(6):e(n[t],r[t]):n[t]=r[t]}(e.Elm,le):e.Elm=le}(this);