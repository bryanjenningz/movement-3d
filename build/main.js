!function(e){"use strict";function n(e,n,r){return r.a=e,r.f=n,r}function s(r){return n(2,r,function(n){return function(e){return r(n,e)}})}function b(t){return n(3,t,function(r){return function(n){return function(e){return t(r,n,e)}}})}function u(o){return n(4,o,function(t){return function(r){return function(n){return function(e){return o(t,r,n,e)}}}})}function l(a){return n(5,a,function(o){return function(t){return function(r){return function(n){return function(e){return a(o,t,r,n,e)}}}}})}function E(i){return n(6,i,function(a){return function(o){return function(t){return function(r){return function(n){return function(e){return i(a,o,t,r,n,e)}}}}}})}function R(c){return n(7,c,function(i){return function(a){return function(o){return function(t){return function(r){return function(n){return function(e){return c(i,a,o,t,r,n,e)}}}}}}})}function I(l){return n(8,l,function(c){return function(i){return function(a){return function(o){return function(t){return function(r){return function(n){return function(e){return l(c,i,a,o,t,r,n,e)}}}}}}}})}function z(e,n,r){return 2===e.a?e.f(n,r):e(n)(r)}function D(e,n,r,t){return 3===e.a?e.f(n,r,t):e(n)(r)(t)}function S(e,n,r,t,o){return 4===e.a?e.f(n,r,t,o):e(n)(r)(t)(o)}function V(e,n,r,t,o,a){return 5===e.a?e.f(n,r,t,o,a):e(n)(r)(t)(o)(a)}function H(e,n,r,t,o,a,i){return 6===e.a?e.f(n,r,t,o,a,i):e(n)(r)(t)(o)(a)(i)}function j(e,n,r,t,o,a,i,c){return 7===e.a?e.f(n,r,t,o,a,i,c):e(n)(r)(t)(o)(a)(i)(c)}function f(e,n){for(var r,t=[],o=O(e,n,0,t);o&&(r=t.pop());o=O(r.a,r.b,0,t));return o}function O(e,n,r,t){if(e!==n){if("object"!=typeof e||null===e||null===n)return"function"==typeof e&&re(5),!1;if(100<r)t.push({a:e,b:n});else for(var o in e.$<0&&(e=vt(e),n=vt(n)),e)if(!O(e[o],n[o],r+1,t))return!1}return!0}var Y=s(function(e,n){return!f(e,n)});function d(e,n,r){if("object"!=typeof e)return e===n?0:e<n?-1:1;if(void 0===e.$)return(r=(r=d(e.a,n.a))||d(e.b,n.b))||d(e.c,n.c);for(;e.b&&n.b&&!(r=d(e.a,n.a));e=e.b,n=n.b);return r||(e.b?1:n.b?-1:0)}var U=s(function(e,n){e=d(e,n);return e<0?bt:e?st:ft}),W=0;function v(e,n){var r,t={};for(r in e)t[r]=e[r];for(r in n)t[r]=n[r];return t}function G(e,n){if("string"==typeof e)return e+n;if(!e.b)return n;var r={$:1,a:e.a,b:n};e=e.b;for(var t=r;e.b;e=e.b)t=t.b={$:1,a:e.a,b:n};return r}var m={$:0};function X(e,n){return{$:1,a:e,b:n}}var J=s(X);function p(e){for(var n=m,r=e.length;r--;)n={$:1,a:e[r],b:n};return n}function Q(e){for(var n=[];e.b;e=e.b)n.push(e.a);return n}var K=b(function(e,n,r){for(var t=[];n.b&&r.b;n=n.b,r=r.b)t.push(z(e,n.a,r.a));return p(t)}),Z=s(function(r,e){return p(Q(e).sort(function(e,n){e=z(r,e,n);return e===ft?0:e===bt?-1:1}))});var ee=b(function(e,n,r){for(var t=Array(e),o=0;o<e;o++)t[o]=r(n+o);return t}),ne=s(function(e,n){for(var r=Array(e),t=0;t<e&&n.b;t++)r[t]=n.a,n=n.b;return r.length=t,{a:r,b:n}});function re(e){throw Error("https://github.com/elm/core/blob/1.0.0/hints/"+e+".md")}var te=s(function(e,n){return e+n}),oe=s(Math.pow),ae=Math.cos,ie=Math.sin,ce=Math.tan;var le=Math.ceil,ue=Math.floor,fe=Math.round,se=Math.sqrt,be=Math.log;var de=s(function(e,n){return n.join(e)});function ve(e){return e+""}var me={$:2,b:function(e){return"number"==typeof e?xt(e):Le("a FLOAT",e)}},pe={$:2,b:function(e){return"string"==typeof e?xt(e):e instanceof String?xt(e+""):Le("a STRING",e)}};var ge=s(function(e,n){return{$:6,d:e,b:n}});var he=s(function(e,n){return{$:9,f:e,g:[n]}}),xe=b(function(e,n,r){return{$:9,f:e,g:[n,r]}}),Ce=s(g);function g(e,n){switch(e.$){case 2:return e.b(n);case 5:return null===n?xt(e.c):Le("null",n);case 3:return ye(n)?Pe(e.b,n,p):Le("a LIST",n);case 4:return ye(n)?Pe(e.b,n,Te):Le("an ARRAY",n);case 6:var r=e.d;return"object"==typeof n&&null!==n&&r in n?(a=g(e.b,n[r]),L(a)?a:mt(z(gt,r,a.a))):Le("an OBJECT with a field named `"+r+"`",n);case 7:r=e.e;return ye(n)?r<n.length?(a=g(e.b,n[r]),L(a)?a:mt(z(ht,r,a.a))):Le("a LONGER array. Need index "+r+" but only see "+n.length+" entries",n):Le("an ARRAY",n);case 8:if("object"!=typeof n||null===n||ye(n))return Le("an OBJECT",n);var t,o=m;for(t in n)if(n.hasOwnProperty(t)){var a=g(e.b,n[t]);if(!L(a))return mt(z(gt,t,a.a));o={$:1,a:{a:t,b:a.a},b:o}}return xt($t(o));case 9:for(var i=e.f,c=e.g,l=0;l<c.length;l++){a=g(c[l],n);if(!L(a))return a;i=i(a.a)}return xt(i);case 10:a=g(e.b,n);return L(a)?g(e.h(a.a),n):a;case 11:for(var u=m,f=e.g;f.b;f=f.b){a=g(f.a,n);if(L(a))return a;u={$:1,a:a.a,b:u}}return mt(Ct($t(u)));case 1:return mt(z(pt,e.a,n));case 0:return xt(e.a)}}function Pe(e,n,r){for(var t=n.length,o=Array(t),a=0;a<t;a++){var i=g(e,n[a]);if(!L(i))return mt(z(ht,a,i.a));o[a]=i.a}return xt(r(o))}function ye(e){return Array.isArray(e)||"undefined"!=typeof FileList&&e instanceof FileList}function Te(n){return z(jt,n.length,function(e){return n[e]})}function Le(e,n){return mt(z(pt,"Expecting "+e,n))}function Me(e,n){if(e===n)return!0;if(e.$!==n.$)return!1;switch(e.$){case 0:case 1:return e.a===n.a;case 2:return e.b===n.b;case 5:return e.c===n.c;case 3:case 4:case 8:return Me(e.b,n.b);case 6:return e.d===n.d&&Me(e.b,n.b);case 7:return e.e===n.e&&Me(e.b,n.b);case 9:return e.f===n.f&&we(e.g,n.g);case 10:return e.h===n.h&&Me(e.b,n.b);case 11:return we(e.g,n.g)}}function we(e,n){var r=e.length;if(r!==n.length)return!1;for(var t=0;t<r;t++)if(!Me(e[t],n[t]))return!1;return!0}function Ne(e){return e}function $e(e){return{$:0,a:e}}var ze=s(function(e,n){return{$:3,b:e,d:n}});var De=0;function Se(e){e={$:0,e:De++,f:e,g:null,h:[]};return Be(e),e}function Ve(n){return{$:2,b:function(e){e({$:0,a:Se(n)})},c:null}}function Ae(e,n){e.h.push(n),Be(e)}var _e=s(function(n,r){return{$:2,b:function(e){Ae(n,r),e({$:0,a:W})},c:null}});var qe=!1,Fe=[];function Be(e){if(Fe.push(e),!qe){for(qe=!0;e=Fe.shift();)!function(n){for(;n.f;){var e=n.f.$;if(0===e||1===e){for(;n.g&&n.g.$!==e;)n.g=n.g.i;if(!n.g)return;n.f=n.g.b(n.f.a),n.g=n.g.i}else{if(2===e)return n.f.c=n.f.b(function(e){n.f=e,Be(n)});if(5===e){if(0===n.h.length)return;n.f=n.f.b(n.h.shift())}else n.g={$:3===e?0:1,b:n.f.b,i:n.g},n.f=n.f.d}}}(e);qe=!1}}function ke(e,n,r,t,o,a){var e=z(Ce,e,n?n.flags:void 0),i=(L(e)||re(2),{}),n=r(e.a),c=n.a,l=a(u,c),r=function(e,n){var r,t;for(t in Ee){var o=Ee[t];o.a&&((r=r||{})[t]=o.a(t,n)),e[t]=function(e,n){var t={g:n,h:void 0},o=e.c,a=e.d,i=e.e,c=e.f;function l(r){return z(ze,l,{$:5,b:function(e){var n=e.a;return 0===e.$?D(a,t,n,r):i&&c?S(o,t,n.i,n.j,r):D(o,t,i?n.i:n.j,r)}})}return t.h=Se(z(ze,l,e.b))}(o,n)}return r}(i,u);function u(e,n){e=z(t,e,c);l(c=e.a,n),Ue(i,e.b,o(c))}return Ue(i,n.b,o(c)),r?{ports:r}:{}}var Ee={};var Re=s(function(n,r){return{$:2,b:function(e){n.g(r),e({$:0,a:W})},c:null}}),Ie=s(function(e,n){return z(_e,e.h,{$:0,a:n})});function He(n){return function(e){return{$:1,k:n,l:e}}}function je(e){return{$:2,m:e}}var Oe=[],Ye=!1;function Ue(e,n,r){if(Oe.push({p:e,q:n,r:r}),!Ye){Ye=!0;for(var t;t=Oe.shift();)!function(e,n,r){var t,o={};for(t in We(!0,n,o,null),We(!1,r,o,null),e)Ae(e[t],{$:"fx",a:o[t]||{i:m,j:m}})}(t.p,t.q,t.r);Ye=!1}}function We(e,n,r,t){switch(n.$){case 1:var o=n.k,a=function(e,n,r,t){function o(e){for(var n=r;n;n=n.t)e=n.s(e);return e}return z(e?Ee[n].e:Ee[n].f,o,t)}(e,o,t,n.l);return void(r[o]=function(e,n,r){return r=r||{i:m,j:m},e?r.i={$:1,a:n,b:r.i}:r.j={$:1,a:n,b:r.j},r}(e,a,r[o]));case 2:for(var i=n.m;i.b;i=i.b)We(e,i.a,r,t);return;case 3:We(e,n.o,r,{s:n.n,t:t})}}var Ge;var Xe="undefined"!=typeof document?document:{};function Je(e){return{$:0,a:e}}var Qe=s(function(a,i){return s(function(e,n){for(var r=[],t=0;n.b;n=n.b){var o=n.a;t+=o.b||0,r.push(o)}return t+=r.length,{$:1,c:i,d:an(e),e:r,f:a,b:t}})})(void 0),Ke=s(function(a,i){return s(function(e,n){for(var r=[],t=0;n.b;n=n.b){var o=n.a;t+=o.b.b||0,r.push(o)}return t+=r.length,{$:2,c:i,d:an(e),e:r,f:a,b:t}})})(void 0);var Ze=s(function(e,n){return{$:"a0",n:e,o:n}}),en=s(function(e,n){return{$:"a1",n:e,o:n}}),nn=s(function(e,n){return{$:"a2",n:e,o:n}}),rn=s(function(e,n){return{$:"a3",n:e,o:n}}),tn=/^script$/i;var on;function an(e){for(var n={};e.b;e=e.b){var r,t=e.a,o=t.$,a=t.n,t=t.o;"a2"===o?"className"===a?cn(n,a,t):n[a]=t:(r=n[o]||(n[o]={}),"a3"===o&&"class"===a?cn(r,a,t):r[a]=t)}return n}function cn(e,n,r){var t=e[n];e[n]=t?t+" "+r:r}function ln(e,n){var r=e.$;if(5===r)return ln(e.k||(e.k=e.m()),n);if(0===r)return Xe.createTextNode(e.a);if(4===r){for(var t=e.k,o=e.j;4===t.$;)"object"!=typeof o?o=[o,t.j]:o.push(t.j),t=t.k;var a={j:o,p:n};(i=ln(t,a)).elm_event_node_ref=a}else if(3===r)un(i=e.h(e.g),n,e.d);else{var i=e.f?Xe.createElementNS(e.f,e.c):Xe.createElement(e.c);Ge&&"a"==e.c&&i.addEventListener("click",Ge(i)),un(i,n,e.d);for(var c=e.e,l=0;l<c.length;l++)i.appendChild(ln(1===r?c[l]:c[l].b,n))}return i}function un(e,n,r){for(var t in r){var o=r[t];"a1"===t?function(e,n){var r,t=e.style;for(r in n)t[r]=n[r]}(e,o):"a0"===t?function(e,n,r){var t,o=e.elmFs||(e.elmFs={});for(t in r){var a=r[t],i=o[t];if(a){if(i){if(i.q.$===a.$){i.q=a;continue}e.removeEventListener(t,i)}i=function(l,e){function u(e){var n=u.q,r=g(n.a,e);if(L(r)){for(var t,n=Wt(n),r=r.a,o=n?n<3?r.a:r.aJ:r,a=1==n?r.b:3==n&&r.dC,i=(a&&e.stopPropagation(),(2==n?r.b:3==n&&r.dr)&&e.preventDefault(),l);t=i.j;){if("function"==typeof t)o=t(o);else for(var c=t.length;c--;)o=t[c](o);i=i.p}i(o,a)}}return u.q=e,u}(n,a),e.addEventListener(t,i,on&&{passive:Wt(a)<2}),o[t]=i}else e.removeEventListener(t,i),o[t]=void 0}}(e,n,o):"a3"===t?function(e,n){for(var r in n){var t=n[r];void 0!==t?e.setAttribute(r,t):e.removeAttribute(r)}}(e,o):"a4"===t?function(e,n){for(var r in n){var t=n[r],o=t.f,t=t.o;void 0!==t?e.setAttributeNS(o,r,t):e.removeAttributeNS(o,r)}}(e,o):("value"!==t&&"checked"!==t||e[t]!==o)&&(e[t]=o)}}try{window.addEventListener("t",null,Object.defineProperty({},"passive",{get:function(){on=!0}}))}catch(e){}function fn(e,n){var r=[];return _(e,n,r,0),r}function A(e,n,r,t){n={$:n,r:r,s:t,t:void 0,u:void 0};return e.push(n),n}function _(e,n,r,t){if(e!==n){var o=e.$,a=n.$;if(o!==a){if(1!==o||2!==a)return void A(r,0,t,n);n=function(e){for(var n=e.e,r=n.length,t=Array(r),o=0;o<r;o++)t[o]=n[o].b;return{$:1,c:e.c,d:e.d,e:t,f:e.f,b:e.b}}(n),a=1}switch(a){case 5:for(var i=e.l,c=n.l,l=i.length,u=l===c.length;u&&l--;)u=i[l]===c[l];if(u)return void(n.k=e.k);n.k=n.m();var f=[];return _(e.k,n.k,f,0),void(0<f.length&&A(r,1,t,f));case 4:for(var s=e.j,b=n.j,d=!1,v=e.k;4===v.$;)d=!0,"object"!=typeof s?s=[s,v.j]:s.push(v.j),v=v.k;for(var m=n.k;4===m.$;)d=!0,"object"!=typeof b?b=[b,m.j]:b.push(m.j),m=m.k;return d&&s.length!==b.length?void A(r,0,t,n):((d?function(e,n){for(var r=0;r<e.length;r++)if(e[r]!==n[r])return;return 1}(s,b):s===b)||A(r,2,t,b),void _(v,m,r,t+1));case 0:return void(e.a!==n.a&&A(r,3,t,n.a));case 1:return void sn(e,n,r,t,dn);case 2:return void sn(e,n,r,t,vn);case 3:if(e.h!==n.h)return void A(r,0,t,n);f=bn(e.d,n.d),f=(f&&A(r,4,t,f),n.i(e.g,n.g));f&&A(r,5,t,f)}}}function sn(e,n,r,t,o){var a;e.c!==n.c||e.f!==n.f?A(r,0,t,n):((a=bn(e.d,n.d))&&A(r,4,t,a),o(e,n,r,t))}function bn(e,n,r){var t,o,a,i,c;for(o in e)"a1"===o||"a0"===o||"a3"===o||"a4"===o?(a=bn(e[o],n[o]||{},o))&&((t=t||{})[o]=a):o in n?(a=e[o])===(i=n[o])&&"value"!==o&&"checked"!==o||"a0"===r&&function(e,n){return e.$==n.$&&Me(e.a,n.a)}(a,i)||((t=t||{})[o]=i):(t=t||{})[o]=r?"a1"===r?"":"a0"===r||"a3"===r?void 0:{f:e[o].f,o:void 0}:"string"==typeof e[o]?"":null;for(c in n)c in e||((t=t||{})[c]=n[c]);return t}function dn(e,n,r,t){var o=e.e,a=n.e,e=o.length,n=a.length;n<e?A(r,6,t,{v:n,i:e-n}):e<n&&A(r,7,t,{v:e,e:a});for(var i=e<n?e:n,c=0;c<i;c++){var l=o[c];_(l,a[c],r,++t),t+=l.b||0}}function vn(e,n,r,t){for(var o=[],a={},i=[],c=e.e,l=n.e,u=c.length,f=l.length,s=0,b=0,d=t;s<u&&b<f;){var v=c[s],m=l[b],p=v.a,g=m.a,h=v.b,x=m.b,C=void 0,P=void 0;if(p===g)_(h,x,o,++d),d+=h.b||0,s++,b++;else{var y,T,L,M,w=c[s+1],N=l[b+1];if(w&&(T=w.b,P=g===(y=w.a)),N&&(M=N.b,C=p===(L=N.a)),C&&P)_(h,M,o,++d),pn(a,o,p,x,b,i),d+=h.b||0,gn(a,o,p,T,++d),d+=T.b||0,s+=2,b+=2;else if(C)d++,pn(a,o,g,x,b,i),_(h,M,o,d),d+=h.b||0,s+=1,b+=2;else if(P)gn(a,o,p,h,++d),d+=h.b||0,_(T,x,o,++d),d+=T.b||0,s+=2,b+=1;else{if(!w||y!==L)break;gn(a,o,p,h,++d),pn(a,o,g,x,b,i),d+=h.b||0,_(T,M,o,++d),d+=T.b||0,s+=2,b+=2}}}for(;s<u;){h=(v=c[s]).b;gn(a,o,v.a,h,++d),d+=h.b||0,s++}for(;b<f;){var $=$||[];pn(a,o,(m=l[b]).a,m.b,void 0,$),b++}(0<o.length||0<i.length||$)&&A(r,8,t,{w:o,x:i,y:$})}var mn="_elmW6BL";function pn(e,n,r,t,o,a){var i,c=e[r];c?1===c.c?(a.push({r:o,A:c}),c.c=2,_(c.z,t,i=[],c.r),c.r=o,c.s.s={w:i,A:c}):pn(e,n,r+mn,t,o,a):(a.push({r:o,A:c={c:0,z:t,r:o,s:void 0}}),e[r]=c)}function gn(e,n,r,t,o){var a,i=e[r];i?0===i.c?(i.c=2,_(t,i.z,a=[],o),A(n,9,o,{w:a,A:i})):gn(e,n,r+mn,t,o):(a=A(n,9,o,void 0),e[r]={c:1,z:t,r:o,s:a})}function hn(e,n,r,t){!function e(n,r,t,o,a,i,c){var l=t[o];var u=l.r;for(;u===a;){var f,s=l.$;if(1===s?hn(n,r.k,l.s,c):8===s?(l.t=n,l.u=c,0<(f=l.s.w).length&&e(n,r,f,0,a,i,c)):9===s?(l.t=n,l.u=c,(s=l.s)&&(s.A.s=n,0<(f=s.w).length)&&e(n,r,f,0,a,i,c)):(l.t=n,l.u=c),!(l=t[++o])||(u=l.r)>i)return o}var b=r.$;if(4===b){for(var d=r.k;4===d.$;)d=d.k;return e(n,d,t,o,a+1,i,n.elm_event_node_ref)}var v=r.e;var m=n.childNodes;for(var p=0;p<v.length;p++){var g=1===b?v[p]:v[p].b,h=++a+(g.b||0);if(a<=u&&u<=h&&(o=e(m[p],g,t,o,a,h,c),!(l=t[o])||(u=l.r)>i))return o;a=h}return o}(e,n,r,0,0,n.b,t)}function xn(e,n,r,t){return 0===r.length?e:(hn(e,n,r,t),Cn(e,r))}function Cn(e,n){for(var r=0;r<n.length;r++){var t=n[r],o=t.t,t=function(e,n){switch(n.$){case 0:return function(e,n,r){var t=e.parentNode,n=ln(n,r);n.elm_event_node_ref||(n.elm_event_node_ref=e.elm_event_node_ref);t&&n!==e&&t.replaceChild(n,e);return n}(e,n.s,n.u);case 4:return un(e,n.u,n.s),e;case 3:return e.replaceData(0,e.length,n.s),e;case 1:return Cn(e,n.s);case 2:return e.elm_event_node_ref?e.elm_event_node_ref.j=n.s:e.elm_event_node_ref={j:n.s,p:n.u},e;case 6:for(var r=n.s,t=0;t<r.i;t++)e.removeChild(e.childNodes[r.v]);return e;case 7:for(var o=(r=n.s).e,t=r.v,a=e.childNodes[t];t<o.length;t++)e.insertBefore(ln(o[t],n.u),a);return e;case 9:var i;return(r=n.s)?(void 0!==(i=r.A).r&&e.parentNode.removeChild(e),i.s=Cn(e,r.w)):e.parentNode.removeChild(e),e;case 8:return function(e,n){for(var r=n.s,t=function(e,n){if(e){for(var r=Xe.createDocumentFragment(),t=0;t<e.length;t++){var o=e[t].A;r.appendChild(2===o.c?o.s:ln(o.z,n.u))}return r}}(r.y,n),o=(e=Cn(e,r.w),r.x),a=0;a<o.length;a++){var i=o[a],c=i.A,c=2===c.c?c.s:ln(c.z,n.u);e.insertBefore(c,e.childNodes[i.r])}t&&e.appendChild(t);return e}(e,n);case 5:return n.s(e);default:re(10)}}(o,t);o===e&&(e=t)}return e}function Pn(e){if(3===e.nodeType)return{$:0,a:e.textContent};if(1!==e.nodeType)return{$:0,a:""};for(var n=m,r=e.attributes,t=r.length;t--;)var o=r[t],n={$:1,a:z(rn,o.name,o.value),b:n};for(var a=e.tagName.toLowerCase(),i=m,c=e.childNodes,t=c.length;t--;)i={$:1,a:Pn(c[t]),b:i};return D(Qe,a,n,i)}var yn=u(function(n,e,r,i){return ke(e,i,n.f2,n.gF,n.gz,function(r,e){var t=n.gI,o=i.node,a=Pn(o);return Mn(e,function(e){var e=t(e),n=fn(a,e);o=xn(o,a,n,r),a=e})})}),Tn="undefined"!=typeof cancelAnimationFrame?cancelAnimationFrame:function(e){clearTimeout(e)},Ln="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:function(e){return setTimeout(e,1e3/60)};function Mn(r,t){t(r);var o=0;function a(){o=1===o?0:(Ln(a),t(r),1)}return function(e,n){r=e,n?(t(r),2===o&&(o=1)):(0===o&&Ln(a),o=2)}}var wn={addEventListener:function(){},removeEventListener:function(){}},Nn="undefined"!=typeof document?document:wn,$n="undefined"!=typeof window?window:wn,zn=b(function(r,t,o){return Ve({$:2,b:function(e){function n(e){Se(o(e))}return r.addEventListener(t,n,on&&{passive:!0}),function(){r.removeEventListener(t,n)}},c:null})}),Dn=s(function(e,n){e=g(e,n);return L(e)?C(e.a):P});wn=s(function(r,t){return{$:2,b:function(e){var n=setInterval(function(){Se(t)},r);return function(){clearInterval(n)}},c:null}});var Sn=s(function(e,n){return new Float64Array([e,n])});new Float64Array(3),new Float64Array(3),new Float64Array(3);var Vn=b(function(e,n,r){return new Float64Array([e,n,r])});var An=s(function(e,n){return new Float64Array([n[0]*e,n[1]*e,n[2]*e])});var _n=u(function(e,n,r,t){return new Float64Array([e,n,r,t])});new Float64Array(16),new Float64Array(16),new Float64Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);var qn=0;function Fn(e,n){for(;n.b;n=n.b)e(n.a)}function Bn(e){for(var n=0;e.b;e=e.b)n++;return n}function kn(e){e.scissor.enabled&&(e.gl.disable(e.gl.SCISSOR_TEST),e.scissor.enabled=!1)}function En(e){var n=e.colorMask;n.a&&n.b&&n.c&&n.d||(e.gl.colorMask(!0,!0,!0,!0),n.a=!0,n.b=!0,n.c=!0,n.d=!0)}var Rn="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:function(e){setTimeout(e,1e3/60)},In=l(function(e,n,r,t,o){return{$:0,a:e,b:n,c:r,d:t,e:o}}),Hn=s(function(e,n){var r=e.blend;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.BLEND),r.enabled=!0),r.a===n.a&&r.d===n.d||(e.gl.blendEquationSeparate(n.a,n.d),r.a=n.a,r.d=n.d),r.b===n.b&&r.c===n.c&&r.e===n.e&&r.f===n.f||(e.gl.blendFuncSeparate(n.b,n.c,n.e,n.f),r.b=n.b,r.c=n.c,r.e=n.e,r.f=n.f),r.g===n.g&&r.h===n.h&&r.i===n.i&&r.j===n.j||(e.gl.blendColor(n.g,n.h,n.i,n.j),r.g=n.g,r.h=n.h,r.i=n.i,r.j=n.j)}),jn=s(function(e,n){var r=e.depthTest;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.DEPTH_TEST),r.enabled=!0),r.a!==n.a&&(e.gl.depthFunc(n.a),r.a=n.a),r.b!==n.b&&(e.gl.depthMask(n.b),r.b=n.b),r.c===n.c&&r.d===n.d||(e.gl.depthRange(n.c,n.d),r.c=n.c,r.d=n.d)}),On=s(function(e,n){var r=e.stencilTest;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.STENCIL_TEST),r.enabled=!0),r.d===n.d&&r.a===n.a&&r.b===n.b||(e.gl.stencilFuncSeparate(e.gl.FRONT,n.d,n.a,n.b),r.d=n.d),r.e===n.e&&r.f===n.f&&r.g===n.g||(e.gl.stencilOpSeparate(e.gl.FRONT,n.e,n.f,n.g),r.e=n.e,r.f=n.f,r.g=n.g),r.c!==n.c&&(e.gl.stencilMask(n.c),r.c=n.c),r.h===n.h&&r.a===n.a&&r.b===n.b||(e.gl.stencilFuncSeparate(e.gl.BACK,n.h,n.a,n.b),r.h=n.h,r.a=n.a,r.b=n.b),r.i===n.i&&r.j===n.j&&r.k===n.k||(e.gl.stencilOpSeparate(e.gl.BACK,n.i,n.j,n.k),r.i=n.i,r.j=n.j,r.k=n.k)}),Yn=s(function(e,n){var r=e.scissor;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.SCISSOR_TEST),r.enabled=!0),r.a===n.a&&r.b===n.b&&r.c===n.c&&r.d===n.d||(e.gl.scissor(n.a,n.b,n.c,n.d),r.a=n.a,r.b=n.b,r.c=n.c,r.d=n.d)}),Un=s(function(e,n){var r=e.colorMask;r.toggle=e.toggle,r.enabled=!0,r.a===n.a&&r.b===n.b&&r.c===n.c&&r.d===n.d||(e.gl.colorMask(n.a,n.b,n.c,n.d),r.a=n.a,r.b=n.b,r.c=n.c,r.d=n.d)}),Wn=s(function(e,n){var r=e.cullFace;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.CULL_FACE),r.enabled=!0),r.a!==n.a&&(e.gl.cullFace(n.a),r.a=n.a)}),Gn=s(function(e,n){var r=e.polygonOffset;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.POLYGON_OFFSET_FILL),r.enabled=!0),r.a===n.a&&r.b===n.b||(e.gl.polygonOffset(n.a,n.b),r.a=n.a,r.b=n.b)}),Xn=s(function(e,n){var r=e.sampleCoverage;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.SAMPLE_COVERAGE),r.enabled=!0),r.a===n.a&&r.b===n.b||(e.gl.sampleCoverage(n.a,n.b),r.a=n.a,r.b=n.b)}),Jn=["blend","depthTest","stencilTest","scissor","colorMask","cullFace","polygonOffset","sampleCoverage","sampleAlphaToCoverage"],Qn=[function(e){e.blend.enabled&&(e.gl.disable(e.gl.BLEND),e.blend.enabled=!1)},function(e){e.depthTest.enabled&&(e.gl.disable(e.gl.DEPTH_TEST),e.depthTest.enabled=!1)},function(e){e.stencilTest.enabled&&(e.gl.disable(e.gl.STENCIL_TEST),e.stencilTest.enabled=!1)},kn,En,function(e){e.gl.disable(e.gl.CULL_FACE)},function(e){e.gl.disable(e.gl.POLYGON_OFFSET_FILL)},function(e){e.gl.disable(e.gl.SAMPLE_COVERAGE)},function(e){e.gl.disable(e.gl.SAMPLE_ALPHA_TO_COVERAGE)}];function Kn(e,n,r){r=e.createShader(r);return e.shaderSource(r,"#extension GL_OES_standard_derivatives : enable\n"+n),e.compileShader(r),r}function Zn(e,n){switch(n){case e.FLOAT:return{size:1,arraySize:1,type:Float32Array,baseType:e.FLOAT};case e.FLOAT_VEC2:return{size:2,arraySize:1,type:Float32Array,baseType:e.FLOAT};case e.FLOAT_VEC3:return{size:3,arraySize:1,type:Float32Array,baseType:e.FLOAT};case e.FLOAT_VEC4:return{size:4,arraySize:1,type:Float32Array,baseType:e.FLOAT};case e.FLOAT_MAT4:return{size:4,arraySize:4,type:Float32Array,baseType:e.FLOAT};case e.INT:return{size:1,arraySize:1,type:Int32Array,baseType:e.INT}}}function er(e,n,r,t){for(var c=r.a.d_,l=[],o=0;o<c;o++)l.push(String.fromCharCode(97+o));var a=Zn(e,n.type);if(void 0===a)throw Error("No info available for: "+n.type);var i=0,u=a.size*a.arraySize*c,f=new a.type(Bn(r.b)*u),r=(Fn(function(e){!function(n,r,t,o,a){var i;if(1===c)for(i=0;i<r;i++)n[t++]=1===r?o[a]:o[a][i];else l.forEach(function(e){for(i=0;i<r;i++)n[t++]=1===r?o[e][a]:o[e][a][i]})}(f,a.size*a.arraySize,i,e,t[n.name]||n.name),i+=u},r.b),e.createBuffer());return e.bindBuffer(e.ARRAY_BUFFER,r),e.bufferData(e.ARRAY_BUFFER,f,e.STATIC_DRAW),r}function nr(e,n){var r,t;return 0<n.a.d9?(r=e.createBuffer(),t=function(e,n){var r,t=new Uint32Array(Bn(e)*n),o=0;return Fn(function(e){if(1===n)t[o++]=e;else for(r=0;r<n;r++)t[o++]=e[String.fromCharCode(97+r)]},e),t}(n.c,n.a.d9),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,r),e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW),{numIndices:t.length,indexBuffer:r,buffers:{}}):{numIndices:n.a.d_*Bn(n.b),indexBuffer:null,buffers:{}}}var rr=s(function(h,e){var x=h.f,C=x.gl;return C&&(C.viewport(0,0,C.drawingBufferWidth,C.drawingBufferHeight),x.depthTest.b||(C.depthMask(!0),x.depthTest.b=!0),x.stencilTest.c!==x.STENCIL_WRITEMASK&&(C.stencilMask(x.STENCIL_WRITEMASK),x.stencilTest.c=x.STENCIL_WRITEMASK),kn(x),En(x),C.clear(C.COLOR_BUFFER_BIT|C.DEPTH_BUFFER_BIT|C.STENCIL_BUFFER_BIT),Fn(function(e){if(e.d.b.b){var n,r,t;if(!(i=e.b.id&&e.c.id?x.programs[n=e.b.id+"#"+e.c.id]:i)){e.b.id?o=x.shaders[e.b.id]:e.b.id=qn++,o||(o=Kn(C,e.b.src,C.VERTEX_SHADER),x.shaders[e.b.id]=o),e.c.id?a=x.shaders[e.c.id]:e.c.id=qn++,a||(a=Kn(C,e.c.src,C.FRAGMENT_SHADER),x.shaders[e.c.id]=a);for(var o,a,i,c=function(e,n,r){var t=e.createProgram();if(e.attachShader(t,n),e.attachShader(t,r),e.linkProgram(t),e.getProgramParameter(t,e.LINK_STATUS))return t;throw"Link failed: "+e.getProgramInfoLog(t)+"\nvs info-log: "+e.getShaderInfoLog(n)+"\nfs info-log: "+e.getShaderInfoLog(r)}(C,o,a),l=((i={glProgram:c,attributes:Object.assign({},e.b.attributes,e.c.attributes),currentUniforms:{},activeAttributes:[],activeAttributeLocations:[]}).uniformSetters=function(a,e,n,r){var t=n.glProgram,i=n.currentUniforms,c=0,l=e.f;for(var o={},u=a.getProgramParameter(t,a.ACTIVE_UNIFORMS),f=0;f<u;f++){var s=a.getActiveUniform(t,f);o[r[s.name]||s.name]=function(e,n){var r=n.name,t=a.getUniformLocation(e,r);switch(n.type){case a.INT:return function(e){i[r]!==e&&(a.uniform1i(t,e),i[r]=e)};case a.FLOAT:return function(e){i[r]!==e&&(a.uniform1f(t,e),i[r]=e)};case a.FLOAT_VEC2:return function(e){i[r]!==e&&(a.uniform2f(t,e[0],e[1]),i[r]=e)};case a.FLOAT_VEC3:return function(e){i[r]!==e&&(a.uniform3f(t,e[0],e[1],e[2]),i[r]=e)};case a.FLOAT_VEC4:return function(e){i[r]!==e&&(a.uniform4f(t,e[0],e[1],e[2],e[3]),i[r]=e)};case a.FLOAT_MAT4:return function(e){i[r]!==e&&(a.uniformMatrix4fv(t,!1,new Float32Array(e)),i[r]=e)};case a.SAMPLER_2D:var o=c++;return function(e){a.activeTexture(a.TEXTURE0+o);var n=l.textures.get(e);n||(n=e.fB(a),l.textures.set(e,n)),a.bindTexture(a.TEXTURE_2D,n),i[r]!==e&&(a.uniform1i(t,o),i[r]=e)};case a.BOOL:return function(e){i[r]!==e&&(a.uniform1i(t,e),i[r]=e)};default:return function(){}}}(t,s)}return o}(C,h,i,Object.assign({},e.b.uniforms,e.c.uniforms)),C.getProgramParameter(c,C.ACTIVE_ATTRIBUTES)),u=0;u<l;u++){var f=C.getActiveAttrib(c,u),s=C.getAttribLocation(c,f.name);i.activeAttributes.push(f),i.activeAttributeLocations.push(s)}x.programs[n=e.b.id+"#"+e.c.id]=i}x.lastProgId!==n&&(C.useProgram(i.glProgram),x.lastProgId=n),r=i.uniformSetters,Object.keys(t=e.e).forEach(function(e){var n=r[e];n&&n(t[e])});var b=x.buffers.get(e.d);for(b||(b=nr(C,e.d),x.buffers.set(e.d,b)),u=0;u<i.activeAttributes.length;u++){s=i.activeAttributeLocations[u],void 0===b.buffers[(f=i.activeAttributes[u]).name]&&(b.buffers[f.name]=er(C,f,e.d,i.attributes)),C.bindBuffer(C.ARRAY_BUFFER,b.buffers[f.name]);var d=Zn(C,f.type);if(1===d.arraySize)C.enableVertexAttribArray(s),C.vertexAttribPointer(s,d.size,d.baseType,!1,0,0);else for(var v=4*d.size,m=v*d.arraySize,p=0;p<d.arraySize;p++)C.enableVertexAttribArray(s+p),C.vertexAttribPointer(s+p,d.size,d.baseType,!1,m,v*p)}for(x.toggle=!x.toggle,Fn(Ic(x),e.a),u=0;u<9;u++){var g=x[Jn[u]];g.toggle!==x.toggle&&g.enabled&&(Qn[u](x),g.enabled=!1,g.toggle=x.toggle)}b.indexBuffer?(C.bindBuffer(C.ELEMENT_ARRAY_BUFFER,b.indexBuffer),C.drawElements(e.d.a.eJ,b.numIndices,C.UNSIGNED_INT,0)):C.drawArrays(e.d.a.eJ,0,b.numIndices)}},h.g)),e});var tr=b(function(e,n,r){return function(e,n,r,t){return{$:3,d:an(e),g:n,h:r,i:t}}(n,{g:r,f:{},h:e},or,ar)});function or(e){var n={contextAttributes:{alpha:!1,depth:!1,stencil:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1},sceneSettings:[]},r=(Fn(function(e){},e.h),Xe.createElement("canvas")),t=r.getContext&&(r.getContext("webgl",n.contextAttributes)||r.getContext("experimental-webgl",n.contextAttributes));return t&&void 0!==WeakMap?(n.sceneSettings.forEach(function(e){e(t)}),t.getExtension("OES_standard_derivatives"),t.getExtension("OES_element_index_uint"),e.f.gl=t,e.f.toggle=!1,e.f.blend={enabled:!1,toggle:!1},e.f.depthTest={enabled:!1,toggle:!1},e.f.stencilTest={enabled:!1,toggle:!1},e.f.scissor={enabled:!1,toggle:!1},e.f.colorMask={enabled:!1,toggle:!1},e.f.cullFace={enabled:!1,toggle:!1},e.f.polygonOffset={enabled:!1,toggle:!1},e.f.sampleCoverage={enabled:!1,toggle:!1},e.f.sampleAlphaToCoverage={enabled:!1,toggle:!1},e.f.shaders=[],e.f.programs={},e.f.lastProgId=null,e.f.buffers=new WeakMap,e.f.textures=new WeakMap,e.f.STENCIL_WRITEMASK=t.getParameter(t.STENCIL_WRITEMASK),Rn(function(){return z(rr,e,r)})):(r=Xe.createElement("div")).innerHTML='<a href="https://get.webgl.org/">Enable WebGL</a> to see this content!',r}function ar(e,n){return n.f=e.f,rr(n)}function ir(e){return D(y,s(function(e,n){return n+1}),0,e)}function cr(e){return e}function lr(e){return e}function ur(e){return D(Xt,Qt(x),M(m),e)}function fr(e){return fo(2*uo*e)}function sr(e){return{$:0,a:e}}function br(e){return{$:2,a:e}}function dr(e){return{$:3,a:e}}function vr(e){return{a:G(e.a?"w_":"d_",e.b),b:e}}function mr(e){return D(y,s(function(e,n){return D(Po,e.a,e.b,n)}),ro,e)}function pr(e){return e}function gr(e){return{$:8,a:e}}function hr(e){return e.b?C(e.a):P}function h(e){return e}function xr(e){return e}function Cr(e){return!e.$}function Pr(e){return e}function yr(e){var n,r=z(T,F(e.b4),z(T,F(e.b6),F(e.b8)));return r?ta((n=e.b4/r)*n+(n=e.b6/r)*n+(n=e.b8/r)*n)*r:oa}function Tr(e){return fo(uo*(e/180))}function Lr(e){return e.dh}function Mr(e){return e.dN}function wr(e){return e.fF}function Nr(e){return function(e){return e}(e.fn)}function $r(e){return e.fE}function zr(e){return Lr(e)}function Dr(e){return{b4:-e.b4,b6:-e.b6,b8:-e.b8}}function Sr(e){return Dr(Mr(e))}function Vr(e){return D(Xt,Ui,m,e)}function Ar(e){return D(y,Xi,to,e)}function _r(e){var n,r,t;return e.$?(r=(n=e.a).a,z(Wi,function(e){return p([{a:{a:r-1,b:e},b:{a:r,b:e-1}},{a:{a:r-1,b:e},b:{a:r,b:e}},{a:{a:r-1,b:e},b:{a:r,b:e+1}},{a:{a:r,b:e},b:{a:r-1,b:e-1}},{a:{a:r,b:e},b:{a:r-1,b:e}},{a:{a:r,b:e},b:{a:r-1,b:e+1}}])},z(wt,(t=n.b)-e.b+1,t))):(r=(n=e.a).a,t=n.b,z(Wi,function(e){return p([{a:{a:e,b:t},b:{a:e-1,b:t+1}},{a:{a:e,b:t},b:{a:e,b:t+1}},{a:{a:e,b:t},b:{a:e+1,b:t+1}},{a:{a:e,b:t+1},b:{a:e-1,b:t}},{a:{a:e,b:t+1},b:{a:e,b:t}},{a:{a:e,b:t+1},b:{a:e+1,b:t}}])},z(wt,r,r+e.b-1)))}function qr(e){return e}function Fr(e){var n=e.b;return z(rc,1664525*e.a+n>>>0,n)}function Br(e){return((e=277803737*((e=e.a)^e>>>4+(e>>>28)))>>>22^e)>>>0}function kr(e){return D($,e.a,e.b,0)}function Er(e){var n,r,t,o,a,i,c,l;return-1===e.$&&-1===e.d.$&&-1===e.e.$?-1!==e.e.d.$||e.e.d.a?(t=(l=e.e).b,o=l.c,a=l.d,l=l.e,V(q,1,e.b,e.c,V(q,0,(n=e.d).b,n.c,n.d,n.e),V(q,0,t,o,a,l))):(t=(r=e.e).b,o=r.c,i=(a=r.d).d,c=a.e,l=r.e,V(q,0,a.b,a.c,V(q,1,e.b,e.c,V(q,0,(n=e.d).b,n.c,n.d,n.e),i),V(q,1,t,o,c,l))):e}function Rr(e){var n,r,t,o,a,i,c,l,u;return-1===e.$&&-1===e.d.$&&-1===e.e.$?-1!==e.d.d.$||e.d.d.a?(i=(u=e.e).b,c=u.c,l=u.d,u=u.e,V(q,1,n=e.b,r=e.c,V(q,0,(o=e.d).b,o.c,o.d,o=o.e),V(q,0,i,c,l,u))):(n=e.b,r=e.c,o=(t=e.d).e,i=(a=e.e).b,c=a.c,l=a.d,u=a.e,V(q,0,t.b,t.c,V(q,1,(a=t.d).b,a.c,a.d,a.e),V(q,1,n,r,o,V(q,0,i,c,l,u)))):e}function Ir(e){var n,r,t,o,a,i;return-1===e.$&&-1===e.d.$?(n=e.a,r=e.b,t=e.c,i=(o=e.d).d,a=e.e,1===o.a?-1!==i.$||i.a?-1===(i=Er(e)).$?(e=i.e,V(xo,i.a,i.b,i.c,Ir(i.d),e)):no:V(q,n,r,t,Ir(o),a):V(q,n,r,t,Ir(o),a)):no}function Hr(e){return z(Dc,0,zc(Vc(e)))}function jr(e){return{$:4,a:z(qc,e,m)}}function Or(e){return e}function Yr(e){return{$:5,a:e}}function Ur(e){return{a:z(Bi,$l(e),Ml(e)),b:z(Bi,zl(e),wl(e)),c:z(Bi,Dl(e),Nl(e))}}function Wr(e){return e}function Gr(e){var n=(t=Ur(e)).a,r=t.b,t=t.c;return{fx:Wr(function(e){return D(Ll,Pl(e),yl(e),Tl(e))}(e)),fX:n/2,fY:r/2,fZ:t/2}}function Xr(f){return function(u){return function(l){return function(c){return function(i){return function(a){return function(o){return function(t){return function(r){return function(n){return function(e){return{$:2,a:f,b:u,c:l,d:c,e:i,f:a,g:o,h:t,i:r,j:n,k:e}}}}}}}}}}}}function Jr(e){return Ke(function(e){return tn.test(e)?"p":e}(e))}function Qr(e){function n(e){return B(1e4*e)/100}var r=e.b,t=e.c,o=e.d;return e=p(["rgba(",nu(n(e.a)),"%,",nu(n(r)),"%,",nu(n(t)),"%,",nu(B(1e3*o)/1e3),")"]),z(Tt,"",e)}function Kr(e){return e}function Zr(e){return D(Fl,{c7:e.c7,du:e.du,dK:e.dK},{bI:e.bI,bY:e.bY,b9:e.b9,ca:e.ca},{bI:e.bI,bY:e.bY,b9:e.b9,ca:e.ca})}function et(e){return V(Hc,p([Zr(e),S(su,!1,!1,!1,!1)]),pu,vu,mu,{})}function nt(e){return et({bI:7680,c7:15,du:8,bY:516,dK:z(hu,2,e+4),b9:5386,ca:5386})}function rt(e){return e}function tt(e){return e}function ot(e){return S(bu,515,e.aq,e.al,e.ak)}function at(n){var e=function(e){return e.gJ}(n.fv),r=Xa({dh:zr(e),dL:function(e){return Ja(e)}(e),dM:function(e){return Qa(e)}(e),dN:Dr(Sr(e))}),t=jr(n.fN);if(1===(r=S(Au,r,1,P,p([t]))).$)return m;var r=r.a,o=z(Ou,ju,e),a=z(pi,.99,z(Nu,ui(n.fA),Ra(Nl(r)))),i=Ur(r),i=yr(D($i,i.a,i.b,i.c)),r=z(pi,1.01,z(Du,i,Ra(Dl(r)))),e=(a=Hu(r=z(Eu,n.fv,{fm:n.fm,fU:r,gd:a})).eA)?tt(Dr(Sr(e))):h(zr(e)),c=(l=function(){var e=n.aO;switch(e.$){case 0:return{a:0,b:0};case 1:return{a:1,b:0};case 2:return{a:2,b:0};case 3:return{a:3,b:e.a};case 4:return{a:4,b:e.a};default:return{a:5,b:0}}}()).a,l=l.b,u=z(cu,n.aE,n.aR),i=Zc({el:0,em:e.b4,en:ol(u),eo:n.e9,ep:0,eq:e.b6,er:al(u),es:Pr(i),et:0,eu:e.b8,ev:il(u),ew:c,ex:0,ey:a,ez:0,eA:l}),f=H(fu,i,o,r,_u,t,{Y:m,ah:m,aj:m}),s=n.aH;switch(s.$){case 0:var b=s.a;return Vr(p([D(ou,f.Y,{a:b,b:tu},Tu),D(ou,f.ah,Fu,Tu)]));case 1:b=s.a;return Vr(p([D(ou,f.Y,Fu,Tu),p([qu]),D(ou,f.aj,b.bO,du),p([nt(0)]),D(ou,f.Y,{a:b,b:tu},Bu),D(ou,f.ah,Fu,Tu)]));default:var b=s.a,d=s.b;return Vr(p([D(ou,f.Y,{a:d,b:tu},Tu),p([qu]),z(Cu,f.aj,b),D(Iu,f.Y,d,ir(b)),D(ou,f.ah,Fu,Tu)]))}}function it(e){return e.$?"Bronze dagger":"Coins ("+yt(e.a)+")"}function o(e){return nu(e)+"px"}function ct(e){return z(pf,"click",Ut(e))}function lt(e){return z(c,p([$c("item-box")]),1===e.$?m:p([t(it(e.a))]))}var ut,ft=1,st=2,bt=0,x=J,dt=b(function(e,n,r){for(;;){if(-2===r.$)return n;var t=r.d,o=e,a=D(e,r.b,r.c,D(dt,e,n,r.e));e=o,n=a,r=t}}),vt=function(e){return D(dt,b(function(e,n,r){return z(x,{a:e,b:n},r)}),m,e)},mt=function(e){return{$:1,a:e}},pt=s(function(e,n){return{$:3,a:e,b:n}}),gt=s(function(e,n){return{$:0,a:e,b:n}}),ht=s(function(e,n){return{$:1,a:e,b:n}}),xt=function(e){return{$:0,a:e}},Ct=function(e){return{$:2,a:e}},Pt=te,C=function(e){return{$:0,a:e}},P={$:1},yt=ve,Tt=s(function(e,n){return z(de,e,Q(n))}),y=b(function(e,n,r){for(;;){if(!r.b)return n;var t=r.b,o=e,a=z(e,r.a,n);e=o,n=a,r=t}}),Lt=K,Mt=b(function(e,n,r){for(;;){if(1<=d(e,n))return r;var t=e,o=n-1,a=z(x,n,r);e=t,n=o,r=a}}),wt=s(function(e,n){return D(Mt,e,n,m)}),Nt=s(function(e,n){return D(Lt,e,z(wt,0,ir(n)-1),n)}),$t=function(e){return D(y,x,m,e)},zt=u(function(e,n,r,t){return{$:0,a:e,b:n,c:r,d:t}}),Dt=[],St=le,Vt=s(function(e,n){return be(n)/be(e)}),At=St(z(Vt,2,32)),_t=S(zt,0,At,Dt,Dt),qt=ee,Ft=ue,Bt=function(e){return e.length},T=s(function(e,n){return 0<d(e,n)?e:n}),kt=ne,Et=s(function(e,n){for(;;){var r=z(kt,32,e),t=r.b,r=z(x,{$:0,a:r.a},n);if(!t.b)return $t(r);e=t,n=r}}),Rt=s(function(e,n){for(;;){var r=St(n/32);if(1===r)return z(kt,32,e).a;e=z(Et,e,m),n=r}}),It=s(function(e,n){var r,t;return n.r?(t=Ft(z(Vt,32,(r=32*n.r)-1)),e=e?$t(n.F):n.F,e=z(Rt,e,n.r),S(zt,Bt(n.v)+r,z(T,5,t*At),e,n.v)):S(zt,Bt(n.v),At,Dt,n.v)}),Ht=l(function(e,n,r,t,o){for(;;){if(n<0)return z(It,!1,{F:t,r:r/32|0,v:o});var a={$:1,a:D(qt,32,n,e)};e=e,n=n-32,r=r,t=z(x,a,t),o=o}}),jt=s(function(e,n){var r;return 0<e?V(Ht,n,e-(r=e%32)-32,e,m,D(qt,r,e-r,n)):_t}),L=function(e){return!e.$},Ot=he,Yt=xe,Ut=function(e){return{$:0,a:e}},Wt=function(e){switch(e.$){case 0:return 0;case 1:return 1;case 2:return 2;default:return 3}},M=$e,J=M(0),Gt=u(function(e,n,r,t){var o,a,i,c;return t.b?(o=t.a,(t=t.b).b?(a=t.a,(t=t.b).b?(i=t.a,(t=t.b).b?(c=t.b,z(e,o,z(e,a,z(e,i,z(e,t.a,500<r?D(y,e,n,$t(c)):S(Gt,e,n,r+1,c)))))):z(e,o,z(e,a,z(e,i,n)))):z(e,o,z(e,a,n))):z(e,o,n)):n}),Xt=b(function(e,n,r){return S(Gt,e,n,0,r)}),w=s(function(r,e){return D(Xt,s(function(e,n){return z(x,r(e),n)}),m,e)}),N=ze,Jt=s(function(n,e){return z(N,function(e){return M(n(e))},e)}),Qt=b(function(r,e,t){return z(N,function(n){return z(N,function(e){return M(z(r,n,e))},t)},e)}),Kt=Re,Zt=s(function(e,n){return Ve(z(N,Kt(e),n))}),te=b(function(e,n,r){return z(Jt,function(e){return 0},ur(z(w,Zt(e),n)))}),K=(Ee.Task={b:J,c:te,d:b(function(e,n,r){return M(0)}),e:s(function(e,n){return z(Jt,e,n)}),f:void 0},He("Task"),yn),eo={$:0},no={$:-2},ro=no,to=ro,oo=m,ao=u(function(e,n,r,t){return{$:0,a:e,b:n,c:r,d:t}}),io=S(ao,92/255,53/255,.4,1),le=s(function(e,n){return{$:0,a:{bC:io,at:3,ae:m,a$:e,bm:n,cu:3,gb:"Goblin (level 2)",aw:n,J:m}}}),$=b(function(e,n,r){return{b4:e,b6:n,b8:r}}),co=z(Nt,le,p([D($,-3,3,0),D($,-3,-3,0),D($,3,3,0),D($,3,-3,0)])),lo=je(m),uo=3.141592653589793,fo=function(e){return e},so={$:5},bo=je,vo=b(function(e,n,r){return n(e(r))}),mo=s(function(e,n){return{$:0,a:e,b:n}}),po=s(function(e,n){return{eW:n,fa:e}}),ee=M(z(po,ro,ro)),go=U,ho=s(function(e,n){for(;;){if(-2===n.$)return P;var r=n.c,t=n.d,o=n.e;switch(z(go,e,n.b)){case 0:e=e,n=t;continue;case 1:return C(r);default:e=e,n=o;continue}}}),q=l(function(e,n,r,t,o){return{$:-1,a:e,b:n,c:r,d:t,e:o}}),xo=l(function(e,n,r,t,o){var a,i,c,l;return-1!==o.$||o.a?-1!==t.$||t.a||-1!==t.d.$||t.d.a?V(q,e,n,r,t,o):(a=t.d,l=t.e,V(q,0,t.b,t.c,V(q,1,a.b,a.c,a.d,a.e),V(q,1,n,r,l,o))):(a=o.b,i=o.c,c=o.d,o=o.e,-1!==t.$||t.a?V(q,e,a,i,V(q,0,n,r,t,c),o):V(q,0,n,r,V(q,1,t.b,t.c,t.d,l=t.e),V(q,1,a,i,c,o)))}),Co=b(function(e,n,r){if(-2===r.$)return V(q,0,e,n,no,no);var t=r.a,o=r.b,a=r.c,i=r.d,c=r.e;switch(z(go,e,o)){case 0:return V(xo,t,o,a,D(Co,e,n,i),c);case 1:return V(q,t,o,n,i,c);default:return V(xo,t,o,a,i,D(Co,e,n,c))}}),Po=b(function(e,n,r){e=D(Co,e,n,r);return-1!==e.$||e.a?e:V(q,1,e.b,e.c,e.d,e.e)}),yo=s(function(e,n){var r=e.a,e=e.b,t=z(ho,r,n);return D(Po,r,1===t.$?p([e]):z(x,e,t.a),n)}),To=function(r){return{$:2,b:function(e){var n=r.f;2===n.$&&n.c&&n.c(),r.f=null,e({$:0,a:W})},c:null}},Lo=b(function(e,n,r){for(;;){if(-2===r.$)return n;var t=r.e,o=e,a=D(e,r.b,r.c,D(Lo,e,n,r.d));e=o,n=a,r=t}}),Mo=E(function(l,u,f,e,n,r){e=D(Lo,b(function(e,n,r){for(;;){var t=r.a,o=r.b;if(!t.b)return{a:t,b:D(f,e,n,o)};var a=t.a,i=a.a,a=a.b,c=t.b;if(0<=d(i,e))return 0<d(i,e)?{a:t,b:D(f,e,n,o)}:{a:c,b:S(u,i,a,n,o)};e=e,n=n,r={a:c,b:D(l,i,a,o)}}}),{a:vt(e),b:r},n),r=e.a,n=e.b;return D(y,s(function(e,n){return D(l,e.a,e.b,n)}),n,r)}),wo=Ie,No=wn,$o=Ve,zo=b(function(n,e,r){var t,o;return e.b?(o=e.b,e=$o(z(No,t=e.a,z(wo,n,t))),z(N,function(e){return D(zo,n,o,D(Po,t,e,r))},e)):M(r)}),ue=b(function(n,e,r){var r=r.eW,t=b(function(e,n,r){var t=r.c;return{a:r.a,b:r.b,c:z(N,function(e){return t},To(n))}}),o=D(y,yo,ro,e),e=H(Mo,b(function(e,n,r){var t=r.b,o=r.c;return{a:z(x,e,r.a),b:t,c:o}}),u(function(e,n,r,t){var o=t.c;return{a:t.a,b:D(Po,e,r,t.b),c:o}}),t,o,r,{a:m,b:ro,c:M(0)}),a=e.a,i=e.b;return z(N,function(e){return M(z(po,o,e))},z(N,function(e){return D(zo,n,a,i)},e.c))}),Do=lr,So=(ut=Do,{$:2,b:function(e){e({$:0,a:ut(Date.now())})},c:null}),ne=b(function(r,e,n){var t,e=z(ho,e,n.fa);return 1===e.$?M(n):(t=e.a,z(N,function(e){return M(n)},z(N,function(n){return ur(z(w,function(e){return z(Kt,r,e(n))},t))},So)))}),Vo=b(function(e,n,r){return e(n(r))}),Ao=(Ee.Time={b:ee,c:ue,d:ne,e:0,f:s(function(e,n){return z(mo,n.a,z(Vo,e,n.b))})},He("Time")),_o=s(function(e,n){return Ao(z(mo,e,n))}),qo=ge,Fo=me,Bo=b(function(e,n,r){return{dg:r,e_:n,e8:e}}),ko=M(D(Bo,m,P,0)),Eo={$:2,b:function(e){e({$:0,a:Date.now()})},c:null},Ro={$:2,b:function(e){var n=Ln(function(){e({$:0,a:Date.now()})});return function(){Tn(n)}},c:null},he=b(function(e,r,n){var t=n.e_,n=n.dg,o={a:t,b:r};return 1===o.a.$?o.b.b?z(N,function(n){return z(N,function(e){return M(D(Bo,r,C(n),e))},Eo)},$o(z(N,wo(e),Ro))):ko:o.b.b?M(D(Bo,r,t,n)):z(N,function(e){return ko},To(o.a.a))}),xe=b(function(n,r,e){function t(e){return z(Kt,n,e.$?(0,e.a)(r-a):(0,e.a)(Do(r)))}var o=e.e8,a=e.dg;return z(N,function(n){return z(N,function(e){return M(D(Bo,o,C(n),r))},ur(z(w,t,o)))},$o(z(N,wo(n),Ro)))}),Io=(Ee["Browser.AnimationManager"]={b:ko,c:he,d:xe,e:0,f:s(function(e,n){return n.$?{$:1,a:z(Vo,e,n.a)}:{$:0,a:z(Vo,e,n.a)}})},He("Browser.AnimationManager")),Ho=function(e){return Io({$:0,a:e})},jo=b(function(e,n,r){return{$:0,a:e,b:n,c:r}}),Oo=s(function(e,n){return{eS:n,e8:e}}),Re=M(z(Oo,m,ro)),Yo=s(function(e,n){return{d1:n,ec:e}}),Uo=b(function(n,r,e){return z(Jt,function(e){return{a:r,b:e}},D(zn,e.a?$n:Nn,e.b,function(e){return z(wo,n,z(Yo,r,e))}))}),Wo=s(function(e,n){return D(Lo,Po,n,e)}),J=b(function(o,e,n){var r=b(function(e,n,r){var t=r.c;return{a:r.a,b:r.b,c:z(x,D(Uo,o,e,n),t)}}),t=b(function(e,n,r){var t=r.b,o=r.c;return{a:z(x,n,r.a),b:t,c:o}}),a=u(function(e,n,r,t){var o=t.c;return{a:t.a,b:D(Po,e,n,t.b),c:o}}),i=z(w,vr,e),e=H(Mo,t,a,r,n.eS,mr(i),{a:m,b:ro,c:m}),c=e.b,l=e.c;return z(N,function(e){return M(z(Oo,i,z(Wo,c,mr(e))))},z(N,function(e){return ur(l)},ur(z(w,To,e.a))))}),Go=b(function(e,n,r){e=e(n);return e.$?r:z(x,e.a,r)}),Xo=s(function(e,n){return D(Xt,Go(e),m,n)}),te=b(function(e,n,r){var t=n.ec,o=n.d1,n=z(Xo,function(e){var n=e.b,n=n.c;return f(e.a,t)?z(Dn,n,o):P},r.e8);return z(N,function(e){return M(r)},ur(z(w,Kt(e),n)))}),Jo=(Ee["Browser.Events"]={b:Re,c:J,d:te,e:0,f:s(function(e,n){return D(jo,n.a,n.b,z(Ot,e,n.c))})},He("Browser.Events")),yn=b(function(e,n,r){return Jo(D(jo,e,n,r))}),Qo=z(yn,0,"keydown"),Ko=z(yn,0,"keyup"),Zo=z(yn,0,"mousedown"),ea=s(function(e,n){return{b4:e,b6:n}}),na=pe,ra=s(function(e,n){return z(go,e,n)}),F=function(e){return e<0?-e:e},ta=se,oa=0,aa=s(function(e,n){var r=n.b8-e.b8,t=n.b6-e.b6,n=n.b4-e.b4,e=z(T,F(n),z(T,F(t),F(r)));return e?ta((n=n/e)*n+(n=t/e)*n+(t=r/e)*t)*e:oa}),a=b(function(e,n,r){return{b4:e,b6:n,b8:r}}),ia=s(function(e,n){return{b4:n.b4+e.b4,b6:n.b6+e.b6,b8:n.b8+e.b8}}),ca=s(function(e,n){return xr(z(ia,e,h(n)))}),la=Z,ua=s(function(e,n){return n.$?e:n.a}),fa=s(function(e,r){return z(ua,z(ca,D(a,1,0,0),e),hr(z(la,s(function(e,n){return z(ra,z(aa,r,e),z(aa,r,n))}),p([z(ca,D(a,1,0,0),e),z(ca,D(a,-1,0,0),e),z(ca,D(a,0,1,0),e),z(ca,D(a,0,-1,0),e)]))))}),sa=s(function(r,e){return D(Xt,s(function(e,n){return r(e)?z(x,e,n):n}),m,e)}),ba=s(function(e,n){return!z(ho,e,n).$}),da=s(function(e,n){return z(ba,e,n)}),va=Y,ma=s(function(e,n){return n.$?n:{$:0,a:n.a+e}}),pa=s(function(e,n){return-1<d(ir(n),28)?n:G(n,p([e]))}),ga=b(function(e,n,r){for(;;){if(!r.b)return P;var t=r.b;if(n(r.a))return C(e);e=e+1,n=n,r=t}})(0),ha=s(function(e,n){for(;;){if(e<=0)return n;if(!n.b)return n;e=e-1,n=n.b}}),xa=b(function(e,n,r){for(;;){if(e<=0)return r;if(!n.b)return r;var t=n.a;e=e-1,n=n.b,r=z(x,t,r)}}),Ca=s(function(e,n){return $t(D(xa,e,n,m))}),Pa=b(function(e,n,r){if(0<n){var t,o,a,i,c,l={a:n,b:r};e:for(;;){n:for(;;){if(!l.b.b)return r;if(!l.b.b.b){if(1===l.a)break e;break}switch(l.a){case 1:break e;case 2:var u=l.b;return p([u.a,u.b.a]);case 3:if(l.b.b.b.b)return p([(u=l.b).a,(t=u.b).a,t.b.a]);break n;default:if(l.b.b.b.b&&l.b.b.b.b.b)return c=(i=(a=(o=(t=l.b).b).b).b).b,z(x,t.a,z(x,o.a,z(x,a.a,z(x,i.a,1e3<e?z(Ca,n-4,c):D(Pa,e+1,n-4,c)))));break n}}return r}return p([l.b.a])}return m}),ya=s(function(e,n){return D(Pa,0,e,n)}),Ta=b(function(e,n,r){var t,o;return 0<=e&&(o=z(ha,e,r)).b?(t=o.a,o=o.b,G(z(ya,e,r),z(x,n(t),o))):r}),La=s(function(e,n){var r,t=e.bl;return t.$||(t=t.a,1===(r=z(ga,Cr,n)).$)?z(pa,e.bl,n):D(Ta,r.a,ma(t),n)}),Ma=s(function(e,n){return-1<d(e,n.dw)?{$:0,a:{bC:n.bC,at:n.cu,ae:m,a$:n.a$,bm:n.aw,cu:n.cu,gb:n.gb,aw:n.aw,J:m}}:{$:1,a:n}}),wa=s(function(e,n){return{b4:n.b4-e.b4,b6:n.b6-e.b6,b8:n.b8-e.b8}}),Na=function(e){return e},$a=s(function(e,n){return d(e,n)<0?e:n}),za={b4:0,b6:0,b8:0},Da={b4:0,b6:0,b8:0},Sa=s(function(e,n){var r,t=z(T,F(n.b4),z(T,F(n.b6),F(n.b8)));return t?{b4:e*(r=n.b4/t)/(t=ta(r*r+(r=n.b6/t)*r+(n=n.b8/t)*n)),b6:e*r/t,b8:e*n/t}:Da}),Va=s(function(r,e){function n(e){return xr(z(ia,z(wa,za,r),(n=z($a,.05,Pr(yr(e=z(wa,r,e)))),z(Sa,Na(n),e))));var n}var t,o;return e.b?(o=e.b,f(r,t=e.a)?o.b?{a:n(o.a),b:o}:{a:r,b:m}:{a:n(t),b:e}):{a:r,b:e}}),Aa=s(function(t,o){var e=s(function(e,n){return fr(e+n/(2*uo))}),n=z(w,function(e){var n,r;return e.$?z(Ma,t,n=e.a):(r=(e=z(Va,(n=e.a).bm,n.J)).a,e=e.b,{$:0,a:v(n,{ae:z(sa,function(e){return 0<d(e.ch,t)},n.ae),bm:r,J:3===(r=o.I).$&&f(n.a$,r.a.a$)?z(ya,1,e):e})})},o.P),r=z(sa,function(e){return 0<d(e.ch,t)},o.ae),a=function(){var e=o.I;switch(e.$){case 2:var n=e.a;return z(Va,o.bm,o.J);case 3:n=z(ua,(n=e.a).bm,hr(n.J));return z(Va,o.bm,p([z(fa,n,o.bm)]));case 0:return z(Va,o.bm,o.J);default:return z(Va,o.bm,o.J)}}(),i=a.a,c=a.b,a=function(){var e={a:c,b:o.I};e:for(;;){if(e.a.b)break;switch(e.b.$){case 2:return{a:{$:3,a:e.b.a},b:o.a0,c:o.X};case 1:var n=e.b.a;return{a:eo,b:z(La,n,o.a0),c:z(sa,va(n),o.X)};default:break e}}return{a:o.I,b:o.a0,c:o.X}}(),l=a.b,a=v(o,{I:a.a,X:z(sa,function(e){return 0<d(e.dY,t)},a.c),ae:r,a0:l,bm:i,P:n,aL:t,J:c});return z(da,"ArrowLeft",o.aF)?v(a,{aX:z(e,-.005,o.aX)}):z(da,"ArrowRight",o.aF)?v(a,{aX:z(e,.005,o.aX)}):a}),_a={$:1},qa=s(function(n,e){return hr(z(Xo,function(e){return!e.$&&f((e=e.a).a$,n)?C(e):P},e))}),Fa=s(function(e,n){return{bC:n.bC,a$:n.a$,cu:n.cu,gb:n.gb,dw:e+2e4,aw:n.aw}}),Ba=b(function(n,r,e){return z(w,function(e){return e.$?{$:1,a:e.a}:f((e=e.a).a$,n)?r(e):{$:0,a:e}},e)}),ka=b(function(e,t,o){var a,n,r,i=o.I;return 3===i.$?(a=o.aL+500,n=D(Ba,(i=i.a).a$,function(e){var n=z(x,{cM:t,ch:a},e.ae),r=e.at-t;return 0<r?{$:0,a:v(e,{at:r,ae:n})}:{$:1,a:z(Fa,o.aL,e)}},o.P),r=1===z(qa,i.a$,n).$?z(x,o.aL%2?{dY:o.aL+2e4,bl:_a,bm:i.bm}:{dY:o.aL+2e4,bl:{$:0,a:2},bm:i.bm},o.X):o.X,v(o,{a9:o.aT?o.a9:o.a9+t,I:1===(i=z(qa,i.a$,n)).$?eo:{$:3,a:i.a},bc:2===o.aT?o.bc+t:o.bc,X:r,at:z(T,1,o.at-e),ae:z(x,{cM:1===o.at?0:e,ch:a},o.ae),P:n,bs:1===o.aT?o.bs+t:o.bs})):o}),Ea=b(function(e,n,r){var t;return 0<e?(t=(r.b4-n.b4)/e)*t+(t=(r.b6-n.b6)/e)*t+(t=(r.b8-n.b8)/e)*t<=1:!e&&f(n.b4,r.b4)&&f(n.b6,r.b6)&&f(n.b8,r.b8)}),Ra=function(e){return-e},Ia=s(function(e,n){return{b4:e.b6*n.b8-e.b8*n.b6,b6:e.b8*n.b4-e.b4*n.b8,b8:e.b4*n.b6-e.b6*n.b4}}),Ha=function(e){return e.dL},ja=function(e){return e.dM},Oa=function(e){return z(Ia,Ha(e),ja(e))},Ya=ae,Ua=ie,Wa=b(function(e,n,r){var n=.5*n,t=Ya(n),n=Ua(n),e=e.fF,o=e.b4*n,a=t*o,i=o*o,c=e.b6*n,l=t*c,u=o*c,f=c*c,e=e.b8*n,n=t*e,t=o*e,o=c*e,c=e*e;return{b4:(1-2*(f+c))*r.b4+2*(u-n)*r.b6+2*(t+l)*r.b8,b6:2*(u+n)*r.b4+(1-2*(i+c))*r.b6+2*(o-a)*r.b8,b8:2*(t-l)*r.b4+2*(o+a)*r.b6+(1-2*(i+f))*r.b8}}),Ga=b(function(e,n,r){var n=.5*n,t=Ya(n),n=Ua(n),o=e.dh,a=r.b4-o.b4,i=r.b6-o.b6,r=r.b8-o.b8,e=e.fF,c=e.b4*n,l=t*c,u=c*c,f=e.b6*n,s=t*f,b=c*f,d=f*f,e=e.b8*n,n=t*e,t=c*e,c=f*e,f=e*e;return{b4:o.b4+(1-2*(d+f))*a+2*(b-n)*i+2*(t+s)*r,b6:o.b6+2*(b+n)*a+(1-2*(u+f))*i+2*(c-l)*r,b8:o.b8+2*(t-s)*a+2*(c+l)*i+(1-2*(u+d))*r}}),Xa=function(e){return e},Ja=function(e){return e.dL},Qa=function(e){return e.dM},Ka=b(function(e,n,r){return Xa({dh:D(Ga,e,n,Lr(r)),dL:D(Wa,e,n,Ja(r)),dM:D(Wa,e,n,Qa(r)),dN:D(Wa,e,n,Mr(r))})}),Za=b(function(e,n,r){return D(Ka,e(r),n,r)}),i=s(function(e,n){return{b4:n.b4+e.b4,b6:n.b6+e.b6,b8:n.b8+e.b8}}),ei=s(function(e,n){return Xa({dh:z(i,e,Lr(n)),dL:Ja(n),dM:Qa(n),dN:Mr(n)})}),ni=s(function(e,n){return{b4:e*n.b4,b6:e*n.b6,b8:e*n.b8}}),ri=b(function(e,n,r){return z(ei,z(ni,n,e),r)}),ti=b(function(e,n,r){return D(ri,wr(e(r)),n,r)}),oi=s(function(e,n){return{fF:n,dh:e}}),ai=function(e){return z(oi,e.dh,e.dL)},ii=function(e){return z(oi,e.dh,e.dM)},ci=function(e){return z(oi,e.dh,e.dN)},li=function(e){return{$:0,a:e}},ui=function(e){return F(e)},fi=function(e){return.5*e},si=ce,bi=function(e){return si(e)},le={b4:1,b6:0,b8:0},U={b4:0,b6:1,b8:0},di=lr({dh:za,dL:le,dM:U}),vi=function(e){return function(e){var n=fi(ui(e.gH)),n=bi(n);return{ds:li(n),gJ:e.gJ}}({gH:Tr(30),gJ:(e={fo:e.aX,fG:Na(15),fL:Tr(30),fV:e.bm,fW:di},n=Xa({dh:e.fV,dL:ja(e.fW),dM:Oa(e.fW),dN:Ha(e.fW)}),D(ti,ci,e.fG,D(Za,ai,Ra(e.fL),D(Za,ii,e.fo,n))))});var n},mi=s(function(e,n){return n.b4*e.b4+n.b6*e.b6+n.b8*e.b8}),pi=s(function(e,n){return e*n}),gi=s(function(e,n){var r=e.dh,e=e.gl;return(n.b4-r.b4)*e.b4+(n.b6-r.b6)*e.b6+(n.b8-r.b8)*e.b8}),hi=b(function(e,n,r){return{b4:r.b4+n*e.b4,b6:r.b6+n*e.b6,b8:r.b8+n*e.b8}}),xi=s(function(e,n){var r=wr(n),t=z(mi,e.gl,r);return t?(n=function(e){return e.dh}(n),C(D(hi,r,z(pi,-1/t,z(gi,e,n)),n))):P}),Ci=s(function(e,n){return n.$?P:C(e(n.a))}),Pi=s(function(e,n){return n=h(n),r=n.b6,t=n.b8,{b4:e(n.b4),b6:e(r),b8:e(t)};var r,t}),yi=s(function(e,n){return e*n}),Ti=s(function(e,n){return n/e}),Li={b4:0,b6:0,b8:-1},Mi=s(function(e,n){return n/e}),wi=s(function(e,n){var r=e.dN,t=e.dM,e=e.dL;return{b4:e.b4*n.b4+t.b4*n.b6+r.b4*n.b8,b6:e.b6*n.b4+t.b6*n.b6+r.b6*n.b8,b8:e.b8*n.b4+t.b8*n.b6+r.b8*n.b8}}),Ni=s(function(e,n){var r=e.dh,e=e.dL;return(n.b4-r.b4)*e.b4+(n.b6-r.b6)*e.b6}),$i=b(function(e,n,r){return{b4:e,b6:n,b8:r}}),zi=u(function(e,n,r,t){var o=e.dh,a=e.dN,i=e.dM,e=e.dL;return{b4:o.b4+n*e.b4+r*i.b4+t*a.b4,b6:o.b6+n*e.b6+r*i.b6+t*a.b6,b8:o.b8+n*e.b8+r*i.b8+t*a.b8}}),Di=s(function(e,n){var r=e.dh,e=e.dM;return(n.b4-r.b4)*e.b4+(n.b6-r.b6)*e.b6}),Si=b(function(e,n,r){var t,o=z(Di,Nr(n),r),r=z(Ni,Nr(n),r),a=e.gJ,n=$r(n),n=n.b,i=e.ds;return i.$?z(oi,S(zi,a,z(yi,t=z(Mi,n,i.a),r),z(yi,t,o),oa),Sr(e.gJ)):(t=Ra(z(Ti,i.a,z(pi,.5,n))),i=z(wi,a,z(ua,Li,function(e){var n,r,t=z(T,F(e.b4),z(T,F(e.b6),F(e.b8)));return t?(t=ta((r=e.b4/t)*r+(n=e.b6/t)*n+(e=e.b8/t)*e),C({b4:r/t,b6:n/t,b8:e/t})):P}(D($i,r,o,t)))),z(oi,zr(e.gJ),i))}),B=fe,Vi=function(e){return e},Ai=600,_i=800,qi=s(function(e,n){return-1<d(n,e)}),Fi=s(function(e,n){return e+.5*(n-e)}),Bi=s(function(e,n){return n-e}),ki={b4:-1,b6:0},Ei={b4:0,b6:-1},Ri={b4:1,b6:0},Ii={b4:0,b6:1},Hi=s(function(e,n){return{b4:e,b6:n}}),Ie=u(function(e,n,r,t){var o=z(qi,n,t)?Ii:Ei,a=z(qi,e,r)?Ri:ki,i={a:ui(z(Bi,e,r)),b:ui(z(Bi,n,t))};return{fn:{dh:z(Hi,z(Fi,e,r),z(Fi,n,t)),dL:a,dM:o},fE:i}}),ji=(wn={gM:Vi(0),gN:Vi(_i),gP:Vi(Ai),gQ:Vi(0)},S(Ie,wn.gM,wn.gP,wn.gN,wn.gQ)),Oi=s(function(e,n){return{$:0,a:e,b:n}}),Yi=s(function(e,n){return{$:1,a:e,b:n}}),ee=function(e){var n=e.a,e=e.b;return p([z(Yi,{a:n,b:e},4),z(Oi,{a:n,b:e},3),z(Yi,{a:n+3,b:e},4),z(Oi,{a:n,b:e-4},1),z(Oi,{a:n+2,b:e-4},1)])}({a:6,b:6}),Ui=s(function(e,n){return n.b?D(Xt,x,n,e):e}),Wi=s(function(e,n){return Vr(z(w,e,n))}),Gi=s(function(e,n){return{$:0,a:e,b:n}}),Xi=s(function(e,n){return D(Po,e,0,n)}),Ji=s(function(e,n){return z(Gi,n.a,z(x,e,n.b))}),Qi=u(function(n,e,r,t){for(;;){var o=function(e){for(;;){var n,r,t;if(e.a.b)return r=(n=e.a).b,t=e.b,{a:C(n.a),b:z(Gi,r,t)};if(!e.b.b)return{a:P,b:e};e=z(Gi,$t(t=e.b),m)}}(e);if(1===o.a.$)return P;var a=o.a.a,i=a.a,c=a.b,a=o.b;if(f(i,t))return C($t(z(x,t,c)));o=z(sa,function(e){return!z(da,e,r)&&!z(da,{a:e,b:i},n)&&!z(da,{a:i,b:e},n)},function(e){var n=e.a,e=e.b;return p([{a:n,b:e-1},{a:n,b:e+1},{a:n-1,b:e},{a:n+1,b:e},{a:n-1,b:e-1},{a:n+1,b:e-1},{a:n+1,b:e+1},{a:n-1,b:e+1}])}(i));n=n,e=D(y,s(function(e,n){return z(Ji,{a:e,b:z(x,i,c)},n)}),a,o),r=D(y,Xi,r,o),t=t}}),Ki=b(function(e,n,r){return S(Qi,Ar(z(Wi,function(e){var n=e.a,e=e.b;return p([{a:n,b:e},{a:e,b:n}])},z(Wi,_r,e))),(e=p([{a:n,b:m}]),z(Gi,e,m)),Ar(p([n])),r)})(ee),Zi=s(function(e,n){e={a:B(h(e).b4),b:B(h(e).b6)},n={a:B(h(n).b4),b:B(h(n).b6)};return z(w,function(e){return D($,e.a,e.b,0)},z(ua,m,z(Ki,e,n)))}),ue={b4:0,b6:0,b8:1},ec=z(s(function(e,n){return{gl:n,dh:e}}),za,ue),nc=s(function(e,n){var r,t=D(Si,vi(n),ji,e),t=z(Ci,Pi(z(vo,B,cr)),z(xi,ec,t));return 0<d(qr(e).b4,_i)||0<d(qr(e).b6,Ai)||1===t.$?n:(r=t.a,e=z(ua,n.bm,hr(n.J)),t=hr(z(sa,function(e){return D(Ea,Na(.5),r,e.bm)},n.X)),v(n,(t={a:hr(z(sa,function(e){return!e.$&&(e=e.a,D(Ea,Na(.5),r,e.bm))},n.P)),b:t}).a.$||t.a.a.$?t.b.$?{I:eo,J:z(Zi,e,r)}:{I:{$:1,a:t.b.a},J:z(Zi,e,r)}:{I:{$:2,a:t.a.a.a},J:z(Zi,e,z(fa,r,n.bm))}))}),rc=s(function(e,n){return{$:0,a:e,b:n}}),ne=z(N,function(e){return M((e=pr(e),n=Fr(z(rc,0,1013904223)),Fr(z(rc,n.a+e>>>0,n.b))));var n},So),tc=s(function(e,n){return e(n)}),oc=b(function(n,e,r){var t,o;return e.b?(t=e.b,o=(e=z(tc,e.a,r)).b,z(N,function(e){return D(oc,n,t,o)},z(Kt,n,e.a))):M(r)}),ge=b(function(e,n,r){return M(r)}),ac=s(function(r,e){var t=e;return function(e){var e=t(e),n=e.b;return{a:r(e.a),b:n}}}),ic=(Ee.Random={b:ne,c:oc,d:ge,e:s(function(e,n){return z(ac,e,n)}),f:void 0},He("Random")),cc=s(function(e,n){return ic(z(ac,e,n))}),lc=s(function(e,n){return{$:6,a:e,b:n}}),me=s(function(l,u){return function(e){var n=d(l,u)<0?{a:l,b:u}:{a:u,b:l},r=n.a,t=n.b-r+1;if(!(t-1&t))return{a:((t-1&Br(e))>>>0)+r,b:Fr(e)};for(var o=(-t>>>0)%t>>>0,a=e;;){var i=Br(a),c=Fr(a);if(0<=d(i,o))return{a:i%t+r,b:c};a=c}}}),uc=b(function(t,e,n){var o=e,a=n;return function(e){var e=o(e),n=e.a,e=a(e.b),r=e.b;return{a:z(t,n,e.a),b:r}}}),fc=z(cc,function(e){return z(lc,e.a,e.b)},z(s(function(e,n){return D(uc,s(function(e,n){return{a:e,b:n}}),e,n)}),z(me,0,1),z(me,0,1))),sc=s(function(e,n){return xr(z(ia,z(wa,za,e),z(wa,za,n)))}),bc=u(function(e,n,r,t){for(;;){if(n<1)return{a:e,b:t};var o=r(t),a=o.b;e=z(x,o.a,e),n=n-1,r=r,t=a}}),dc=s(function(n,e){var r=e;return function(e){return S(bc,m,n,r,e)}}),vc=s(function(e,n){return{a:n.a,b:e(n.b)}}),mc=b(function(e,n,r){return d(r,e)<0?e:0<d(r,n)?n:r}),pc=s(function(e,n){var r,t;return f(e,n)?m:(r=D(mc,-1,1,h(n).b6-h(e).b6),t=D(mc,-1,1,h(n).b4-h(e).b4),t=xr(z(ia,z(wa,za,D($,t,r,0)),z(wa,za,e))),z(x,t,z(pc,t,n)))}),gc=s(function(o,a){return function(e){var n=Fr(e),r=F(a-o),t=Br(n);return{a:(134217728*(67108863&Br(e))+(134217727&t))/9007199254740992*r+o,b:Fr(n)}}}),hc=b(function(e,n,r){for(;;){var t=e.a,o=e.b;if(!n.b)return o;var a=n.a,i=n.b;if(d(r,F(t))<1)return o;e=a,n=i,r=r-F(t)}}),xc=s(function(e,n){function r(e){return F(e.a)}var t=r(e)+D(y,Pt,0,z(w,r,n));return z(ac,z(hc,e,n),z(gc,0,t))}),Cc=s(function(e,r){return z(Wi,function(n){return z(w,function(e){return{a:e,b:n}},z(wt,e,r))},z(wt,e,r))}),Pc=s(function(e,n){return z(w,function(e){return{a:1,b:e}},z(Cc,e,n))}),yc=R(function(e,n,r,t,o,a,i){if(-1!==a.$||a.a){for(;;){if(-1!==i.$||1!==i.a)break;if(-1!==i.d.$)return Rr(n);if(1===i.d.a)return Rr(n);break}return n}return V(q,r,a.b,a.c,a.d,V(q,0,t,o,a.e,i))}),Tc=s(function(e,n){var r,t,o,a,i,c,l;return-2===n.$?no:(r=n.a,o=n.c,a=n.d,i=n.e,d(e,t=n.b)<0?-1===a.$&&1===a.a?-1!==(c=a.d).$||c.a?-1===(c=Er(n)).$?(l=c.e,V(xo,c.a,c.b,c.c,z(Tc,e,c.d),l)):no:V(q,r,t,o,z(Tc,e,a),i):V(q,r,t,o,z(Tc,e,a),i):z(Lc,e,j(yc,e,n,r,t,o,a,i)))}),Lc=s(function(e,n){var r,t,o,a,i;return-1===n.$?(r=n.a,t=n.c,o=n.d,a=n.e,f(e,n=n.b)?-1===(i=function(e){for(;;){if(-1!==e.$||-1!==e.d.$)return e;e=e.d}}(a)).$?V(xo,r,i.b,i.c,o,Ir(a)):no:V(xo,r,n,t,o,z(Tc,e,a))):no}),Mc=s(function(e,n){e=z(Tc,e,n);return-1!==e.$||e.a?e:V(q,1,e.b,e.c,e.d,e.e)}),wc=s(function(e,n){return z(Mc,e,n)}),he=s(function(e,o){switch(e.$){case 0:return{a:z(Aa,e.a,o),b:z(cc,gr,(r=o.P,z(ac,function(e){return D(Lt,s(function(e,n){e={a:e,b:n};return e.a.$||e.b.$?P:C(z(pc,(n=e.b.a).bm,z(sc,e.a.a,n.aw)))}),e,r)},z(ac,w(Ci(kr)),z(dc,ir(r),z(xc,{a:500,b:P},z(w,vc(C),z(Pc,-1,1))))))))};case 1:return{a:z(nc,e.a,o),b:lo};case 2:return{a:v(o,{aF:z(Xi,e.a,o.aF)}),b:lo};case 3:return{a:v(o,{aF:z(wc,e.a,o.aF)}),b:lo};case 4:return{a:v(o,{bW:e.a}),b:lo};case 5:return{a:o,b:fc};case 6:return{a:D(ka,e.a,e.b,o),b:lo};case 7:return{a:v(o,{aT:e.a}),b:lo};default:var n=e.a,n=D(Lt,s(function(e,n){var r,t,n={a:e,b:n};return n.a.$||n.b.$||(r=n.a.a,n=n.b.a,3===(t=o.I).$&&f(t.a.a$,r.a$))?e:{$:0,a:v(r,{J:n})}}),o.P,n);return{a:v(o,{P:n}),b:lo}}var r}),Nc=Ne,$c=s(function(e,n){return z(nn,e,Nc(n))})("className"),c=Qe("div"),t=Je,zc=function(e){return{$:0,a:e}},Dc=s(function(e,n){return{$:0,a:e,b:n}}),Sc=Vn,Vc=function(e){e=function(e){return{ba:e.d,cR:e.c,cY:e.b,dt:e.a}}(e);return D(Sc,e.dt,e.cY,e.cR)},Ac=S(ao,143/255,89/255,2/255,1),_c={$:0},qc=s(function(e,n){for(;;){if(!e.b)return n;var r=e.a;e=e.b,n=z(x,r,n)}}),Fc=s(function(e,n){return{$:1,a:e,b:n}}),Bc={src:"\n        precision mediump float;\n        \n        uniform mediump sampler2D colorTexture;\n        \n        varying mediump vec2 interpolatedUv;\n        \n        void main () {\n            gl_FragColor = texture2D(colorTexture, interpolatedUv);\n        }\n    ",attributes:{},uniforms:{colorTexture:"cg"}},kc={src:"\n        precision lowp float;\n        \n        uniform lowp vec3 constantColor;\n        \n        void main () {\n            gl_FragColor = vec4(constantColor, 1.0);\n        }\n    ",attributes:{},uniforms:{constantColor:"aY"}},Ec={src:"\n        precision mediump float;\n        \n        uniform mediump vec3 emissiveColor;\n        uniform highp mat4 sceneProperties;\n        \n        float gammaCorrect(float u) {\n            if (u <= 0.0031308) {\n                return 12.92 * u;\n            } else {\n                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;\n            }\n        }\n        \n        vec3 gammaCorrectedColor(vec3 color) {\n            float red = gammaCorrect(color.r);\n            float green = gammaCorrect(color.g);\n            float blue = gammaCorrect(color.b);\n            return vec3(red, green, blue);\n        }\n        \n        vec3 reinhardLuminanceToneMap(vec3 color) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scale = 1.0 / (1.0 + luminance);\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 reinhardPerChannelToneMap(vec3 color) {\n            return gammaCorrectedColor(color / (color + 1.0));\n        }\n        \n        float extendedReinhardToneMap(float x, float xMax) {\n            return x * (1.0 + (x / (xMax * xMax))) / (1.0 + x);\n        }\n        \n        vec3 extendedReinhardLuminanceToneMap(vec3 color, float overexposureLimit) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scaledLuminance = extendedReinhardToneMap(luminance, overexposureLimit);\n            float scale = scaledLuminance / luminance;\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 extendedReinhardPerChannelToneMap(vec3 color, float overexposureLimit) {\n            float red = extendedReinhardToneMap(color.r, overexposureLimit);\n            float green = extendedReinhardToneMap(color.g, overexposureLimit);\n            float blue = extendedReinhardToneMap(color.b, overexposureLimit);\n            return gammaCorrectedColor(vec3(red, green, blue));\n        }\n        \n        vec3 hableFilmicHelper(vec3 color) {\n            float a = 0.15;\n            float b = 0.5;\n            float c = 0.1;\n            float d = 0.2;\n            float e = 0.02;\n            float f = 0.3;\n            return (color * (a * color + c * b) + d * e) / (color * (a * color + b) + d * f) - e / f;\n        }\n        \n        vec3 hableFilmicToneMap(vec3 color) {\n            float exposureBias = 2.0;\n            vec3 unscaled = hableFilmicHelper(exposureBias * color);\n            vec3 scale = 1.0 / hableFilmicHelper(vec3(11.2));\n            return gammaCorrectedColor(scale * unscaled);\n        }\n        \n        vec3 toneMap(vec3 color, float toneMapType, float toneMapParam) {\n            if (toneMapType == 0.0) {\n                return gammaCorrectedColor(color);\n            } else if (toneMapType == 1.0) {\n                return reinhardLuminanceToneMap(color);\n            } else if (toneMapType == 2.0) {\n                return reinhardPerChannelToneMap(color);\n            } else if (toneMapType == 3.0) {\n                return extendedReinhardLuminanceToneMap(color, toneMapParam);\n            } else if (toneMapType == 4.0) {\n                return extendedReinhardPerChannelToneMap(color, toneMapParam);\n            } else if (toneMapType == 5.0) {\n                return hableFilmicToneMap(color);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {\n            vec3 referenceWhite = sceneProperties[2].rgb;\n            float unitR = linearColor.r / referenceWhite.r;\n            float unitG = linearColor.g / referenceWhite.g;\n            float unitB = linearColor.b / referenceWhite.b;\n            float toneMapType = sceneProperties[3][2];\n            float toneMapParam = sceneProperties[3][3];\n            vec3 toneMapped = toneMap(vec3(unitR, unitG, unitB), toneMapType, toneMapParam);\n            return vec4(toneMapped, 1.0);\n        }\n        \n        void main () {\n            gl_FragColor = toSrgb(emissiveColor, sceneProperties);\n        }\n    ",attributes:{},uniforms:{emissiveColor:"be",sceneProperties:"g"}},Rc={src:"\n        precision mediump float;\n        \n        uniform mediump sampler2D colorTexture;\n        uniform mediump float backlight;\n        uniform highp mat4 sceneProperties;\n        \n        varying mediump vec2 interpolatedUv;\n        \n        float inverseGamma(float u) {\n            if (u <= 0.04045) {\n                return clamp(u / 12.92, 0.0, 1.0);\n            } else {\n                return clamp(pow((u + 0.055) / 1.055, 2.4), 0.0, 1.0);\n            }\n        }\n        \n        vec3 fromSrgb(vec3 srgbColor) {\n            return vec3(\n                inverseGamma(srgbColor.r),\n                inverseGamma(srgbColor.g),\n                inverseGamma(srgbColor.b)\n            );\n        }\n        \n        float gammaCorrect(float u) {\n            if (u <= 0.0031308) {\n                return 12.92 * u;\n            } else {\n                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;\n            }\n        }\n        \n        vec3 gammaCorrectedColor(vec3 color) {\n            float red = gammaCorrect(color.r);\n            float green = gammaCorrect(color.g);\n            float blue = gammaCorrect(color.b);\n            return vec3(red, green, blue);\n        }\n        \n        vec3 reinhardLuminanceToneMap(vec3 color) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scale = 1.0 / (1.0 + luminance);\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 reinhardPerChannelToneMap(vec3 color) {\n            return gammaCorrectedColor(color / (color + 1.0));\n        }\n        \n        float extendedReinhardToneMap(float x, float xMax) {\n            return x * (1.0 + (x / (xMax * xMax))) / (1.0 + x);\n        }\n        \n        vec3 extendedReinhardLuminanceToneMap(vec3 color, float overexposureLimit) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scaledLuminance = extendedReinhardToneMap(luminance, overexposureLimit);\n            float scale = scaledLuminance / luminance;\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 extendedReinhardPerChannelToneMap(vec3 color, float overexposureLimit) {\n            float red = extendedReinhardToneMap(color.r, overexposureLimit);\n            float green = extendedReinhardToneMap(color.g, overexposureLimit);\n            float blue = extendedReinhardToneMap(color.b, overexposureLimit);\n            return gammaCorrectedColor(vec3(red, green, blue));\n        }\n        \n        vec3 hableFilmicHelper(vec3 color) {\n            float a = 0.15;\n            float b = 0.5;\n            float c = 0.1;\n            float d = 0.2;\n            float e = 0.02;\n            float f = 0.3;\n            return (color * (a * color + c * b) + d * e) / (color * (a * color + b) + d * f) - e / f;\n        }\n        \n        vec3 hableFilmicToneMap(vec3 color) {\n            float exposureBias = 2.0;\n            vec3 unscaled = hableFilmicHelper(exposureBias * color);\n            vec3 scale = 1.0 / hableFilmicHelper(vec3(11.2));\n            return gammaCorrectedColor(scale * unscaled);\n        }\n        \n        vec3 toneMap(vec3 color, float toneMapType, float toneMapParam) {\n            if (toneMapType == 0.0) {\n                return gammaCorrectedColor(color);\n            } else if (toneMapType == 1.0) {\n                return reinhardLuminanceToneMap(color);\n            } else if (toneMapType == 2.0) {\n                return reinhardPerChannelToneMap(color);\n            } else if (toneMapType == 3.0) {\n                return extendedReinhardLuminanceToneMap(color, toneMapParam);\n            } else if (toneMapType == 4.0) {\n                return extendedReinhardPerChannelToneMap(color, toneMapParam);\n            } else if (toneMapType == 5.0) {\n                return hableFilmicToneMap(color);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {\n            vec3 referenceWhite = sceneProperties[2].rgb;\n            float unitR = linearColor.r / referenceWhite.r;\n            float unitG = linearColor.g / referenceWhite.g;\n            float unitB = linearColor.b / referenceWhite.b;\n            float toneMapType = sceneProperties[3][2];\n            float toneMapParam = sceneProperties[3][3];\n            vec3 toneMapped = toneMap(vec3(unitR, unitG, unitB), toneMapType, toneMapParam);\n            return vec4(toneMapped, 1.0);\n        }\n        \n        void main () {\n            vec3 emissiveColor = fromSrgb(texture2D(colorTexture, interpolatedUv).rgb) * backlight;\n            gl_FragColor = toSrgb(emissiveColor, sceneProperties);\n        }\n    ",attributes:{},uniforms:{backlight:"cN",colorTexture:"cg",sceneProperties:"g"}},Ic=s(function(e,n){switch(n.$){case 0:return z(Hn,e,n);case 1:return z(jn,e,n);case 2:return z(On,e,n);case 3:return z(Yn,e,n);case 4:return z(Un,e,n);case 5:return z(Wn,e,n);case 6:return z(Gn,e,n);case 7:return z(Xn,e,n);default:return function(e){var n=e.sampleAlphaToCoverage;n.toggle=e.toggle,n.enabled||(e.gl.enable(e.gl.SAMPLE_ALPHA_TO_COVERAGE),n.enabled=!0)}(e)}}),Hc=In,jc=R(function(e,n,r,t,o,a,i){for(;;){if(!i.b)return{eC:n,eD:t,eE:a,eF:e,eG:r,eH:o};var c=i.a,l=i.b,u=c.b4,f=c.b6,c=c.b8;e=z($a,u,e),n=z(T,u,n),r=z($a,f,r),t=z(T,f,t),o=z($a,c,o),a=z(T,c,a),i=l}}),Oc=s(function(e,n){var r=e.b4,t=e.b6,e=e.b8;return j(jc,r,r,t,t,e,e,n)}),Yc={src:"\n        precision highp float;\n        \n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 lights12;\n        uniform highp mat4 lights34;\n        uniform highp mat4 lights56;\n        uniform highp mat4 lights78;\n        uniform lowp vec4 enabledLights;\n        uniform lowp vec3 materialColor;\n        uniform highp mat4 viewMatrix;\n        \n        varying highp vec3 interpolatedPosition;\n        varying highp vec3 interpolatedNormal;\n        \n        const lowp float kPerspectiveProjection = 0.0;\n        const lowp float kOrthographicProjection = 1.0;\n        const lowp float kDirectionalLight = 1.0;\n        const lowp float kPointLight = 2.0;\n        const highp float kPi = 3.14159265359;\n        const lowp float kDisabledLight = 0.0;\n        const lowp float kSoftLighting = 3.0;\n        \n        float getNormalSign() {\n            return 2.0 * float(gl_FrontFacing) - 1.0;\n        }\n        \n        vec3 getDirectionToCamera(vec3 surfacePosition, mat4 sceneProperties) {\n            float projectionType = sceneProperties[1].w;\n            if (projectionType == kPerspectiveProjection) {\n                vec3 cameraPoint = sceneProperties[1].xyz;\n                return normalize(cameraPoint - surfacePosition);\n            } else if (projectionType == kOrthographicProjection) {\n                return sceneProperties[1].xyz;\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        void getDirectionToLightAndNormalIlluminance(\n            vec4 xyz_type,\n            vec4 rgb_parameter,\n            vec3 surfacePosition,\n            out vec3 directionToLight,\n            out vec3 normalIlluminance\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDirectionalLight) {\n                directionToLight = xyz_type.xyz;\n                normalIlluminance = rgb_parameter.rgb;\n            } else if (lightType == kPointLight) {\n                vec3 lightPosition = xyz_type.xyz;\n                vec3 displacement = lightPosition - surfacePosition;\n                float distance = length(displacement);\n                directionToLight = displacement / distance;\n                normalIlluminance = rgb_parameter.rgb / (4.0 * kPi * distance * distance);\n            }\n        }\n        \n        float positiveDotProduct(vec3 v1, vec3 v2) {\n            return clamp(dot(v1, v2), 0.0, 1.0);\n        }\n        \n        vec3 softLightingLuminance(\n            vec3 aboveLuminance,\n            vec3 belowLuminance,\n            vec3 localUpDirection,\n            vec3 localLightDirection\n        ) {\n            float sinElevation = dot(localLightDirection, localUpDirection);\n            float t = (sinElevation + 1.0) / 2.0;\n            return aboveLuminance * t + belowLuminance * (1.0 - t);\n        }\n        \n        vec3 lambertianLight(\n            vec3 surfacePosition,\n            vec3 surfaceNormal,\n            vec3 materialColor,\n            vec4 xyz_type,\n            vec4 rgb_parameter\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDisabledLight) {\n                return vec3(0.0, 0.0, 0.0);\n            } else if (lightType == kSoftLighting) {\n                vec3 upDirection = xyz_type.xyz;\n                vec3 aboveLuminance = rgb_parameter.rgb;\n                vec3 belowLuminance = rgb_parameter.a * aboveLuminance;\n                vec3 luminance = softLightingLuminance(aboveLuminance, belowLuminance, upDirection, surfaceNormal);\n                return luminance * materialColor;\n            }\n        \n            vec3 directionToLight = vec3(0.0, 0.0, 0.0);\n            vec3 normalIlluminance = vec3(0.0, 0.0, 0.0);\n            getDirectionToLightAndNormalIlluminance(\n                xyz_type,\n                rgb_parameter,\n                surfacePosition,\n                directionToLight,\n                normalIlluminance\n            );\n        \n            float dotNL = positiveDotProduct(directionToLight, surfaceNormal);\n            return (normalIlluminance * dotNL) * (materialColor / kPi);\n        }\n        \n        vec3 lambertianLighting(\n            vec3 surfacePosition,\n            vec3 surfaceNormal,\n            vec3 materialColor,\n            mat4 lights12,\n            mat4 lights34,\n            mat4 lights56,\n            mat4 lights78,\n            vec4 enabledLights\n        ) {\n            vec3 litColor1 = enabledLights[0] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights12[0], lights12[1]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor2 = enabledLights[1] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights12[2], lights12[3]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor3 = enabledLights[2] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights34[0], lights34[1]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor4 = enabledLights[3] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights34[2], lights34[3]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor5 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights56[0], lights56[1]);\n            vec3 litColor6 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights56[2], lights56[3]);\n            vec3 litColor7 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights78[0], lights78[1]);\n            vec3 litColor8 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights78[2], lights78[3]);\n            return litColor1 + litColor2 + litColor3 + litColor4 + litColor5 + litColor6 + litColor7 + litColor8;\n        }\n        \n        float gammaCorrect(float u) {\n            if (u <= 0.0031308) {\n                return 12.92 * u;\n            } else {\n                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;\n            }\n        }\n        \n        vec3 gammaCorrectedColor(vec3 color) {\n            float red = gammaCorrect(color.r);\n            float green = gammaCorrect(color.g);\n            float blue = gammaCorrect(color.b);\n            return vec3(red, green, blue);\n        }\n        \n        vec3 reinhardLuminanceToneMap(vec3 color) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scale = 1.0 / (1.0 + luminance);\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 reinhardPerChannelToneMap(vec3 color) {\n            return gammaCorrectedColor(color / (color + 1.0));\n        }\n        \n        float extendedReinhardToneMap(float x, float xMax) {\n            return x * (1.0 + (x / (xMax * xMax))) / (1.0 + x);\n        }\n        \n        vec3 extendedReinhardLuminanceToneMap(vec3 color, float overexposureLimit) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scaledLuminance = extendedReinhardToneMap(luminance, overexposureLimit);\n            float scale = scaledLuminance / luminance;\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 extendedReinhardPerChannelToneMap(vec3 color, float overexposureLimit) {\n            float red = extendedReinhardToneMap(color.r, overexposureLimit);\n            float green = extendedReinhardToneMap(color.g, overexposureLimit);\n            float blue = extendedReinhardToneMap(color.b, overexposureLimit);\n            return gammaCorrectedColor(vec3(red, green, blue));\n        }\n        \n        vec3 hableFilmicHelper(vec3 color) {\n            float a = 0.15;\n            float b = 0.5;\n            float c = 0.1;\n            float d = 0.2;\n            float e = 0.02;\n            float f = 0.3;\n            return (color * (a * color + c * b) + d * e) / (color * (a * color + b) + d * f) - e / f;\n        }\n        \n        vec3 hableFilmicToneMap(vec3 color) {\n            float exposureBias = 2.0;\n            vec3 unscaled = hableFilmicHelper(exposureBias * color);\n            vec3 scale = 1.0 / hableFilmicHelper(vec3(11.2));\n            return gammaCorrectedColor(scale * unscaled);\n        }\n        \n        vec3 toneMap(vec3 color, float toneMapType, float toneMapParam) {\n            if (toneMapType == 0.0) {\n                return gammaCorrectedColor(color);\n            } else if (toneMapType == 1.0) {\n                return reinhardLuminanceToneMap(color);\n            } else if (toneMapType == 2.0) {\n                return reinhardPerChannelToneMap(color);\n            } else if (toneMapType == 3.0) {\n                return extendedReinhardLuminanceToneMap(color, toneMapParam);\n            } else if (toneMapType == 4.0) {\n                return extendedReinhardPerChannelToneMap(color, toneMapParam);\n            } else if (toneMapType == 5.0) {\n                return hableFilmicToneMap(color);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {\n            vec3 referenceWhite = sceneProperties[2].rgb;\n            float unitR = linearColor.r / referenceWhite.r;\n            float unitG = linearColor.g / referenceWhite.g;\n            float unitB = linearColor.b / referenceWhite.b;\n            float toneMapType = sceneProperties[3][2];\n            float toneMapParam = sceneProperties[3][3];\n            vec3 toneMapped = toneMap(vec3(unitR, unitG, unitB), toneMapType, toneMapParam);\n            return vec4(toneMapped, 1.0);\n        }\n        \n        void main() {\n            vec3 normalDirection = normalize(interpolatedNormal) * getNormalSign();\n            vec3 directionToCamera = getDirectionToCamera(interpolatedPosition, sceneProperties);\n        \n            vec3 linearColor = lambertianLighting(\n                interpolatedPosition,\n                normalDirection,\n                materialColor,\n                lights12,\n                lights34,\n                lights56,\n                lights78,\n                enabledLights\n            );\n        \n            gl_FragColor = toSrgb(linearColor, sceneProperties);\n        }\n    ",attributes:{},uniforms:{enabledLights:"ab",lights12:"bO",lights34:"cp",lights56:"cq",lights78:"cr",materialColor:"c8",sceneProperties:"g",viewMatrix:"h"}},Uc={src:"\n        precision highp float;\n        \n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 lights12;\n        uniform highp mat4 lights34;\n        uniform highp mat4 lights56;\n        uniform highp mat4 lights78;\n        uniform lowp vec4 enabledLights;\n        uniform mediump sampler2D materialColorTexture;\n        uniform mediump sampler2D normalMapTexture;\n        uniform lowp float useNormalMap;\n        uniform highp mat4 viewMatrix;\n        \n        varying highp vec3 interpolatedPosition;\n        varying highp vec3 interpolatedNormal;\n        varying mediump vec2 interpolatedUv;\n        varying highp vec3 interpolatedTangent;\n        \n        const lowp float kPerspectiveProjection = 0.0;\n        const lowp float kOrthographicProjection = 1.0;\n        const lowp float kDirectionalLight = 1.0;\n        const lowp float kPointLight = 2.0;\n        const highp float kPi = 3.14159265359;\n        const lowp float kDisabledLight = 0.0;\n        const lowp float kSoftLighting = 3.0;\n        \n        vec3 getLocalNormal(sampler2D normalMap, float useNormalMap, vec2 uv) {\n            vec3 rgb = useNormalMap * texture2D(normalMap, uv).rgb + (1.0 - useNormalMap) * vec3(0.5, 0.5, 1.0);\n            float x = 2.0 * (rgb.r - 0.5);\n            float y = 2.0 * (rgb.g - 0.5);\n            float z = 2.0 * (rgb.b - 0.5);\n            return normalize(vec3(-x, -y, z));\n        }\n        \n        float getNormalSign() {\n            return 2.0 * float(gl_FrontFacing) - 1.0;\n        }\n        \n        vec3 getMappedNormal(vec3 normal, vec3 tangent, float normalSign, vec3 localNormal) {\n            vec3 bitangent = cross(normal, tangent) * normalSign;\n            return normalize(localNormal.x * tangent + localNormal.y * bitangent + localNormal.z * normal);\n        }\n        \n        vec3 getDirectionToCamera(vec3 surfacePosition, mat4 sceneProperties) {\n            float projectionType = sceneProperties[1].w;\n            if (projectionType == kPerspectiveProjection) {\n                vec3 cameraPoint = sceneProperties[1].xyz;\n                return normalize(cameraPoint - surfacePosition);\n            } else if (projectionType == kOrthographicProjection) {\n                return sceneProperties[1].xyz;\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        void getDirectionToLightAndNormalIlluminance(\n            vec4 xyz_type,\n            vec4 rgb_parameter,\n            vec3 surfacePosition,\n            out vec3 directionToLight,\n            out vec3 normalIlluminance\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDirectionalLight) {\n                directionToLight = xyz_type.xyz;\n                normalIlluminance = rgb_parameter.rgb;\n            } else if (lightType == kPointLight) {\n                vec3 lightPosition = xyz_type.xyz;\n                vec3 displacement = lightPosition - surfacePosition;\n                float distance = length(displacement);\n                directionToLight = displacement / distance;\n                normalIlluminance = rgb_parameter.rgb / (4.0 * kPi * distance * distance);\n            }\n        }\n        \n        float positiveDotProduct(vec3 v1, vec3 v2) {\n            return clamp(dot(v1, v2), 0.0, 1.0);\n        }\n        \n        vec3 softLightingLuminance(\n            vec3 aboveLuminance,\n            vec3 belowLuminance,\n            vec3 localUpDirection,\n            vec3 localLightDirection\n        ) {\n            float sinElevation = dot(localLightDirection, localUpDirection);\n            float t = (sinElevation + 1.0) / 2.0;\n            return aboveLuminance * t + belowLuminance * (1.0 - t);\n        }\n        \n        vec3 lambertianLight(\n            vec3 surfacePosition,\n            vec3 surfaceNormal,\n            vec3 materialColor,\n            vec4 xyz_type,\n            vec4 rgb_parameter\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDisabledLight) {\n                return vec3(0.0, 0.0, 0.0);\n            } else if (lightType == kSoftLighting) {\n                vec3 upDirection = xyz_type.xyz;\n                vec3 aboveLuminance = rgb_parameter.rgb;\n                vec3 belowLuminance = rgb_parameter.a * aboveLuminance;\n                vec3 luminance = softLightingLuminance(aboveLuminance, belowLuminance, upDirection, surfaceNormal);\n                return luminance * materialColor;\n            }\n        \n            vec3 directionToLight = vec3(0.0, 0.0, 0.0);\n            vec3 normalIlluminance = vec3(0.0, 0.0, 0.0);\n            getDirectionToLightAndNormalIlluminance(\n                xyz_type,\n                rgb_parameter,\n                surfacePosition,\n                directionToLight,\n                normalIlluminance\n            );\n        \n            float dotNL = positiveDotProduct(directionToLight, surfaceNormal);\n            return (normalIlluminance * dotNL) * (materialColor / kPi);\n        }\n        \n        vec3 lambertianLighting(\n            vec3 surfacePosition,\n            vec3 surfaceNormal,\n            vec3 materialColor,\n            mat4 lights12,\n            mat4 lights34,\n            mat4 lights56,\n            mat4 lights78,\n            vec4 enabledLights\n        ) {\n            vec3 litColor1 = enabledLights[0] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights12[0], lights12[1]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor2 = enabledLights[1] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights12[2], lights12[3]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor3 = enabledLights[2] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights34[0], lights34[1]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor4 = enabledLights[3] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights34[2], lights34[3]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor5 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights56[0], lights56[1]);\n            vec3 litColor6 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights56[2], lights56[3]);\n            vec3 litColor7 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights78[0], lights78[1]);\n            vec3 litColor8 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights78[2], lights78[3]);\n            return litColor1 + litColor2 + litColor3 + litColor4 + litColor5 + litColor6 + litColor7 + litColor8;\n        }\n        \n        float inverseGamma(float u) {\n            if (u <= 0.04045) {\n                return clamp(u / 12.92, 0.0, 1.0);\n            } else {\n                return clamp(pow((u + 0.055) / 1.055, 2.4), 0.0, 1.0);\n            }\n        }\n        \n        vec3 fromSrgb(vec3 srgbColor) {\n            return vec3(\n                inverseGamma(srgbColor.r),\n                inverseGamma(srgbColor.g),\n                inverseGamma(srgbColor.b)\n            );\n        }\n        \n        float gammaCorrect(float u) {\n            if (u <= 0.0031308) {\n                return 12.92 * u;\n            } else {\n                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;\n            }\n        }\n        \n        vec3 gammaCorrectedColor(vec3 color) {\n            float red = gammaCorrect(color.r);\n            float green = gammaCorrect(color.g);\n            float blue = gammaCorrect(color.b);\n            return vec3(red, green, blue);\n        }\n        \n        vec3 reinhardLuminanceToneMap(vec3 color) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scale = 1.0 / (1.0 + luminance);\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 reinhardPerChannelToneMap(vec3 color) {\n            return gammaCorrectedColor(color / (color + 1.0));\n        }\n        \n        float extendedReinhardToneMap(float x, float xMax) {\n            return x * (1.0 + (x / (xMax * xMax))) / (1.0 + x);\n        }\n        \n        vec3 extendedReinhardLuminanceToneMap(vec3 color, float overexposureLimit) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scaledLuminance = extendedReinhardToneMap(luminance, overexposureLimit);\n            float scale = scaledLuminance / luminance;\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 extendedReinhardPerChannelToneMap(vec3 color, float overexposureLimit) {\n            float red = extendedReinhardToneMap(color.r, overexposureLimit);\n            float green = extendedReinhardToneMap(color.g, overexposureLimit);\n            float blue = extendedReinhardToneMap(color.b, overexposureLimit);\n            return gammaCorrectedColor(vec3(red, green, blue));\n        }\n        \n        vec3 hableFilmicHelper(vec3 color) {\n            float a = 0.15;\n            float b = 0.5;\n            float c = 0.1;\n            float d = 0.2;\n            float e = 0.02;\n            float f = 0.3;\n            return (color * (a * color + c * b) + d * e) / (color * (a * color + b) + d * f) - e / f;\n        }\n        \n        vec3 hableFilmicToneMap(vec3 color) {\n            float exposureBias = 2.0;\n            vec3 unscaled = hableFilmicHelper(exposureBias * color);\n            vec3 scale = 1.0 / hableFilmicHelper(vec3(11.2));\n            return gammaCorrectedColor(scale * unscaled);\n        }\n        \n        vec3 toneMap(vec3 color, float toneMapType, float toneMapParam) {\n            if (toneMapType == 0.0) {\n                return gammaCorrectedColor(color);\n            } else if (toneMapType == 1.0) {\n                return reinhardLuminanceToneMap(color);\n            } else if (toneMapType == 2.0) {\n                return reinhardPerChannelToneMap(color);\n            } else if (toneMapType == 3.0) {\n                return extendedReinhardLuminanceToneMap(color, toneMapParam);\n            } else if (toneMapType == 4.0) {\n                return extendedReinhardPerChannelToneMap(color, toneMapParam);\n            } else if (toneMapType == 5.0) {\n                return hableFilmicToneMap(color);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {\n            vec3 referenceWhite = sceneProperties[2].rgb;\n            float unitR = linearColor.r / referenceWhite.r;\n            float unitG = linearColor.g / referenceWhite.g;\n            float unitB = linearColor.b / referenceWhite.b;\n            float toneMapType = sceneProperties[3][2];\n            float toneMapParam = sceneProperties[3][3];\n            vec3 toneMapped = toneMap(vec3(unitR, unitG, unitB), toneMapType, toneMapParam);\n            return vec4(toneMapped, 1.0);\n        }\n        \n        void main() {\n            vec3 localNormal = getLocalNormal(normalMapTexture, useNormalMap, interpolatedUv);\n            float normalSign = getNormalSign();\n            vec3 originalNormal = normalize(interpolatedNormal) * normalSign;\n            vec3 normalDirection = getMappedNormal(originalNormal, interpolatedTangent, normalSign, localNormal);\n            vec3 directionToCamera = getDirectionToCamera(interpolatedPosition, sceneProperties);\n            vec3 materialColor = fromSrgb(texture2D(materialColorTexture, interpolatedUv).rgb);\n        \n            vec3 linearColor = lambertianLighting(\n                interpolatedPosition,\n                normalDirection,\n                materialColor,\n                lights12,\n                lights34,\n                lights56,\n                lights78,\n                enabledLights\n            );\n        \n            gl_FragColor = toSrgb(linearColor, sceneProperties);\n        }\n    ",attributes:{},uniforms:{enabledLights:"ab",lights12:"bO",lights34:"cp",lights56:"cq",lights78:"cr",materialColorTexture:"c9",normalMapTexture:"bo",sceneProperties:"g",useNormalMap:"bu",viewMatrix:"h"}},Wc=Yr(1029),Gc=Yr(1028),Xc=b(function(e,n,r){return 1===n?z(x,e?Wc:Gc,r):r}),Jc={src:"\n        precision highp float;\n        \n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 lights12;\n        uniform highp mat4 lights34;\n        uniform highp mat4 lights56;\n        uniform highp mat4 lights78;\n        uniform lowp vec4 enabledLights;\n        uniform lowp vec3 baseColor;\n        uniform lowp float roughness;\n        uniform lowp float metallic;\n        \n        varying highp vec3 interpolatedPosition;\n        varying highp vec3 interpolatedNormal;\n        \n        const lowp float kPerspectiveProjection = 0.0;\n        const lowp float kOrthographicProjection = 1.0;\n        const lowp float kDirectionalLight = 1.0;\n        const lowp float kPointLight = 2.0;\n        const highp float kPi = 3.14159265359;\n        const mediump float kMediumpFloatMax = 65504.0;\n        const lowp float kDisabledLight = 0.0;\n        const lowp float kSoftLighting = 3.0;\n        \n        float getNormalSign() {\n            return 2.0 * float(gl_FrontFacing) - 1.0;\n        }\n        \n        vec3 getDirectionToCamera(vec3 surfacePosition, mat4 sceneProperties) {\n            float projectionType = sceneProperties[1].w;\n            if (projectionType == kPerspectiveProjection) {\n                vec3 cameraPoint = sceneProperties[1].xyz;\n                return normalize(cameraPoint - surfacePosition);\n            } else if (projectionType == kOrthographicProjection) {\n                return sceneProperties[1].xyz;\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        void getDirectionToLightAndNormalIlluminance(\n            vec4 xyz_type,\n            vec4 rgb_parameter,\n            vec3 surfacePosition,\n            out vec3 directionToLight,\n            out vec3 normalIlluminance\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDirectionalLight) {\n                directionToLight = xyz_type.xyz;\n                normalIlluminance = rgb_parameter.rgb;\n            } else if (lightType == kPointLight) {\n                vec3 lightPosition = xyz_type.xyz;\n                vec3 displacement = lightPosition - surfacePosition;\n                float distance = length(displacement);\n                directionToLight = displacement / distance;\n                normalIlluminance = rgb_parameter.rgb / (4.0 * kPi * distance * distance);\n            }\n        }\n        \n        float positiveDotProduct(vec3 v1, vec3 v2) {\n            return clamp(dot(v1, v2), 0.0, 1.0);\n        }\n        \n        // Adapted from https://google.github.io/filament/Filament.md.html#materialsystem/specularbrdf/normaldistributionfunction(speculard)\n        float specularD(float alpha, float dotNH, vec3 normalDirection, vec3 halfDirection) {\n            vec3 crossNH = cross(normalDirection, halfDirection);\n            float a = dotNH * alpha;\n            float k = alpha / (dot(crossNH, crossNH) + a * a);\n            float d = k * k * (1.0 / kPi);\n            return min(d, kMediumpFloatMax);\n        }\n        \n        float safeQuotient(float numerator, float denominator) {\n            if (denominator == 0.0) {\n                return 0.0;\n            } else {\n                return numerator / denominator;\n            }\n        }\n        \n        float g1(float dotNV, float alphaSquared) {\n            return safeQuotient(2.0 * dotNV, dotNV + sqrt(alphaSquared + (1.0 - alphaSquared) * dotNV * dotNV));\n        }\n        \n        float specularG(float dotNL, float dotNV, float alphaSquared) {\n            return g1(dotNV, alphaSquared) * g1(dotNL, alphaSquared);\n        }\n        \n        vec3 fresnelColor(vec3 specularBaseColor, float dotVH) {\n            vec3 one = vec3(1.0, 1.0, 1.0);\n            float scale = exp2((-5.55473 * dotVH - 6.98316) * dotVH);\n            return specularBaseColor + (one - specularBaseColor) * scale;\n        }\n        \n        vec3 brdf(vec3 normalDirection, vec3 directionToCamera, vec3 directionToLight, float alpha, float dotNV, float dotNL, vec3 specularBaseColor, vec3 normalIlluminance) {\n            vec3 halfDirection = normalize(directionToCamera + directionToLight);\n            float dotVH = positiveDotProduct(directionToCamera, halfDirection);\n            float dotNH = positiveDotProduct(normalDirection, halfDirection);\n            float dotNHSquared = dotNH * dotNH;\n        \n            float d = specularD(alpha, dotNH, normalDirection, halfDirection);\n            float g = specularG(dotNL, dotNV, alpha * alpha);\n            vec3 f = fresnelColor(specularBaseColor, dotVH);\n            return safeQuotient(d * g, 4.0 * dotNL * dotNV) * f;\n        }\n        \n        vec3 sampleFacetNormal(vec3 vH, vec3 vT1, vec3 vT2, float s, float alpha) {\n            float t2 = (1.0 - s);\n            vec3 vNh = t2 * vT2 + sqrt(max(0.0, 1.0 - t2 * t2)) * vH;\n            return normalize(vec3(alpha * vNh.x, alpha * vNh.y, max(0.0, vNh.z)));\n        }\n        \n        vec3 softLightingLuminance(\n            vec3 aboveLuminance,\n            vec3 belowLuminance,\n            vec3 localUpDirection,\n            vec3 localLightDirection\n        ) {\n            float sinElevation = dot(localLightDirection, localUpDirection);\n            float t = (sinElevation + 1.0) / 2.0;\n            return aboveLuminance * t + belowLuminance * (1.0 - t);\n        }\n        \n        vec3 softLightingSpecularSample(\n            vec3 aboveLuminance,\n            vec3 belowLuminance,\n            vec3 localUpDirection,\n            vec3 localViewDirection,\n            vec3 localLightDirection,\n            vec3 localHalfDirection,\n            float alphaSquared,\n            vec3 specularBaseColor\n        ) {\n            vec3 luminance = softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection);\n            float dotVH = positiveDotProduct(localViewDirection, localHalfDirection);\n            float dotNL = localLightDirection.z;\n            return luminance * (fresnelColor(specularBaseColor, dotVH) * g1(dotNL, alphaSquared));\n        }\n        \n        vec3 softLighting(\n            vec3 normalDirection,\n            vec3 diffuseBaseColor,\n            vec3 specularBaseColor,\n            float alpha,\n            vec3 directionToCamera,\n            vec3 viewY,\n            vec4 xyz_type,\n            vec4 rgb_parameter\n        ) {\n            float alphaSquared = alpha * alpha;\n            vec3 upDirection = xyz_type.xyz;\n            vec3 luminanceAbove = rgb_parameter.rgb;\n            vec3 luminanceBelow = rgb_parameter.a * luminanceAbove;\n            vec3 crossProduct = cross(normalDirection, directionToCamera);\n            float crossMagnitude = length(crossProduct);\n            vec3 xDirection = vec3(0.0, 0.0, 0.0);\n            vec3 yDirection = vec3(0.0, 0.0, 0.0);\n            if (crossMagnitude > 1.0e-6) {\n                yDirection = (1.0 / crossMagnitude) * crossProduct;\n                xDirection = cross(yDirection, normalDirection);\n            } else {\n                vec3 viewY = vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]);\n                xDirection = normalize(cross(viewY, normalDirection));\n                yDirection = cross(normalDirection, xDirection);\n            }\n            float localViewX = dot(directionToCamera, xDirection);\n            float localViewZ = dot(directionToCamera, normalDirection);\n            vec3 localViewDirection = vec3(localViewX, 0, localViewZ);\n            float localUpX = dot(upDirection, xDirection);\n            float localUpY = dot(upDirection, yDirection);\n            float localUpZ = dot(upDirection, normalDirection);\n            vec3 localUpDirection = vec3(localUpX, localUpY, localUpZ);\n        \n            vec3 vH = normalize(vec3(alpha * localViewX, 0.0, localViewZ));\n            vec3 vT1 = vec3(0.0, 1.0, 0.0);\n            vec3 vT2 = cross(vH, vT1);\n            float s = 0.5 * (1.0 + vH.z);\n            \n            vec3 localHalfDirection = sampleFacetNormal(vH, vT1, vT2, s, alpha);\n            vec3 localLightDirection = vec3(0.0, 0.0, 0.0);\n            \n            localLightDirection = -reflect(localViewDirection, localHalfDirection);\n            vec3 specular = softLightingSpecularSample(luminanceAbove, luminanceBelow, localUpDirection, localViewDirection, localLightDirection, localHalfDirection, alphaSquared, specularBaseColor);\n            \n            localLightDirection = vec3(0.000000, 0.000000, 1.000000);\n            vec3 diffuse = softLightingLuminance(luminanceAbove, luminanceBelow, localUpDirection, localLightDirection) * localLightDirection.z;\n            \n            return specular + diffuse * diffuseBaseColor;\n        }\n        \n        vec3 physicalLight(\n            vec4 xyz_type,\n            vec4 rgb_parameter,\n            vec3 surfacePosition,\n            vec3 normalDirection,\n            vec3 directionToCamera,\n            vec3 viewY,\n            float dotNV,\n            vec3 diffuseBaseColor,\n            vec3 specularBaseColor,\n            float alpha\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDisabledLight) {\n                return vec3(0.0, 0.0, 0.0);\n            } else if (lightType == kSoftLighting) {\n                return softLighting(normalDirection, diffuseBaseColor, specularBaseColor, alpha, directionToCamera, viewY, xyz_type, rgb_parameter);\n            }\n        \n            vec3 directionToLight = vec3(0.0, 0.0, 0.0);\n            vec3 normalIlluminance = vec3(0.0, 0.0, 0.0);\n            getDirectionToLightAndNormalIlluminance(xyz_type, rgb_parameter, surfacePosition, directionToLight, normalIlluminance);\n        \n            float dotNL = positiveDotProduct(normalDirection, directionToLight);\n            vec3 specularColor = brdf(normalDirection, directionToCamera, directionToLight, alpha, dotNV, dotNL, specularBaseColor, normalIlluminance);\n            return (normalIlluminance * dotNL) * ((diffuseBaseColor / kPi) + specularColor);\n        }\n        \n        vec3 physicalLighting(\n            vec3 surfacePosition,\n            vec3 surfaceNormal,\n            vec3 baseColor,\n            vec3 directionToCamera,\n            mat4 viewMatrix,\n            float roughness,\n            float metallic,\n            mat4 lights12,\n            mat4 lights34,\n            mat4 lights56,\n            mat4 lights78,\n            vec4 enabledLights\n        ) {\n            float dotNV = positiveDotProduct(surfaceNormal, directionToCamera);\n            float alpha = roughness * roughness;\n            float nonmetallic = 1.0 - metallic;\n            vec3 diffuseBaseColor = nonmetallic * 0.96 * baseColor;\n            vec3 specularBaseColor = nonmetallic * 0.04 * vec3(1.0, 1.0, 1.0) + metallic * baseColor;\n            vec3 viewY = vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]);\n        \n            vec3 litColor1 = enabledLights[0] == 1.0 ? physicalLight(lights12[0], lights12[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor2 = enabledLights[1] == 1.0 ? physicalLight(lights12[2], lights12[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor3 = enabledLights[2] == 1.0 ? physicalLight(lights34[0], lights34[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor4 = enabledLights[3] == 1.0 ? physicalLight(lights34[2], lights34[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor5 = physicalLight(lights56[0], lights56[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            vec3 litColor6 = physicalLight(lights56[2], lights56[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            vec3 litColor7 = physicalLight(lights78[0], lights78[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            vec3 litColor8 = physicalLight(lights78[2], lights78[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            return litColor1 + litColor2 + litColor3 + litColor4 + litColor5 + litColor6 + litColor7 + litColor8;\n        }\n        \n        float gammaCorrect(float u) {\n            if (u <= 0.0031308) {\n                return 12.92 * u;\n            } else {\n                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;\n            }\n        }\n        \n        vec3 gammaCorrectedColor(vec3 color) {\n            float red = gammaCorrect(color.r);\n            float green = gammaCorrect(color.g);\n            float blue = gammaCorrect(color.b);\n            return vec3(red, green, blue);\n        }\n        \n        vec3 reinhardLuminanceToneMap(vec3 color) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scale = 1.0 / (1.0 + luminance);\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 reinhardPerChannelToneMap(vec3 color) {\n            return gammaCorrectedColor(color / (color + 1.0));\n        }\n        \n        float extendedReinhardToneMap(float x, float xMax) {\n            return x * (1.0 + (x / (xMax * xMax))) / (1.0 + x);\n        }\n        \n        vec3 extendedReinhardLuminanceToneMap(vec3 color, float overexposureLimit) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scaledLuminance = extendedReinhardToneMap(luminance, overexposureLimit);\n            float scale = scaledLuminance / luminance;\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 extendedReinhardPerChannelToneMap(vec3 color, float overexposureLimit) {\n            float red = extendedReinhardToneMap(color.r, overexposureLimit);\n            float green = extendedReinhardToneMap(color.g, overexposureLimit);\n            float blue = extendedReinhardToneMap(color.b, overexposureLimit);\n            return gammaCorrectedColor(vec3(red, green, blue));\n        }\n        \n        vec3 hableFilmicHelper(vec3 color) {\n            float a = 0.15;\n            float b = 0.5;\n            float c = 0.1;\n            float d = 0.2;\n            float e = 0.02;\n            float f = 0.3;\n            return (color * (a * color + c * b) + d * e) / (color * (a * color + b) + d * f) - e / f;\n        }\n        \n        vec3 hableFilmicToneMap(vec3 color) {\n            float exposureBias = 2.0;\n            vec3 unscaled = hableFilmicHelper(exposureBias * color);\n            vec3 scale = 1.0 / hableFilmicHelper(vec3(11.2));\n            return gammaCorrectedColor(scale * unscaled);\n        }\n        \n        vec3 toneMap(vec3 color, float toneMapType, float toneMapParam) {\n            if (toneMapType == 0.0) {\n                return gammaCorrectedColor(color);\n            } else if (toneMapType == 1.0) {\n                return reinhardLuminanceToneMap(color);\n            } else if (toneMapType == 2.0) {\n                return reinhardPerChannelToneMap(color);\n            } else if (toneMapType == 3.0) {\n                return extendedReinhardLuminanceToneMap(color, toneMapParam);\n            } else if (toneMapType == 4.0) {\n                return extendedReinhardPerChannelToneMap(color, toneMapParam);\n            } else if (toneMapType == 5.0) {\n                return hableFilmicToneMap(color);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {\n            vec3 referenceWhite = sceneProperties[2].rgb;\n            float unitR = linearColor.r / referenceWhite.r;\n            float unitG = linearColor.g / referenceWhite.g;\n            float unitB = linearColor.b / referenceWhite.b;\n            float toneMapType = sceneProperties[3][2];\n            float toneMapParam = sceneProperties[3][3];\n            vec3 toneMapped = toneMap(vec3(unitR, unitG, unitB), toneMapType, toneMapParam);\n            return vec4(toneMapped, 1.0);\n        }\n        \n        void main() {\n            vec3 normalDirection = normalize(interpolatedNormal) * getNormalSign();\n            vec3 directionToCamera = getDirectionToCamera(interpolatedPosition, sceneProperties);\n        \n            vec3 linearColor = physicalLighting(\n                interpolatedPosition,\n                normalDirection,\n                baseColor,\n                directionToCamera,\n                viewMatrix,\n                roughness,\n                metallic,\n                lights12,\n                lights34,\n                lights56,\n                lights78,\n                enabledLights\n            );\n        \n            gl_FragColor = toSrgb(linearColor, sceneProperties);\n        }\n    ",attributes:{},uniforms:{baseColor:"cP",enabledLights:"ab",lights12:"bO",lights34:"cp",lights56:"cq",lights78:"cr",metallic:"db",roughness:"dy",sceneProperties:"g",viewMatrix:"h"}},Qc={src:"\n        precision highp float;\n        \n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 lights12;\n        uniform highp mat4 lights34;\n        uniform highp mat4 lights56;\n        uniform highp mat4 lights78;\n        uniform lowp vec4 enabledLights;\n        uniform mediump sampler2D baseColorTexture;\n        uniform lowp vec4 constantBaseColor;\n        uniform mediump sampler2D roughnessTexture;\n        uniform lowp vec2 constantRoughness;\n        uniform mediump sampler2D metallicTexture;\n        uniform lowp vec2 constantMetallic;\n        uniform mediump sampler2D normalMapTexture;\n        uniform lowp float useNormalMap;\n        \n        varying highp vec3 interpolatedPosition;\n        varying highp vec3 interpolatedNormal;\n        varying mediump vec2 interpolatedUv;\n        varying highp vec3 interpolatedTangent;\n        \n        const lowp float kPerspectiveProjection = 0.0;\n        const lowp float kOrthographicProjection = 1.0;\n        const lowp float kDirectionalLight = 1.0;\n        const lowp float kPointLight = 2.0;\n        const highp float kPi = 3.14159265359;\n        const mediump float kMediumpFloatMax = 65504.0;\n        const lowp float kDisabledLight = 0.0;\n        const lowp float kSoftLighting = 3.0;\n        \n        float getFloatValue(sampler2D texture, vec2 uv, vec2 constantValue) {\n            if (constantValue.y == 1.0) {\n                return constantValue.x;\n            } else {\n                vec4 textureColor = texture2D(texture, uv);\n                return dot(textureColor, vec4(0.2126, 0.7152, 0.0722, 0.0));\n            }\n        }\n        \n        vec3 getLocalNormal(sampler2D normalMap, float useNormalMap, vec2 uv) {\n            vec3 rgb = useNormalMap * texture2D(normalMap, uv).rgb + (1.0 - useNormalMap) * vec3(0.5, 0.5, 1.0);\n            float x = 2.0 * (rgb.r - 0.5);\n            float y = 2.0 * (rgb.g - 0.5);\n            float z = 2.0 * (rgb.b - 0.5);\n            return normalize(vec3(-x, -y, z));\n        }\n        \n        float getNormalSign() {\n            return 2.0 * float(gl_FrontFacing) - 1.0;\n        }\n        \n        vec3 getMappedNormal(vec3 normal, vec3 tangent, float normalSign, vec3 localNormal) {\n            vec3 bitangent = cross(normal, tangent) * normalSign;\n            return normalize(localNormal.x * tangent + localNormal.y * bitangent + localNormal.z * normal);\n        }\n        \n        vec3 getDirectionToCamera(vec3 surfacePosition, mat4 sceneProperties) {\n            float projectionType = sceneProperties[1].w;\n            if (projectionType == kPerspectiveProjection) {\n                vec3 cameraPoint = sceneProperties[1].xyz;\n                return normalize(cameraPoint - surfacePosition);\n            } else if (projectionType == kOrthographicProjection) {\n                return sceneProperties[1].xyz;\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        void getDirectionToLightAndNormalIlluminance(\n            vec4 xyz_type,\n            vec4 rgb_parameter,\n            vec3 surfacePosition,\n            out vec3 directionToLight,\n            out vec3 normalIlluminance\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDirectionalLight) {\n                directionToLight = xyz_type.xyz;\n                normalIlluminance = rgb_parameter.rgb;\n            } else if (lightType == kPointLight) {\n                vec3 lightPosition = xyz_type.xyz;\n                vec3 displacement = lightPosition - surfacePosition;\n                float distance = length(displacement);\n                directionToLight = displacement / distance;\n                normalIlluminance = rgb_parameter.rgb / (4.0 * kPi * distance * distance);\n            }\n        }\n        \n        float positiveDotProduct(vec3 v1, vec3 v2) {\n            return clamp(dot(v1, v2), 0.0, 1.0);\n        }\n        \n        // Adapted from https://google.github.io/filament/Filament.md.html#materialsystem/specularbrdf/normaldistributionfunction(speculard)\n        float specularD(float alpha, float dotNH, vec3 normalDirection, vec3 halfDirection) {\n            vec3 crossNH = cross(normalDirection, halfDirection);\n            float a = dotNH * alpha;\n            float k = alpha / (dot(crossNH, crossNH) + a * a);\n            float d = k * k * (1.0 / kPi);\n            return min(d, kMediumpFloatMax);\n        }\n        \n        float safeQuotient(float numerator, float denominator) {\n            if (denominator == 0.0) {\n                return 0.0;\n            } else {\n                return numerator / denominator;\n            }\n        }\n        \n        float g1(float dotNV, float alphaSquared) {\n            return safeQuotient(2.0 * dotNV, dotNV + sqrt(alphaSquared + (1.0 - alphaSquared) * dotNV * dotNV));\n        }\n        \n        float specularG(float dotNL, float dotNV, float alphaSquared) {\n            return g1(dotNV, alphaSquared) * g1(dotNL, alphaSquared);\n        }\n        \n        vec3 fresnelColor(vec3 specularBaseColor, float dotVH) {\n            vec3 one = vec3(1.0, 1.0, 1.0);\n            float scale = exp2((-5.55473 * dotVH - 6.98316) * dotVH);\n            return specularBaseColor + (one - specularBaseColor) * scale;\n        }\n        \n        vec3 brdf(vec3 normalDirection, vec3 directionToCamera, vec3 directionToLight, float alpha, float dotNV, float dotNL, vec3 specularBaseColor, vec3 normalIlluminance) {\n            vec3 halfDirection = normalize(directionToCamera + directionToLight);\n            float dotVH = positiveDotProduct(directionToCamera, halfDirection);\n            float dotNH = positiveDotProduct(normalDirection, halfDirection);\n            float dotNHSquared = dotNH * dotNH;\n        \n            float d = specularD(alpha, dotNH, normalDirection, halfDirection);\n            float g = specularG(dotNL, dotNV, alpha * alpha);\n            vec3 f = fresnelColor(specularBaseColor, dotVH);\n            return safeQuotient(d * g, 4.0 * dotNL * dotNV) * f;\n        }\n        \n        vec3 sampleFacetNormal(vec3 vH, vec3 vT1, vec3 vT2, float s, float alpha) {\n            float t2 = (1.0 - s);\n            vec3 vNh = t2 * vT2 + sqrt(max(0.0, 1.0 - t2 * t2)) * vH;\n            return normalize(vec3(alpha * vNh.x, alpha * vNh.y, max(0.0, vNh.z)));\n        }\n        \n        vec3 softLightingLuminance(\n            vec3 aboveLuminance,\n            vec3 belowLuminance,\n            vec3 localUpDirection,\n            vec3 localLightDirection\n        ) {\n            float sinElevation = dot(localLightDirection, localUpDirection);\n            float t = (sinElevation + 1.0) / 2.0;\n            return aboveLuminance * t + belowLuminance * (1.0 - t);\n        }\n        \n        vec3 softLightingSpecularSample(\n            vec3 aboveLuminance,\n            vec3 belowLuminance,\n            vec3 localUpDirection,\n            vec3 localViewDirection,\n            vec3 localLightDirection,\n            vec3 localHalfDirection,\n            float alphaSquared,\n            vec3 specularBaseColor\n        ) {\n            vec3 luminance = softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection);\n            float dotVH = positiveDotProduct(localViewDirection, localHalfDirection);\n            float dotNL = localLightDirection.z;\n            return luminance * (fresnelColor(specularBaseColor, dotVH) * g1(dotNL, alphaSquared));\n        }\n        \n        vec3 softLighting(\n            vec3 normalDirection,\n            vec3 diffuseBaseColor,\n            vec3 specularBaseColor,\n            float alpha,\n            vec3 directionToCamera,\n            vec3 viewY,\n            vec4 xyz_type,\n            vec4 rgb_parameter\n        ) {\n            float alphaSquared = alpha * alpha;\n            vec3 upDirection = xyz_type.xyz;\n            vec3 luminanceAbove = rgb_parameter.rgb;\n            vec3 luminanceBelow = rgb_parameter.a * luminanceAbove;\n            vec3 crossProduct = cross(normalDirection, directionToCamera);\n            float crossMagnitude = length(crossProduct);\n            vec3 xDirection = vec3(0.0, 0.0, 0.0);\n            vec3 yDirection = vec3(0.0, 0.0, 0.0);\n            if (crossMagnitude > 1.0e-6) {\n                yDirection = (1.0 / crossMagnitude) * crossProduct;\n                xDirection = cross(yDirection, normalDirection);\n            } else {\n                vec3 viewY = vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]);\n                xDirection = normalize(cross(viewY, normalDirection));\n                yDirection = cross(normalDirection, xDirection);\n            }\n            float localViewX = dot(directionToCamera, xDirection);\n            float localViewZ = dot(directionToCamera, normalDirection);\n            vec3 localViewDirection = vec3(localViewX, 0, localViewZ);\n            float localUpX = dot(upDirection, xDirection);\n            float localUpY = dot(upDirection, yDirection);\n            float localUpZ = dot(upDirection, normalDirection);\n            vec3 localUpDirection = vec3(localUpX, localUpY, localUpZ);\n        \n            vec3 vH = normalize(vec3(alpha * localViewX, 0.0, localViewZ));\n            vec3 vT1 = vec3(0.0, 1.0, 0.0);\n            vec3 vT2 = cross(vH, vT1);\n            float s = 0.5 * (1.0 + vH.z);\n            \n            vec3 localHalfDirection = sampleFacetNormal(vH, vT1, vT2, s, alpha);\n            vec3 localLightDirection = vec3(0.0, 0.0, 0.0);\n            \n            localLightDirection = -reflect(localViewDirection, localHalfDirection);\n            vec3 specular = softLightingSpecularSample(luminanceAbove, luminanceBelow, localUpDirection, localViewDirection, localLightDirection, localHalfDirection, alphaSquared, specularBaseColor);\n            \n            localLightDirection = vec3(0.000000, 0.000000, 1.000000);\n            vec3 diffuse = softLightingLuminance(luminanceAbove, luminanceBelow, localUpDirection, localLightDirection) * localLightDirection.z;\n            \n            return specular + diffuse * diffuseBaseColor;\n        }\n        \n        vec3 physicalLight(\n            vec4 xyz_type,\n            vec4 rgb_parameter,\n            vec3 surfacePosition,\n            vec3 normalDirection,\n            vec3 directionToCamera,\n            vec3 viewY,\n            float dotNV,\n            vec3 diffuseBaseColor,\n            vec3 specularBaseColor,\n            float alpha\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDisabledLight) {\n                return vec3(0.0, 0.0, 0.0);\n            } else if (lightType == kSoftLighting) {\n                return softLighting(normalDirection, diffuseBaseColor, specularBaseColor, alpha, directionToCamera, viewY, xyz_type, rgb_parameter);\n            }\n        \n            vec3 directionToLight = vec3(0.0, 0.0, 0.0);\n            vec3 normalIlluminance = vec3(0.0, 0.0, 0.0);\n            getDirectionToLightAndNormalIlluminance(xyz_type, rgb_parameter, surfacePosition, directionToLight, normalIlluminance);\n        \n            float dotNL = positiveDotProduct(normalDirection, directionToLight);\n            vec3 specularColor = brdf(normalDirection, directionToCamera, directionToLight, alpha, dotNV, dotNL, specularBaseColor, normalIlluminance);\n            return (normalIlluminance * dotNL) * ((diffuseBaseColor / kPi) + specularColor);\n        }\n        \n        vec3 physicalLighting(\n            vec3 surfacePosition,\n            vec3 surfaceNormal,\n            vec3 baseColor,\n            vec3 directionToCamera,\n            mat4 viewMatrix,\n            float roughness,\n            float metallic,\n            mat4 lights12,\n            mat4 lights34,\n            mat4 lights56,\n            mat4 lights78,\n            vec4 enabledLights\n        ) {\n            float dotNV = positiveDotProduct(surfaceNormal, directionToCamera);\n            float alpha = roughness * roughness;\n            float nonmetallic = 1.0 - metallic;\n            vec3 diffuseBaseColor = nonmetallic * 0.96 * baseColor;\n            vec3 specularBaseColor = nonmetallic * 0.04 * vec3(1.0, 1.0, 1.0) + metallic * baseColor;\n            vec3 viewY = vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]);\n        \n            vec3 litColor1 = enabledLights[0] == 1.0 ? physicalLight(lights12[0], lights12[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor2 = enabledLights[1] == 1.0 ? physicalLight(lights12[2], lights12[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor3 = enabledLights[2] == 1.0 ? physicalLight(lights34[0], lights34[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor4 = enabledLights[3] == 1.0 ? physicalLight(lights34[2], lights34[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor5 = physicalLight(lights56[0], lights56[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            vec3 litColor6 = physicalLight(lights56[2], lights56[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            vec3 litColor7 = physicalLight(lights78[0], lights78[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            vec3 litColor8 = physicalLight(lights78[2], lights78[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            return litColor1 + litColor2 + litColor3 + litColor4 + litColor5 + litColor6 + litColor7 + litColor8;\n        }\n        \n        float inverseGamma(float u) {\n            if (u <= 0.04045) {\n                return clamp(u / 12.92, 0.0, 1.0);\n            } else {\n                return clamp(pow((u + 0.055) / 1.055, 2.4), 0.0, 1.0);\n            }\n        }\n        \n        vec3 fromSrgb(vec3 srgbColor) {\n            return vec3(\n                inverseGamma(srgbColor.r),\n                inverseGamma(srgbColor.g),\n                inverseGamma(srgbColor.b)\n            );\n        }\n        \n        float gammaCorrect(float u) {\n            if (u <= 0.0031308) {\n                return 12.92 * u;\n            } else {\n                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;\n            }\n        }\n        \n        vec3 gammaCorrectedColor(vec3 color) {\n            float red = gammaCorrect(color.r);\n            float green = gammaCorrect(color.g);\n            float blue = gammaCorrect(color.b);\n            return vec3(red, green, blue);\n        }\n        \n        vec3 reinhardLuminanceToneMap(vec3 color) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scale = 1.0 / (1.0 + luminance);\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 reinhardPerChannelToneMap(vec3 color) {\n            return gammaCorrectedColor(color / (color + 1.0));\n        }\n        \n        float extendedReinhardToneMap(float x, float xMax) {\n            return x * (1.0 + (x / (xMax * xMax))) / (1.0 + x);\n        }\n        \n        vec3 extendedReinhardLuminanceToneMap(vec3 color, float overexposureLimit) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scaledLuminance = extendedReinhardToneMap(luminance, overexposureLimit);\n            float scale = scaledLuminance / luminance;\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 extendedReinhardPerChannelToneMap(vec3 color, float overexposureLimit) {\n            float red = extendedReinhardToneMap(color.r, overexposureLimit);\n            float green = extendedReinhardToneMap(color.g, overexposureLimit);\n            float blue = extendedReinhardToneMap(color.b, overexposureLimit);\n            return gammaCorrectedColor(vec3(red, green, blue));\n        }\n        \n        vec3 hableFilmicHelper(vec3 color) {\n            float a = 0.15;\n            float b = 0.5;\n            float c = 0.1;\n            float d = 0.2;\n            float e = 0.02;\n            float f = 0.3;\n            return (color * (a * color + c * b) + d * e) / (color * (a * color + b) + d * f) - e / f;\n        }\n        \n        vec3 hableFilmicToneMap(vec3 color) {\n            float exposureBias = 2.0;\n            vec3 unscaled = hableFilmicHelper(exposureBias * color);\n            vec3 scale = 1.0 / hableFilmicHelper(vec3(11.2));\n            return gammaCorrectedColor(scale * unscaled);\n        }\n        \n        vec3 toneMap(vec3 color, float toneMapType, float toneMapParam) {\n            if (toneMapType == 0.0) {\n                return gammaCorrectedColor(color);\n            } else if (toneMapType == 1.0) {\n                return reinhardLuminanceToneMap(color);\n            } else if (toneMapType == 2.0) {\n                return reinhardPerChannelToneMap(color);\n            } else if (toneMapType == 3.0) {\n                return extendedReinhardLuminanceToneMap(color, toneMapParam);\n            } else if (toneMapType == 4.0) {\n                return extendedReinhardPerChannelToneMap(color, toneMapParam);\n            } else if (toneMapType == 5.0) {\n                return hableFilmicToneMap(color);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {\n            vec3 referenceWhite = sceneProperties[2].rgb;\n            float unitR = linearColor.r / referenceWhite.r;\n            float unitG = linearColor.g / referenceWhite.g;\n            float unitB = linearColor.b / referenceWhite.b;\n            float toneMapType = sceneProperties[3][2];\n            float toneMapParam = sceneProperties[3][3];\n            vec3 toneMapped = toneMap(vec3(unitR, unitG, unitB), toneMapType, toneMapParam);\n            return vec4(toneMapped, 1.0);\n        }\n        \n        void main() {\n            vec3 baseColor = fromSrgb(texture2D(baseColorTexture, interpolatedUv).rgb) * (1.0 - constantBaseColor.w) + constantBaseColor.rgb * constantBaseColor.w;\n            float roughness = getFloatValue(roughnessTexture, interpolatedUv, constantRoughness);\n            float metallic = getFloatValue(metallicTexture, interpolatedUv, constantMetallic);\n        \n            vec3 localNormal = getLocalNormal(normalMapTexture, useNormalMap, interpolatedUv);\n            float normalSign = getNormalSign();\n            vec3 originalNormal = normalize(interpolatedNormal) * normalSign;\n            vec3 normalDirection = getMappedNormal(originalNormal, interpolatedTangent, normalSign, localNormal);\n            vec3 directionToCamera = getDirectionToCamera(interpolatedPosition, sceneProperties);\n        \n            vec3 linearColor = physicalLighting(\n                interpolatedPosition,\n                normalDirection,\n                baseColor,\n                directionToCamera,\n                viewMatrix,\n                roughness,\n                metallic,\n                lights12,\n                lights34,\n                lights56,\n                lights78,\n                enabledLights\n            );\n        \n            gl_FragColor = toSrgb(linearColor, sceneProperties);\n        }\n    ",attributes:{},uniforms:{baseColorTexture:"cQ",constantBaseColor:"cS",constantMetallic:"cT",constantRoughness:"cU",enabledLights:"ab",lights12:"bO",lights34:"cp",lights56:"cq",lights78:"cr",metallicTexture:"dc",normalMapTexture:"bo",roughnessTexture:"dz",sceneProperties:"g",useNormalMap:"bu",viewMatrix:"h"}},Kc={src:"\n        precision highp float;\n        \n        attribute highp vec3 quadVertex;\n        \n        uniform highp vec4 modelScale;\n        uniform highp mat4 modelMatrix;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 projectionMatrix;\n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 quadVertexPositions;\n        \n        void getQuadVertex(int quadVertexIndex, mat4 quadVertexPositions, out vec3 position, out vec3 normal, out vec3 tangent) {\n            vec3 next = vec3(0.0, 0.0, 0.0);\n            vec3 prev = vec3(0.0, 0.0, 0.0);\n            if (quadVertexIndex == 0) {\n                prev = quadVertexPositions[3].xyz;\n                position = quadVertexPositions[0].xyz;\n                next = quadVertexPositions[1].xyz;\n                tangent = normalize(next - position);\n            } else if (quadVertexIndex == 1) {\n                prev = quadVertexPositions[0].xyz;\n                position = quadVertexPositions[1].xyz;\n                next = quadVertexPositions[2].xyz;\n                tangent = normalize(position - prev);\n            } else if (quadVertexIndex == 2) {\n                prev = quadVertexPositions[1].xyz;\n                position = quadVertexPositions[2].xyz;\n                next = quadVertexPositions[3].xyz;\n                tangent = normalize(position - next);\n            } else {\n                prev = quadVertexPositions[2].xyz;\n                position = quadVertexPositions[3].xyz;\n                next = quadVertexPositions[0].xyz;\n                tangent = normalize(prev - position);\n            }\n            normal = normalize(cross(next - position, prev - position));\n        }\n        \n        vec4 getWorldPosition(vec3 modelPosition, vec4 modelScale, mat4 modelMatrix) {\n            vec4 scaledPosition = vec4(modelScale.xyz * modelPosition, 1.0);\n            return modelMatrix * scaledPosition;\n        }\n        \n        void main() {\n            vec3 position = vec3(0.0, 0.0, 0.0);\n            vec3 normal = vec3(0.0, 0.0, 0.0);\n            vec3 tangent = vec3(0.0, 0.0, 0.0);\n            getQuadVertex(int(quadVertex.z), quadVertexPositions, position, normal, tangent);\n            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);\n            gl_Position = projectionMatrix * (viewMatrix * worldPosition);\n        }\n    ",attributes:{quadVertex:"cB"},uniforms:{modelMatrix:"d",modelScale:"e",projectionMatrix:"f",quadVertexPositions:"av",sceneProperties:"g",viewMatrix:"h"}},Zc=function(e){var n=new Float64Array(16);return n[0]=e.el,n[1]=e.ep,n[2]=e.et,n[3]=e.ex,n[4]=e.em,n[5]=e.eq,n[6]=e.eu,n[7]=e.ey,n[8]=e.en,n[9]=e.er,n[10]=e.ev,n[11]=e.ez,n[12]=e.eo,n[13]=e.es,n[14]=e.ew,n[15]=e.eA,n},el=u(function(e,n,r,t){t=h(t),r=h(r),n=h(n),e=h(e);return Zc({el:e.b4,em:n.b4,en:r.b4,eo:t.b4,ep:e.b6,eq:n.b6,er:r.b6,es:t.b6,et:e.b8,eu:n.b8,ev:r.b8,ew:t.b8,ex:0,ey:0,ez:0,eA:0})}),xe=s(function(e,n){return{$:0,a:e,b:n}}),nl=xe({d_:1,d9:0,eJ:6})(p([{cB:D(Sc,0,0,0)},{cB:D(Sc,1,0,1)},{cB:D(Sc,1,1,2)},{cB:D(Sc,0,1,3)}])),rl=s(function(e,n){return{$:1,a:e,b:n}}),tl=s(function(e,n){return n.$?{a:n.a.p,b:1}:{a:e,b:0}}),ol=function(e){return e[0]},al=function(e){return e[1]},il=function(e){return e[2]},cl=_n,ll=S(cl,0,0,0,0),ul=s(function(e,n){return n.$?{a:n.a.p,b:ll}:{a:e,b:S(cl,ol(e=n.a),al(e),il(e),1)}}),fl=s(function(e,n){var r,t={a:e,b:n};return t.a.$?z(rl,{a:r=t.a.a.p,b:ll},z(tl,r,n)):t.b.$?z(rl,z(ul,r=t.b.a.p,e),z(tl,r,n)):{$:0,a:t.a.a}}),sl=b(function(e,n,r){return{$:0,a:e,b:n,c:r}}),bl=u(function(e,n,r,t){return{$:1,a:e,b:n,c:r,d:t}}),dl=u(function(e,n,r,t){return{$:0,a:e,b:n,c:r,d:t}}),r=Sn,vl=z(r,0,0),ml=s(function(e,n){return n.$?{a:n.a.p,b:vl}:{a:e,b:z(r,n.a,1)}}),pl=u(function(e,n,r,t){var o,a=S(dl,e,n,r,t);return a.a.$?S(bl,{a:o=a.a.a.p,b:ll},z(ml,o,n),z(ml,o,r),z(tl,o,t)):a.b.$?S(bl,z(ul,o=a.b.a.p,e),{a:o,b:vl},z(ml,o,r),z(tl,o,t)):a.c.$?S(bl,z(ul,o=a.c.a.p,e),z(ml,o,n),{a:o,b:vl},z(tl,o,t)):a.d.$?S(bl,z(ul,o=a.d.a.p,e),z(ml,o,n),z(ml,o,r),{a:o,b:1}):D(sl,a.a.a,a.b.a,a.c.a)}),gl=An,hl={src:"\n        precision highp float;\n        \n        attribute highp vec3 quadVertex;\n        \n        uniform highp vec4 modelScale;\n        uniform highp mat4 modelMatrix;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 projectionMatrix;\n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 quadVertexPositions;\n        \n        varying highp vec3 interpolatedPosition;\n        varying highp vec3 interpolatedNormal;\n        \n        void getQuadVertex(int quadVertexIndex, mat4 quadVertexPositions, out vec3 position, out vec3 normal, out vec3 tangent) {\n            vec3 next = vec3(0.0, 0.0, 0.0);\n            vec3 prev = vec3(0.0, 0.0, 0.0);\n            if (quadVertexIndex == 0) {\n                prev = quadVertexPositions[3].xyz;\n                position = quadVertexPositions[0].xyz;\n                next = quadVertexPositions[1].xyz;\n                tangent = normalize(next - position);\n            } else if (quadVertexIndex == 1) {\n                prev = quadVertexPositions[0].xyz;\n                position = quadVertexPositions[1].xyz;\n                next = quadVertexPositions[2].xyz;\n                tangent = normalize(position - prev);\n            } else if (quadVertexIndex == 2) {\n                prev = quadVertexPositions[1].xyz;\n                position = quadVertexPositions[2].xyz;\n                next = quadVertexPositions[3].xyz;\n                tangent = normalize(position - next);\n            } else {\n                prev = quadVertexPositions[2].xyz;\n                position = quadVertexPositions[3].xyz;\n                next = quadVertexPositions[0].xyz;\n                tangent = normalize(prev - position);\n            }\n            normal = normalize(cross(next - position, prev - position));\n        }\n        \n        vec4 getWorldPosition(vec3 modelPosition, vec4 modelScale, mat4 modelMatrix) {\n            vec4 scaledPosition = vec4(modelScale.xyz * modelPosition, 1.0);\n            return modelMatrix * scaledPosition;\n        }\n        \n        vec3 safeNormalize(vec3 vector) {\n            if (vector == vec3(0.0, 0.0, 0.0)) {\n                return vector;\n            } else {\n                return normalize(vector);\n            }\n        }\n        \n        vec3 getWorldNormal(vec3 modelNormal, vec4 modelScale, mat4 modelMatrix) {\n            vec3 normalScale = vec3(modelScale.w / modelScale.x, modelScale.w / modelScale.y, modelScale.w / modelScale.z);\n            return (modelMatrix * vec4(safeNormalize(normalScale * modelNormal), 0.0)).xyz;\n        }\n        \n        void main() {\n            vec3 position = vec3(0.0, 0.0, 0.0);\n            vec3 normal = vec3(0.0, 0.0, 0.0);\n            vec3 tangent = vec3(0.0, 0.0, 0.0);\n            getQuadVertex(int(quadVertex.z), quadVertexPositions, position, normal, tangent);\n            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);\n            gl_Position = projectionMatrix * (viewMatrix * worldPosition);\n            interpolatedPosition = worldPosition.xyz;\n            interpolatedNormal = getWorldNormal(normal, modelScale, modelMatrix);\n        }\n    ",attributes:{quadVertex:"cB"},uniforms:{modelMatrix:"d",modelScale:"e",projectionMatrix:"f",quadVertexPositions:"av",sceneProperties:"g",viewMatrix:"h"}},xl={src:"\n        precision highp float;\n        \n        attribute highp vec3 quadVertex;\n        \n        uniform highp vec4 modelScale;\n        uniform highp mat4 modelMatrix;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 projectionMatrix;\n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 quadVertexPositions;\n        \n        varying highp vec3 interpolatedPosition;\n        varying highp vec3 interpolatedNormal;\n        varying mediump vec2 interpolatedUv;\n        varying highp vec3 interpolatedTangent;\n        \n        void getQuadVertex(int quadVertexIndex, mat4 quadVertexPositions, out vec3 position, out vec3 normal, out vec3 tangent) {\n            vec3 next = vec3(0.0, 0.0, 0.0);\n            vec3 prev = vec3(0.0, 0.0, 0.0);\n            if (quadVertexIndex == 0) {\n                prev = quadVertexPositions[3].xyz;\n                position = quadVertexPositions[0].xyz;\n                next = quadVertexPositions[1].xyz;\n                tangent = normalize(next - position);\n            } else if (quadVertexIndex == 1) {\n                prev = quadVertexPositions[0].xyz;\n                position = quadVertexPositions[1].xyz;\n                next = quadVertexPositions[2].xyz;\n                tangent = normalize(position - prev);\n            } else if (quadVertexIndex == 2) {\n                prev = quadVertexPositions[1].xyz;\n                position = quadVertexPositions[2].xyz;\n                next = quadVertexPositions[3].xyz;\n                tangent = normalize(position - next);\n            } else {\n                prev = quadVertexPositions[2].xyz;\n                position = quadVertexPositions[3].xyz;\n                next = quadVertexPositions[0].xyz;\n                tangent = normalize(prev - position);\n            }\n            normal = normalize(cross(next - position, prev - position));\n        }\n        \n        vec4 getWorldPosition(vec3 modelPosition, vec4 modelScale, mat4 modelMatrix) {\n            vec4 scaledPosition = vec4(modelScale.xyz * modelPosition, 1.0);\n            return modelMatrix * scaledPosition;\n        }\n        \n        vec3 safeNormalize(vec3 vector) {\n            if (vector == vec3(0.0, 0.0, 0.0)) {\n                return vector;\n            } else {\n                return normalize(vector);\n            }\n        }\n        \n        vec3 getWorldNormal(vec3 modelNormal, vec4 modelScale, mat4 modelMatrix) {\n            vec3 normalScale = vec3(modelScale.w / modelScale.x, modelScale.w / modelScale.y, modelScale.w / modelScale.z);\n            return (modelMatrix * vec4(safeNormalize(normalScale * modelNormal), 0.0)).xyz;\n        }\n        \n        void main() {\n            vec3 position = vec3(0.0, 0.0, 0.0);\n            vec3 normal = vec3(0.0, 0.0, 0.0);\n            vec3 tangent = vec3(0.0, 0.0, 0.0);\n            getQuadVertex(int(quadVertex.z), quadVertexPositions, position, normal, tangent);\n            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);\n            gl_Position = projectionMatrix * (viewMatrix * worldPosition);\n            interpolatedPosition = worldPosition.xyz;\n            interpolatedNormal = getWorldNormal(normal, modelScale, modelMatrix);\n            interpolatedUv = quadVertex.xy;\n            interpolatedTangent = tangent;\n        }\n    ",attributes:{quadVertex:"cB"},uniforms:{modelMatrix:"d",modelScale:"e",projectionMatrix:"f",quadVertexPositions:"av",sceneProperties:"g",viewMatrix:"h"}},Cl=b(function(e,n,r){return.5<r?n+(1-r)*(e-n):e+r*(n-e)}),Pl=function(e){return D(Cl,e.eF,e.eC,.5)},yl=function(e){return D(Cl,e.eG,e.eD,.5)},Tl=function(e){return D(Cl,e.eH,e.eE,.5)},Ll=b(function(e,n,r){return{b4:e,b6:n,b8:r}}),Ml=function(e){return e.eC},wl=function(e){return e.eD},Nl=function(e){return e.eE},$l=function(e){return e.eF},zl=function(e){return e.eG},Dl=function(e){return e.eH},Sl={src:"\n        precision highp float;\n        \n        attribute highp vec3 quadVertex;\n        \n        uniform highp vec4 modelScale;\n        uniform highp mat4 modelMatrix;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 projectionMatrix;\n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 quadVertexPositions;\n        \n        varying mediump vec2 interpolatedUv;\n        \n        void getQuadVertex(int quadVertexIndex, mat4 quadVertexPositions, out vec3 position, out vec3 normal, out vec3 tangent) {\n            vec3 next = vec3(0.0, 0.0, 0.0);\n            vec3 prev = vec3(0.0, 0.0, 0.0);\n            if (quadVertexIndex == 0) {\n                prev = quadVertexPositions[3].xyz;\n                position = quadVertexPositions[0].xyz;\n                next = quadVertexPositions[1].xyz;\n                tangent = normalize(next - position);\n            } else if (quadVertexIndex == 1) {\n                prev = quadVertexPositions[0].xyz;\n                position = quadVertexPositions[1].xyz;\n                next = quadVertexPositions[2].xyz;\n                tangent = normalize(position - prev);\n            } else if (quadVertexIndex == 2) {\n                prev = quadVertexPositions[1].xyz;\n                position = quadVertexPositions[2].xyz;\n                next = quadVertexPositions[3].xyz;\n                tangent = normalize(position - next);\n            } else {\n                prev = quadVertexPositions[2].xyz;\n                position = quadVertexPositions[3].xyz;\n                next = quadVertexPositions[0].xyz;\n                tangent = normalize(prev - position);\n            }\n            normal = normalize(cross(next - position, prev - position));\n        }\n        \n        vec4 getWorldPosition(vec3 modelPosition, vec4 modelScale, mat4 modelMatrix) {\n            vec4 scaledPosition = vec4(modelScale.xyz * modelPosition, 1.0);\n            return modelMatrix * scaledPosition;\n        }\n        \n        void main() {\n            vec3 position = vec3(0.0, 0.0, 0.0);\n            vec3 normal = vec3(0.0, 0.0, 0.0);\n            vec3 tangent = vec3(0.0, 0.0, 0.0);\n            getQuadVertex(int(quadVertex.z), quadVertexPositions, position, normal, tangent);\n            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);\n            gl_Position = projectionMatrix * (viewMatrix * worldPosition);\n            interpolatedUv = quadVertex.xy;\n        }\n    ",attributes:{quadVertex:"cB"},uniforms:{modelMatrix:"d",modelScale:"e",projectionMatrix:"f",quadVertexPositions:"av",sceneProperties:"g",viewMatrix:"h"}},Vl=l(function(r,M,w,N,$){var e=z(Oc,M,p([w,N,$])),e=Gr(e);return z(Fc,e,function(){switch(r.$){case 0:var l;return r.b.$?(u=r.b.a.p,I(function(e,n,r,t,o,a,i,c){return V(Hc,D(Xc,t,0,c),Sl,Bc,nl,{cg:u,d:r,e:n,f:a,av:S(el,M,w,N,$),g:e,h:o})})):(l=r.b.a,I(function(e,n,r,t,o,a,i,c){return V(Hc,D(Xc,t,0,c),Kc,kc,nl,{aY:l,d:r,e:n,f:a,av:S(el,M,w,N,$),g:e,h:o})}));case 1:var u,f,s;return r.b.$?(u=r.b.a.p,s=r.c,I(function(e,n,r,t,o,a,i,c){return V(Hc,D(Xc,t,0,c),Sl,Rc,nl,{cN:Or(s),cg:u,d:r,e:n,f:a,av:S(el,M,w,N,$),g:e,h:o})})):(f=r.b.a,s=r.c,I(function(e,n,r,t,o,a,i,c){return V(Hc,D(Xc,t,0,c),Kc,Ec,nl,{cN:s,be:z(gl,Or(s),f),d:r,e:n,f:a,av:S(el,M,w,N,$),g:e,h:o})}));case 2:var b,d,e=z(fl,r.b,r.c);return e.$?(b=e.a.a,C=(n=e.b).a,P=n.b,I(function(e,n,r,t,o,a,i,c){var l=i.a,i=i.b;return V(Hc,D(Xc,t,0,c),xl,Uc,nl,{ab:i,bO:l.bO,cp:l.cp,cq:l.cq,cr:l.cr,c9:b,d:r,e:n,bo:C,f:a,av:S(el,M,w,N,$),g:e,bu:P,h:o})})):(d=e.a,I(function(e,n,r,t,o,a,i,c){var l=i.a,i=i.b;return V(Hc,D(Xc,t,0,c),hl,Yc,nl,{ab:i,bO:l.bO,cp:l.cp,cq:l.cq,cr:l.cr,c8:d,d:r,e:n,f:a,av:S(el,M,w,N,$),g:e,h:o})}));default:var v,m,p,g,h,x,C,P,y,T,L,n=S(pl,r.b,r.c,r.d,r.e);return n.$?(v=(e=n.a).a,m=e.b,p=(e=n.b).a,g=e.b,h=(e=n.c).a,x=e.b,C=(e=n.d).a,P=e.b,I(function(e,n,r,t,o,a,i,c){var l=i.a,i=i.b;return V(Hc,D(Xc,t,0,c),xl,Qc,nl,{cQ:v,cS:m,cT:x,cU:g,ab:i,bO:l.bO,cp:l.cp,cq:l.cq,cr:l.cr,dc:h,d:r,e:n,bo:C,f:a,av:S(el,M,w,N,$),dz:p,g:e,bu:P,h:o})})):(y=n.a,T=n.b,L=n.c,I(function(e,n,r,t,o,a,i,c){var l=i.a,i=i.b;return V(Hc,D(Xc,t,0,c),hl,Jc,nl,{cP:y,ab:i,bO:l.bO,cp:l.cp,cq:l.cq,cr:l.cr,db:L,d:r,e:n,f:a,av:S(el,M,w,N,$),dy:T,g:e,h:o})}))}}())}),Re=b(function(e,n,r){return{$:3,a:e,b:n,c:r}})({d_:1,d9:3,eJ:4}),Al=(J=p([{aN:z(r,0,1)},{aN:z(r,1,1)},{aN:z(r,2,1)},{aN:z(r,3,1)},{aN:z(r,0,-1)},{aN:z(r,1,-1)},{aN:z(r,2,-1)},{aN:z(r,3,-1)}]),te=p([{a:0,b:1,c:2},{a:0,b:2,c:3},{a:4,b:6,c:5},{a:4,b:7,c:6},{a:4,b:5,c:1},{a:1,b:0,c:4},{a:5,b:6,c:2},{a:2,b:1,c:5},{a:6,b:7,c:3},{a:3,b:2,c:6},{a:7,b:4,c:0},{a:0,b:3,c:7}]),z(Re,J,te)),_l={src:"\n        precision highp float;\n        \n        attribute highp vec2 quadShadowVertex;\n        \n        uniform highp vec4 modelScale;\n        uniform highp mat4 modelMatrix;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 projectionMatrix;\n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 shadowLight;\n        uniform highp mat4 quadVertexPositions;\n        \n        const lowp float kDirectionalLight = 1.0;\n        const lowp float kPointLight = 2.0;\n        \n        void getQuadVertex(int quadVertexIndex, mat4 quadVertexPositions, out vec3 position, out vec3 normal, out vec3 tangent) {\n            vec3 next = vec3(0.0, 0.0, 0.0);\n            vec3 prev = vec3(0.0, 0.0, 0.0);\n            if (quadVertexIndex == 0) {\n                prev = quadVertexPositions[3].xyz;\n                position = quadVertexPositions[0].xyz;\n                next = quadVertexPositions[1].xyz;\n                tangent = normalize(next - position);\n            } else if (quadVertexIndex == 1) {\n                prev = quadVertexPositions[0].xyz;\n                position = quadVertexPositions[1].xyz;\n                next = quadVertexPositions[2].xyz;\n                tangent = normalize(position - prev);\n            } else if (quadVertexIndex == 2) {\n                prev = quadVertexPositions[1].xyz;\n                position = quadVertexPositions[2].xyz;\n                next = quadVertexPositions[3].xyz;\n                tangent = normalize(position - next);\n            } else {\n                prev = quadVertexPositions[2].xyz;\n                position = quadVertexPositions[3].xyz;\n                next = quadVertexPositions[0].xyz;\n                tangent = normalize(prev - position);\n            }\n            normal = normalize(cross(next - position, prev - position));\n        }\n        \n        vec4 getWorldPosition(vec3 modelPosition, vec4 modelScale, mat4 modelMatrix) {\n            vec4 scaledPosition = vec4(modelScale.xyz * modelPosition, 1.0);\n            return modelMatrix * scaledPosition;\n        }\n        \n        vec3 safeNormalize(vec3 vector) {\n            if (vector == vec3(0.0, 0.0, 0.0)) {\n                return vector;\n            } else {\n                return normalize(vector);\n            }\n        }\n        \n        vec3 getWorldNormal(vec3 modelNormal, vec4 modelScale, mat4 modelMatrix) {\n            vec3 normalScale = vec3(modelScale.w / modelScale.x, modelScale.w / modelScale.y, modelScale.w / modelScale.z);\n            return (modelMatrix * vec4(safeNormalize(normalScale * modelNormal), 0.0)).xyz;\n        }\n        \n        vec3 getDirectionToLight(vec3 surfacePosition, vec4 xyz_type, vec4 rgb_parameter) {\n            float lightType = xyz_type.w;\n            if (lightType == kDirectionalLight) {\n                return xyz_type.xyz;\n            } else if (lightType == kPointLight) {\n                vec3 lightPosition = xyz_type.xyz;\n                return normalize(lightPosition - surfacePosition);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 shadowVertexPosition(vec3 position, vec3 normal, mat4 shadowLight, vec4 modelScale, mat4 modelMatrix, mat4 viewMatrix, mat4 projectionMatrix, mat4 sceneProperties) {\n            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);\n            vec3 worldNormal = getWorldNormal(normal, vec4(modelScale.xyz, 1.0), modelMatrix);\n            vec4 xyz_type = shadowLight[0];\n            vec4 rgb_parameter = shadowLight[1];\n            vec3 directionToLight = getDirectionToLight(worldPosition.xyz, xyz_type, rgb_parameter);\n            vec3 offset = vec3(0.0, 0.0, 0.0);\n            float sceneDiameter = sceneProperties[3][1];\n            if (dot(directionToLight, worldNormal) <= 0.0) {\n                offset = -sceneDiameter * directionToLight;\n            } else {\n                offset = -0.001 * sceneDiameter * directionToLight;\n            }\n            vec4 offsetPosition = worldPosition + vec4(offset, 0.0);\n            return projectionMatrix * (viewMatrix * offsetPosition);\n        }\n        \n        void main () {\n            vec3 position = vec3(0.0, 0.0, 0.0);\n            vec3 normal = vec3(0.0, 0.0, 0.0);\n            vec3 tangent = vec3(0.0, 0.0, 0.0);\n            getQuadVertex(int(quadShadowVertex.x), quadVertexPositions, position, normal, tangent);\n            normal *= quadShadowVertex.y;\n            gl_Position = shadowVertexPosition(\n                position,\n                normal,\n                shadowLight,\n                modelScale,\n                modelMatrix,\n                viewMatrix,\n                projectionMatrix,\n                sceneProperties\n            );\n        }\n    ",attributes:{quadShadowVertex:"aN"},uniforms:{modelMatrix:"d",modelScale:"e",projectionMatrix:"f",quadVertexPositions:"av",sceneProperties:"g",shadowLight:"cI",viewMatrix:"h"}},ql={src:"\n        precision lowp float;\n        \n        void main () {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    ",attributes:{},uniforms:{}},Fl=b(function(e,n,r){function t(e){return z(vo,i(e.bY),z(vo,c(e.bI),z(vo,c(e.b9),c(e.ca))))}var o=e.du,a=e.c7,e=e.dK,i=s(function(e,n){return n(e)}),c=s(function(e,n){return n(e)});return z(t,r,z(t,n,D(Xr,o,a,e)))}),Bl=D(Fl,{c7:0,du:0,dK:15},{bI:7680,bY:519,b9:7680,ca:7683},{bI:7680,bY:519,b9:7680,ca:7682}),kl=D(Fl,{c7:0,du:0,dK:15},{bI:7680,bY:519,b9:7680,ca:7682},{bI:7680,bY:519,b9:7680,ca:7683}),El=s(function(e,n){return z(x,e?kl:Bl,n)}),Rl=u(function(l,u,f,s){return{$:2,a:I(function(e,n,r,t,o,a,i,c){return V(Hc,z(El,t,c),_l,ql,Al,{d:r,e:n,f:a,av:S(el,l,u,f,s),g:e,cI:i,h:o})})}}),Il=R(function(e,n,r,t,o,a,i){r=V(Vl,r,t,o,a,i),e={a:e,b:n};return e.a?e.b?jr(p([r,S(Rl,t,o,a,i)])):r:e.b?S(Rl,t,o,a,i):_c}),Hl=l(function(e,n,r,t,o){return j(Il,!0,!1,e,n,r,t,o)}),jl=z(w,function(e){var n,r,t,o;return e.$?(r=(t=e.a).a,t=t.b,o=e.b,V(Hl,Hr(Ac),D($,r-.5,t+.5,1),D($,r-.5,t+.5,0),D($,r-.5,t-o+.5,0),D($,r-.5,t-o+.5,1))):(r=(n=e.a).a,t=n.b,o=e.b,V(Hl,Hr(Ac),D($,r-.5,t+.5,1),D($,r-.5,t+.5,0),D($,r+o-.5,t+.5,0),D($,r+o-.5,t+.5,1)))},ee),Ol=S(ao,52/255,101/255,164/255,1),Yl=S(ao,32/255,74/255,135/255,1),Ul=S(ao,164/255,0,0,1),Wl=function(e){switch(e.$){case 0:return Ol;case 1:case 2:return Yl;default:return Ul}},k=en,yn=S(ao,186/255,189/255,182/255,1),pe=p([{bC:S(ao,78/255,154/255,6/255,1),b4:0,b5:19,b6:0,b7:15,b8:-.02},{bC:yn,b4:0,b5:3,b6:0,b7:15,b8:-.01},{bC:yn,b4:5.5,b5:8,b6:0,b7:3,b8:-.01}]),Gl=z(w,function(e){var n=e.bC,r=e.b5,t=e.b7,e=D($,e.b4,e.b6,e.b8);return V(Hl,Hr(n),z(i,D(a,-r/2,-t/2,0),e),z(i,D(a,r/2,-t/2,0),e),z(i,D(a,r/2,t/2,0),e),z(i,D(a,-r/2,t/2,0),e))},pe),Xl=S(u(function(e,n,r,t){return S(ao,e,n,r,t)}),0,0,0,0),Jl=function(e){return{$:0,a:e}},Ql={$:3},Kl=u(function(e,n,r,t){return{$:4,a:e,b:n,c:r,d:t}}),Zl=function(e){return{$:1,a:e}},eu=function(e){return{$:2,a:e}},nu=ve,ru=b(function(e,n,r){return D(tr,e,n,r)}),tu=S(cl,1,1,1,1),ou=b(function(e,n,r){return z(w,function(e){return z(e,n,r)},e)}),au=b(function(e,n,r){return{$:0,a:e,b:n,c:r}}),iu=s(function(e,n){var r=n.b4,n=n.b6;return D(au,e*r/n,e,e*(1-r-n)/n)}),cu=s(function(e,n){return D(Sc,3.2406*(n=(e=z(iu,e,n)).a)-1.5372*(r=e.b)-.4986*(e=e.c),-.9689*n+1.8758*r+.0415*e,.0557*n-.204*r+1.057*e);var r}),lu=s(function(e,n){return{eb:f(e.eb,n.eb),w:e.w*n.w+e.x*n.z+e.y*n.C,x:e.w*n.x+e.x*n.A+e.y*n.D,y:e.w*n.y+e.x*n.B+e.y*n.E,z:e.z*n.w+e.A*n.z+e.B*n.C,A:e.z*n.x+e.A*n.A+e.B*n.D,B:e.z*n.y+e.A*n.B+e.B*n.E,C:e.C*n.w+e.D*n.z+e.E*n.C,D:e.C*n.x+e.D*n.A+e.E*n.D,E:e.C*n.y+e.D*n.B+e.E*n.E,Q:n.Q+(e.Q*n.w+e.R*n.z+e.S*n.C)*n.cH,R:n.R+(e.Q*n.x+e.R*n.A+e.S*n.D)*n.cH,S:n.S+(e.Q*n.y+e.R*n.B+e.S*n.E)*n.cH,cH:e.cH*n.cH}}),uu=l(function(e,n,r,t,o){return H(o,e,S(cl,t.cH,t.cH,t.cH,t.eb?1:-1),function(e){return Zc({el:e.w,em:e.z,en:e.C,eo:e.Q,ep:e.x,eq:e.A,er:e.D,es:e.R,et:e.y,eu:e.B,ev:e.E,ew:e.S,ex:0,ey:0,ez:0,eA:1})}(t),t.eb,n,r)}),fu=E(function(e,n,r,t,o,a){for(;;)switch(o.$){case 0:return a;case 5:var i=o.b;e=e,n=n,r=r,t=z(lu,o.a,t),o=i,a=a;continue;case 1:return{Y:z(x,V(uu,e,n,r,t,o.b),a.Y),ah:a.ah,aj:a.aj};case 3:i=z(x,V(uu,e,n,r,t,o.b),a.ah);return{Y:a.Y,ah:i,aj:a.aj};case 2:var c=z(x,V(uu,e,n,r,t,o.a),a.aj);return{Y:a.Y,ah:a.ah,aj:c};default:c=o.a;return D(y,S(fu,e,n,r,t),a,c)}}),su=u(function(e,n,r,t){return{$:4,a:e,b:n,c:r,d:t}}),bu=u(function(e,n,r,t){return{$:1,a:e,b:n,c:r,d:t}}),se=s(function(e,n){return{$:6,a:e,b:n}}),du=p([function(e){return S(bu,518,e.aq,e.al,e.ak)}({ak:1,al:0,aq:!1}),S(su,!1,!1,!1,!1),z(se,0,1)]),vu={src:"\n        precision lowp float;\n\n        void main() {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n    ",attributes:{},uniforms:{}},mu=xe({d_:1,d9:0,eJ:5})(p([{cA:z(r,-1,-1)},{cA:z(r,1,-1)},{cA:z(r,-1,1)},{cA:z(r,1,1)}])),pu={src:"\n        precision lowp float;\n\n        attribute vec2 position;\n\n        void main() {\n            gl_Position = vec4(position, 0.0, 1.0);\n        }\n    ",attributes:{position:"cA"},uniforms:{}},gu=et({bI:7681,c7:0,du:8,bY:519,dK:15,b9:7681,ca:7681}),hu=oe,xu=b(function(e,n,r){return Vr(p([D(ou,e,r,du),p([nt(n),gu])]))}),Cu=s(function(e,n){return Vr(z(Nt,xu(e),n))}),Z=function(e){return S(bu,513,e.aq,e.al,e.ak)}({ak:1,al:0,aq:!0}),Pu=b(function(e,n,r){return{$:0,a:e,b:n,c:r}}),Y=s(function(e,n){return D(Pu,32774,e,n)}),yu=function(e){var a=e.cC,i=e.cl,c=e.cd,l=e.cb,n=e.bC,e=e.ba;return z(s(function(e,n){var r=e.c,t=n.a,o=n.b,n=n.c;return function(u){return function(l){return function(c){return function(i){return function(a){return function(o){return function(t){return function(r){return function(n){return function(e){return{$:0,a:u,b:l,c:c,d:i,e:a,f:o,g:t,h:r,i:n,j:e}}}}}}}}}}}(e.a)(e.b)(r)(t)(o)(n)(a)(i)(c)(l)}),n,e)}({cb:0,ba:z(Y,1,771),cd:0,bC:z(Y,770,771),cl:0,cC:0}),Tu=p([Z,yu]),Lu=s(function(e,n){var r=e.dN,t=e.dM,e=e.dL;return{b4:n.b4*e.b4+n.b6*e.b6+n.b8*e.b8,b6:n.b4*t.b4+n.b6*t.b6+n.b8*t.b8,b8:n.b4*r.b4+n.b6*r.b6+n.b8*r.b8}}),Mu=s(function(e,n){var r=e.dh,t=n.b4-r.b4,o=n.b6-r.b6,n=n.b8-r.b8,r=e.dN,a=e.dM,e=e.dL;return{b4:t*e.b4+o*e.b6+n*e.b8,b6:t*a.b4+o*a.b6+n*a.b8,b8:t*r.b4+o*r.b6+n*r.b8}}),wu=s(function(e,n){return{dh:z(Mu,e,Lr(n)),dL:z(Lu,e,Ja(n)),dM:z(Lu,e,Qa(n)),dN:z(Lu,e,Mr(n))}}),Nu=s(function(e,n){return z(T,e,n)}),$u=s(function(e,n){return z($a,e,n)}),zu=s(function(e,n){n=rt(n),e=rt(e);return{eC:z(Nu,e.eC,n.eC),eD:z(Nu,e.eD,n.eD),eE:z(Nu,e.eE,n.eE),eF:z($u,e.eF,n.eF),eG:z($u,e.eG,n.eG),eH:z($u,e.eH,n.eH)}}),Du=s(function(e,n){return n+e}),Su=s(function(e,n){var r=e.a,t=e.c,e=fi(ui(e.b)),r=fi(ui(r)),t=fi(ui(t)),n=function(e){return{a:e.b4,b:e.b6,c:e.b8}}(n),o=n.a,a=n.b,n=n.c;return{eC:z(Du,r,o),eD:z(Du,e,a),eE:z(Du,t,n),eF:z(Bi,r,o),eG:z(Bi,e,a),eH:z(Bi,t,n)}}),Vu=u(function(e,n,r,t){var o=r.fx,a=2*r.fZ*n,i=2*r.fY*n,r=2*r.fX*n,c=o.b8*n,l=o.b6*n,o=o.b4*n,n=tt(Mr(e)),n=F(r*n.b4)+F(i*n.b6)+F(a*n.b8),u=tt(Qa(e)),u=F(r*u.b4)+F(i*u.b6)+F(a*u.b8),f=tt(Ja(e)),r=F(r*f.b4)+F(i*f.b6)+F(a*f.b8),i=z(Su,{a:r,b:u,c:n},z(Mu,e,D($,o,l,c)));return C(t.$?i:z(zu,t.a,i))}),Au=u(function(e,n,r,t){for(;;){if(!t.b)return r;var o=t.a,a=t.b;switch(o.$){case 0:e=c=e,n=l=n,r=u=r,t=a;continue;case 1:var i=S(Vu,e,n,o.a,r);e=c=e,n=l=n,r=u=i,t=a;continue;case 2:e=c=e,n=l=n,r=u=r,t=a;continue;case 3:i=S(Vu,e,n,o.a,r);e=c=e,n=l=n,r=u=i,t=a;continue;case 4:var c=e,l=n,u=S(Au,e,n,r,o.a);e=c,n=l,r=u,t=a;continue;default:var f=o.a,s=o.b,b=z(wu,function(e){return Xa({dh:{b4:e.Q,b6:e.R,b8:e.S},dL:{b4:e.w,b6:e.x,b8:e.y},dM:{b4:e.z,b6:e.A,b8:e.B},dN:{b4:e.C,b6:e.D,b8:e.E}})}(f),e),f=n*f.cH;e=c=e,n=l=n,r=u=S(Au,b,f,r,p([s])),t=a;continue}}}),_u={eb:!0,w:1,x:0,y:0,z:0,A:1,B:0,C:0,D:0,E:1,Q:0,R:0,S:0,cH:1},qu=et({bI:7681,c7:0,du:8,bY:519,dK:255,b9:7681,ca:7681}),ae={cd:0,fw:!1,cl:0,dq:0,cC:0,gE:0,b4:0,b6:0,b8:0},ie=s(function(e,n){return Zc({el:e.b4,em:e.cC,en:n.b4,eo:n.cC,ep:e.b6,eq:e.cl,er:n.b6,es:n.cl,et:e.b8,eu:e.cd,ev:n.b8,ew:n.cd,ex:e.gE,ey:e.dq,ez:n.gE,eA:n.dq})}),Fu={a:{bO:z(ie,ae,ae),cp:z(ie,ae,ae),cq:z(ie,ae,ae),cr:z(ie,ae,ae)},b:S(cl,0,0,0,0)},Bu=p([ot({ak:1,al:0,aq:!0}),Zr({bI:7680,c7:240,du:0,bY:514,dK:0,b9:7680,ca:7680}),yu]),ku=function(e){return e===1/0||e===-1/0},Eu=s(function(e,n){var r,t=n.fU,o=n.fm,n=ui(n.gd),t=ui(t),e=e.ds;return e.$?(r=e.a,ku(t)?Zc({el:2/(o*r),em:0,en:0,eo:0,ep:0,eq:2/r,er:0,es:0,et:0,eu:0,ev:0,ew:-1,ex:0,ey:0,ez:0,eA:1}):Zc({el:2/(o*r),em:0,en:0,eo:0,ep:0,eq:2/r,er:0,es:0,et:0,eu:0,ev:-2/(t-n),ew:-(t+n)/(t-n),ex:0,ey:0,ez:0,eA:1})):(r=e.a,ku(t)?Zc({el:1/(o*r),em:0,en:0,eo:0,ep:0,eq:1/r,er:0,es:0,et:0,eu:0,ev:-1,ew:-2*n,ex:0,ey:0,ez:-1,eA:0}):Zc({el:1/(o*r),em:0,en:0,eo:0,ep:0,eq:1/r,er:0,es:0,et:0,eu:0,ev:-(t+n)/(t-n),ew:-2*t*n/(t-n),ex:0,ey:0,ez:-1,eA:0}))}),Ru=s(function(e,n){return 1==(1&e>>n)?0:1}),Iu=b(function(r,t,e){return Vr(z(w,function(e){var n=e<<4;return D(ou,r,{a:t,b:S(cl,z(Ru,e,0),z(Ru,e,1),z(Ru,e,2),z(Ru,e,3))},function(e){return p([ot({ak:1,al:0,aq:!0}),Zr({bI:7680,c7:240,du:e,bY:514,dK:0,b9:7680,ca:7680}),yu])}(n))},z(wt,1,z(hu,2,e)-1)))}),Hu=function(e){return{el:e[0],ep:e[1],et:e[2],ex:e[3],em:e[4],eq:e[5],eu:e[6],ey:e[7],en:e[8],er:e[9],ev:e[10],ez:e[11],eo:e[12],es:e[13],ew:e[14],eA:e[15]}},ju={dh:za,dL:le,dM:U,dN:ue},Ou=s(function(e,n){var r,t;return e=Wr(Lr(n=z(wu,n,e))),r=tt(Mr(n)),t=tt(Qa(n)),n=tt(Ja(n)),Zc({el:n.b4,em:t.b4,en:r.b4,eo:e.b4,ep:n.b6,eq:t.b6,er:r.b6,es:e.b6,et:n.b8,eu:t.b8,ev:r.b8,ew:e.b8,ex:0,ey:0,ez:0,eA:1})}),Yu=s(function(n,e){var r=p([Zl(1),eu(0),Jl(!0),S(Kl,0,0,0,0)]),t=function(){var e=n.bb;switch(e.$){case 0:return{a:r,b:"0",c:1};case 1:return{a:z(x,Ql,r),b:"1",c:1};default:return{a:r,b:"0",c:e.a}}}(),o=t.a,a=t.b,i=t.c,t=n.fE,c=t.a,t=Kr(t.b),l=z(k,"height",yt(t)+"px"),c=Kr(c),u=c/t,e=z(Wi,function(e){return at({fm:u,fv:n.fv,fA:n.fA,fN:e.fN,aE:e.aE,aH:e.aH,e9:i,aO:e.aO,aR:e.aR})},e),f=z(k,"width",yt(c)+"px"),s=Qr(n.fp);return D(Jr,"div",p([z(k,"padding","0px"),f,l]),p([{a:a,b:D(ru,o,p([(a=B(c*i),z(rn,"width",yt(a))),function(e){return z(rn,"height",yt(e))}(B(t*i)),f,l,z(k,"display","block"),z(k,"background-color",s)]),e)}]))}),Uu={b4:.31271,b6:.32902},Wu={$:1},Gu={$:0,a:Fu.a},Xu={$:0},Ju=function(e){return function(e){return z(Yu,{bb:e.bb,fp:e.fp,fv:e.fv,fA:e.fA,fE:e.fE},p([{fN:e.fN,aE:e.aE,aH:e.aH,aO:e.aO,aR:e.aR}]))}({bb:Wu,fp:e.fp,fv:e.fv,fA:e.fA,fE:e.fE,fN:e.fN,aE:ui(80),aH:Gu,aO:Xu,aR:Uu})},Qu=S(ao,237/255,212/255,0,1),Ku=function(e){return V(Hl,Hr(e.bl.$?Ac:Qu),z(i,D(a,-.5,-.5,0),e.bm),z(i,D(a,.5,-.5,0),e.bm),z(i,D(a,.5,.5,0),e.bm),z(i,D(a,-.5,.5,0),e.bm))},Zu=s(function(e,n){return e/n}),ef=s(function(e,n){var r=e.dh,e=e.dL;return(n.b4-r.b4)*e.b4+(n.b6-r.b6)*e.b6+(n.b8-r.b8)*e.b8}),nf=b(function(e,n,r){var t=e.dh,o=e.dM,e=e.dL;return{b4:t.b4+n*e.b4+r*o.b4,b6:t.b6+n*e.b6+r*o.b6}}),rf=s(function(e,n){var r=e.dh,e=e.dM;return(n.b4-r.b4)*e.b4+(n.b6-r.b6)*e.b6+(n.b8-r.b8)*e.b8}),tf=s(function(e,n){var r=e.dh,e=e.dN;return(n.b4-r.b4)*e.b4+(n.b6-r.b6)*e.b6+(n.b8-r.b8)*e.b8}),of=b(function(e,n,r){var t,o,a=e.gJ,i=z(ef,a,r),c=z(rf,a,r),a=Ra(z(tf,a,r)),r=$r(n),l=r.a,r=r.b,u=z(Zu,l,r),e=e.ds;return e.$?(o=z(Zu,c,t=e.a),D(nf,Nr(n),z(pi,z(Zu,i,z(pi,u,t)),l),z(pi,o,r))):(t=e.a,o=z(Zu,c,a)/t,D(nf,Nr(n),z(pi,z(Zu,i,a)/(u*t)/2,l),z(pi,o/2,r)))}),af=s(function(e,n){e=qr(D(of,e,ji,z(ca,D(a,0,0,.1),n.bm)));return z(c,p([z(k,"position","absolute"),z(k,"left",o(e.b4-45)),z(k,"top",o(e.b6)),z(k,"width",o(90)),z(k,"text-align","center"),z(k,"font-size",o(10)),z(k,"font-weight","bold")]),p([t(it(n.bl))]))}),cf=u(function(e,n,r,t){e=qr(D(of,e,ji,z(ca,D(a,0,0,1.2),t)));return z(c,p([z(k,"position","absolute"),z(k,"left",o(e.b4-45)),z(k,"top",o(e.b6)),z(k,"width",o(90)),z(k,"height",o(15)),z(k,"background-color","#d33030")]),p([z(c,p([z(k,"position","absolute"),z(k,"left","0"),z(k,"top","0"),z(k,"width",nu(n/r*100)+"%"),z(k,"height",o(15)),z(k,"background-color","lime")]),m)]))}),lf=b(function(e,n,r){var e=qr(D(of,e,ji,r)),r=e.b4,e=e.b6,n=hr(n);return 1===n.$?t(""):(n=n.a.cM,z(c,p([z(k,"position","absolute"),z(k,"left",o(r-15)),z(k,"top",o(e-15)),z(k,"width",o(30)),z(k,"height",o(30)),z(k,"background-color","#d33030"),z(k,"color","white"),z(k,"display","flex"),z(k,"justify-content","center"),z(k,"align-items","center"),z(k,"border-radius","100%"),z(k,"font-weight","bold")]),p([z(c,m,p([t(yt(n))]))])))}),uf=_c,ff=s(function(e,n){return V(Hl,Hr(e),z(i,D(a,-.5,-.5,0),n),z(i,D(a,.5,-.5,0),n),z(i,D(a,.5,.5,0),n),z(i,D(a,-.5,.5,0),n))}),sf=function(e){return e.$?uf:z(ff,(e=e.a).bC,e.bm)},bf=s(function(e,n){return n.$?t(""):(n=v(n=qr(D(of,e,ji,(e=n.a).bm)),{b4:n.b4-75,b6:n.b6-10}),z(c,p([z(k,"position","absolute"),z(k,"left",o(n.b4)),z(k,"top",o(n.b6)),z(k,"width",o(150)),z(k,"text-align","center"),z(k,"color","white"),z(k,"font-size","12px"),z(k,"font-weight","bold")]),p([t(e.gb)])))}),df=function(e){var n=v(n=qr(D(of,vi(e),ji,e.bm)),{b4:n.b4-75,b6:n.b6-10});return z(c,p([z(k,"position","absolute"),z(k,"left",o(n.b4)),z(k,"top",o(n.b6)),z(k,"width",o(150)),z(k,"text-align","center"),z(k,"color","white"),z(k,"font-size","12px"),z(k,"font-weight","bold")]),p([t(function(e){switch(e.I.$){case 0:return e.J.b?"Walking":"Standing";case 1:return"Getting item";case 2:return"Attacking";default:return"Fighting"}}(e))]))},vf=Qe("button"),mf=Ze,pf=s(function(e,n){return z(mf,e,{$:0,a:n})}),gf=b(function(e,n,r){return z(vf,p([ct({$:4,a:e}),z(k,"background-color",f(n.bW,e)?"#d33030":""),z(k,"height","50px"),z(k,"flex","1")]),p([t(r)]))}),hf=b(function(e,n,r){return z(vf,p([ct({$:7,a:e}),f(r.aT,e)?z(k,"background-color","#d33030"):z(k,"",""),z(k,"flex","1"),z(k,"height",o(50))]),p([t(n)]))}),xf=function(e){return z(c,p([z(k,"display","flex")]),p([D(hf,0,"Accuracy",e),D(hf,1,"Strength",e),D(hf,2,"Defense",e)]))},Cf=b(function(e,n,r){for(;;){if(n<=0)return e;e=z(x,r,e),n=n-1,r=r}}),Pf=s(function(e,n){return D(Cf,m,e,n)}),yf=function(e){e=z(ya,28,G(z(w,C,e),z(Pf,28,P)));return z(c,p([$c("inventory")]),z(w,lt,e))},Tf=s(function(e,n){return z(c,p([z(k,"width","100%"),z(k,"background-color","#333"),z(k,"height",o(50)),z(k,"display","flex"),z(k,"justify-content","center"),z(k,"align-items","center")]),p([t(e+(" level: "+yt(function(e){return e<15?1:e<35?2:e<60?3:e<90?4:5}(n))+(" ("+yt(n)))+" XP)")]))}),Lf=function(e){return z(c,p([z(k,"display","flex"),z(k,"flex-direction","column"),z(k,"gap","10px")]),p([z(Tf,"Accuracy",e.a9),z(Tf,"Strength",e.bs),z(Tf,"Defense",e.bc)]))},ce=K({f2:function(e){return{a:{a9:0,I:eo,aT:0,aX:fr(0),bc:0,X:m,at:10,ae:m,a0:oo,aF:to,bm:D($,0,0,0),cu:10,P:co,aL:-1,bW:1,bs:0,J:m},b:lo}},gz:function(e){return bo(G(p([Qo(z(Ot,br,z(qo,"key",na))),Ko(z(Ot,dr,z(qo,"key",na))),Zo(D(Yt,s(function(e,n){return{$:1,a:z(ea,e,n)}}),z(qo,"clientX",Fo),z(qo,"clientY",Fo))),Ho(z(vo,pr,sr))]),3===e.I.$?p([z(_o,1e3,function(e){return so})]):m))},gF:he,gI:function(e){return z(c,m,p([z(c,p([$c("game-container")]),p([function(n){return z(c,p([z(k,"position","relative"),z(k,"overflow","hidden"),z(k,"user-select","none")]),p([Ju({fp:Xl,fv:vi(n),fA:Na(1),fE:{a:Vi(B(_i)),b:Vi(B(Ai))},fN:G(Gl,G(z(w,Ku,n.X),G(z(x,z(ff,Wl(n.I),n.bm),z(w,sf,n.P)),jl)))}),z(c,m,z(w,af(vi(n)),n.X)),z(c,m,z(w,function(e){return e.$?t(""):(e=e.a,S(cf,vi(n),e.at,e.cu,e.bm))},n.P)),df(n),S(cf,vi(n),n.at,n.cu,n.bm),D(lf,vi(n),n.ae,n.bm),z(c,m,z(w,bf(vi(n)),n.P)),z(c,m,z(w,function(e){return e.$?t(""):(e=e.a,D(lf,vi(n),e.ae,e.bm))},n.P))]))}(e),function(e){return z(c,p([z(k,"width","320px")]),p([z(c,p([z(k,"display","flex")]),p([D(gf,0,e,"Attack Style / Stats"),D(gf,1,e,"Inventory")])),e.bW?yf(e.a0):z(c,m,p([z(c,p([z(k,"text-align","center"),z(k,"padding","5px")]),p([t("Attack style")])),xf(e),z(c,p([z(k,"text-align","center"),z(k,"padding","5px")]),p([t("Stats")])),Lf(e)]))]))}(e)])),z(c,m,p([t("Use left and right arrow keys to rotate the screen.")])),z(c,m,p([t("Click on the screen to move to that location.")])),z(c,m,p([t("Click on a monster to attack it.")]))]))}});fe={Main:{init:ce(Ut(0))(0)}},e.Elm?function e(n,r){for(var t in r)t in n?"init"==t?re(6):e(n[t],r[t]):n[t]=r[t]}(e.Elm,fe):e.Elm=fe}(this);