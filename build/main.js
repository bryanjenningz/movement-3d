!function(e){"use strict";function n(e,n,r){return r.a=e,r.f=n,r}function f(r){return n(2,r,function(n){return function(e){return r(n,e)}})}function d(t){return n(3,t,function(r){return function(n){return function(e){return t(r,n,e)}}})}function u(o){return n(4,o,function(t){return function(r){return function(n){return function(e){return o(t,r,n,e)}}}})}function l(a){return n(5,a,function(o){return function(t){return function(r){return function(n){return function(e){return a(o,t,r,n,e)}}}}})}function B(i){return n(6,i,function(a){return function(o){return function(t){return function(r){return function(n){return function(e){return i(a,o,t,r,n,e)}}}}}})}function F(c){return n(7,c,function(i){return function(a){return function(o){return function(t){return function(r){return function(n){return function(e){return c(i,a,o,t,r,n,e)}}}}}}})}function t(l){return n(8,l,function(c){return function(i){return function(a){return function(o){return function(t){return function(r){return function(n){return function(e){return l(c,i,a,o,t,r,n,e)}}}}}}}})}function D(e,n,r){return 2===e.a?e.f(n,r):e(n)(r)}function z(e,n,r,t){return 3===e.a?e.f(n,r,t):e(n)(r)(t)}function V(e,n,r,t,o){return 4===e.a?e.f(n,r,t,o):e(n)(r)(t)(o)}function $(e,n,r,t,o,a){return 5===e.a?e.f(n,r,t,o,a):e(n)(r)(t)(o)(a)}function E(e,n,r,t,o,a,i){return 6===e.a?e.f(n,r,t,o,a,i):e(n)(r)(t)(o)(a)(i)}function G(e,n,r,t,o,a,i,c){return 7===e.a?e.f(n,r,t,o,a,i,c):e(n)(r)(t)(o)(a)(i)(c)}function s(e,n){for(var r,t=[],o=j(e,n,0,t);o&&(r=t.pop());o=j(r.a,r.b,0,t));return o}function j(e,n,r,t){if(e!==n){if("object"!=typeof e||null===e||null===n)return"function"==typeof e&&ee(5),!1;if(100<r)t.push({a:e,b:n});else for(var o in e.$<0&&(e=rt(e),n=rt(n)),e)if(!j(e[o],n[o],r+1,t))return!1}return!0}function v(e,n,r){if("object"!=typeof e)return e===n?0:e<n?-1:1;if(void 0===e.$)return(r=(r=v(e.a,n.a))||v(e.b,n.b))||v(e.c,n.c);for(;e.b&&n.b&&!(r=v(e.a,n.a));e=e.b,n=n.b);return r||(e.b?1:n.b?-1:0)}var I=f(function(e,n){e=v(e,n);return e<0?et:e?Jr:Xr}),H=0;function m(e,n){var r,t={};for(r in e)t[r]=e[r];for(r in n)t[r]=n[r];return t}function U(e,n){if("string"==typeof e)return e+n;if(!e.b)return n;var r={$:1,a:e.a,b:n};e=e.b;for(var t=r;e.b;e=e.b)t=t.b={$:1,a:e.a,b:n};return r}var p={$:0};function O(e,n){return{$:1,a:e,b:n}}var Y=f(O);function g(e){for(var n=p,r=e.length;r--;)n={$:1,a:e[r],b:n};return n}function W(e){for(var n=[];e.b;e=e.b)n.push(e.a);return n}var K=d(function(e,n,r){for(var t=[];n.b&&r.b;n=n.b,r=r.b)t.push(D(e,n.a,r.a));return g(t)}),Q=f(function(r,e){return g(W(e).sort(function(e,n){e=D(r,e,n);return e===Xr?0:e===et?-1:1}))});var X=d(function(e,n,r){for(var t=Array(e),o=0;o<e;o++)t[o]=r(n+o);return t}),J=f(function(e,n){for(var r=Array(e),t=0;t<e&&n.b;t++)r[t]=n.a,n=n.b;return r.length=t,{a:r,b:n}});function ee(e){throw Error("https://github.com/elm/core/blob/1.0.0/hints/"+e+".md")}var ne=f(Math.pow),re=Math.cos,te=Math.sin,oe=Math.tan;var ae=Math.ceil,ie=Math.floor,ce=Math.round,le=Math.sqrt,ue=Math.log;var se=f(function(e,n){return n.split(e)}),fe=f(function(e,n){return n.join(e)});function de(e){return e+""}var ve={$:2,b:function(e){return"number"==typeof e?ct(e):Pe("a FLOAT",e)}},me={$:2,b:function(e){return"string"==typeof e?ct(e):e instanceof String?ct(e+""):Pe("a STRING",e)}};var pe=f(function(e,n){return{$:6,d:e,b:n}});var ge=f(function(e,n){return{$:9,f:e,g:[n]}}),he=d(function(e,n,r){return{$:9,f:e,g:[n,r]}}),be=f(h);function h(e,n){switch(e.$){case 2:return e.b(n);case 5:return null===n?ct(e.c):Pe("null",n);case 3:return Ce(n)?xe(e.b,n,g):Pe("a LIST",n);case 4:return Ce(n)?xe(e.b,n,ye):Pe("an ARRAY",n);case 6:var r=e.d;return"object"==typeof n&&null!==n&&r in n?(a=h(e.b,n[r]),T(a)?a:tt(D(at,r,a.a))):Pe("an OBJECT with a field named `"+r+"`",n);case 7:r=e.e;return Ce(n)?r<n.length?(a=h(e.b,n[r]),T(a)?a:tt(D(it,r,a.a))):Pe("a LONGER array. Need index "+r+" but only see "+n.length+" entries",n):Pe("an ARRAY",n);case 8:if("object"!=typeof n||null===n||Ce(n))return Pe("an OBJECT",n);var t,o=p;for(t in n)if(n.hasOwnProperty(t)){var a=h(e.b,n[t]);if(!T(a))return tt(D(at,t,a.a));o={$:1,a:{a:t,b:a.a},b:o}}return ct(gt(o));case 9:for(var i=e.f,c=e.g,l=0;l<c.length;l++){a=h(c[l],n);if(!T(a))return a;i=i(a.a)}return ct(i);case 10:a=h(e.b,n);return T(a)?h(e.h(a.a),n):a;case 11:for(var u=p,s=e.g;s.b;s=s.b){a=h(s.a,n);if(T(a))return a;u={$:1,a:a.a,b:u}}return tt(lt(gt(u)));case 1:return tt(D(ot,e.a,n));case 0:return ct(e.a)}}function xe(e,n,r){for(var t=n.length,o=Array(t),a=0;a<t;a++){var i=h(e,n[a]);if(!T(i))return tt(D(it,a,i.a));o[a]=i.a}return ct(r(o))}function Ce(e){return Array.isArray(e)||"undefined"!=typeof FileList&&e instanceof FileList}function ye(n){return D(Vt,n.length,function(e){return n[e]})}function Pe(e,n){return tt(D(ot,"Expecting "+e,n))}function Te(e,n){if(e===n)return!0;if(e.$!==n.$)return!1;switch(e.$){case 0:case 1:return e.a===n.a;case 2:return e.b===n.b;case 5:return e.c===n.c;case 3:case 4:case 8:return Te(e.b,n.b);case 6:return e.d===n.d&&Te(e.b,n.b);case 7:return e.e===n.e&&Te(e.b,n.b);case 9:return e.f===n.f&&Le(e.g,n.g);case 10:return e.h===n.h&&Te(e.b,n.b);case 11:return Le(e.g,n.g)}}function Le(e,n){var r=e.length;if(r!==n.length)return!1;for(var t=0;t<r;t++)if(!Te(e[t],n[t]))return!1;return!0}function Me(e){return{$:0,a:e}}var _e=f(function(e,n){return{$:3,b:e,d:n}});var we=0;function Ne(e){e={$:0,e:we++,f:e,g:null,h:[]};return Ae(e),e}function De(n){return{$:2,b:function(e){e({$:0,a:Ne(n)})},c:null}}function ze(e,n){e.h.push(n),Ae(e)}var Ve=f(function(n,r){return{$:2,b:function(e){ze(n,r),e({$:0,a:H})},c:null}});var $e=!1,Se=[];function Ae(e){if(Se.push(e),!$e){for($e=!0;e=Se.shift();)!function(n){for(;n.f;){var e=n.f.$;if(0===e||1===e){for(;n.g&&n.g.$!==e;)n.g=n.g.i;if(!n.g)return;n.f=n.g.b(n.f.a),n.g=n.g.i}else{if(2===e)return n.f.c=n.f.b(function(e){n.f=e,Ae(n)});if(5===e){if(0===n.h.length)return;n.f=n.f.b(n.h.shift())}else n.g={$:3===e?0:1,b:n.f.b,i:n.g},n.f=n.f.d}}}(e);$e=!1}}function qe(e,n,r,t,o,a){var e=D(be,e,n?n.flags:void 0),i=(T(e)||ee(2),{}),n=r(e.a),c=n.a,l=a(u,c),r=function(e,n){var r,t;for(t in ke){var o=ke[t];o.a&&((r=r||{})[t]=o.a(t,n)),e[t]=function(e,n){var t={g:n,h:void 0},o=e.c,a=e.d,i=e.e,c=e.f;function l(r){return D(_e,l,{$:5,b:function(e){var n=e.a;return 0===e.$?z(a,t,n,r):i&&c?V(o,t,n.i,n.j,r):z(o,t,i?n.i:n.j,r)}})}return t.h=Ne(D(_e,l,e.b))}(o,n)}return r}(i,u);function u(e,n){e=D(t,e,c);l(c=e.a,n),je(i,e.b,o(c))}return je(i,n.b,o(c)),r?{ports:r}:{}}var ke={};var Ze=f(function(n,r){return{$:2,b:function(e){n.g(r),e({$:0,a:H})},c:null}}),Re=f(function(e,n){return D(Ve,e.h,{$:0,a:n})});function Be(n){return function(e){return{$:1,k:n,l:e}}}function Fe(e){return{$:2,m:e}}var Ee=[],Ge=!1;function je(e,n,r){if(Ee.push({p:e,q:n,r:r}),!Ge){Ge=!0;for(var t;t=Ee.shift();)!function(e,n,r){var t,o={};for(t in Ie(!0,n,o,null),Ie(!1,r,o,null),e)ze(e[t],{$:"fx",a:o[t]||{i:p,j:p}})}(t.p,t.q,t.r);Ge=!1}}function Ie(e,n,r,t){switch(n.$){case 1:var o=n.k,a=function(e,n,r,t){function o(e){for(var n=r;n;n=n.t)e=n.s(e);return e}return D(e?ke[n].e:ke[n].f,o,t)}(e,o,t,n.l);return void(r[o]=function(e,n,r){return r=r||{i:p,j:p},e?r.i={$:1,a:n,b:r.i}:r.j={$:1,a:n,b:r.j},r}(e,a,r[o]));case 2:for(var i=n.m;i.b;i=i.b)Ie(e,i.a,r,t);return;case 3:Ie(e,n.o,r,{s:n.n,t:t})}}var He;var Ue="undefined"!=typeof document?document:{};function Oe(e){return{$:0,a:e}}var Ye=f(function(a,i){return f(function(e,n){for(var r=[],t=0;n.b;n=n.b){var o=n.a;t+=o.b||0,r.push(o)}return t+=r.length,{$:1,c:i,d:nn(e),e:r,f:a,b:t}})})(void 0),We=f(function(a,i){return f(function(e,n){for(var r=[],t=0;n.b;n=n.b){var o=n.a;t+=o.b.b||0,r.push(o)}return t+=r.length,{$:2,c:i,d:nn(e),e:r,f:a,b:t}})})(void 0);var Ke=f(function(e,n){return{$:"a0",n:e,o:n}}),Qe=f(function(e,n){return{$:"a1",n:e,o:n}}),Xe=f(function(e,n){return{$:"a3",n:e,o:n}}),Je=/^script$/i;var en;function nn(e){for(var n={};e.b;e=e.b){var r,t=e.a,o=t.$,a=t.n,t=t.o;"a2"===o?"className"===a?rn(n,a,t):n[a]=t:(r=n[o]||(n[o]={}),"a3"===o&&"class"===a?rn(r,a,t):r[a]=t)}return n}function rn(e,n,r){var t=e[n];e[n]=t?t+" "+r:r}function tn(e,n){var r=e.$;if(5===r)return tn(e.k||(e.k=e.m()),n);if(0===r)return Ue.createTextNode(e.a);if(4===r){for(var t=e.k,o=e.j;4===t.$;)"object"!=typeof o?o=[o,t.j]:o.push(t.j),t=t.k;var a={j:o,p:n};(i=tn(t,a)).elm_event_node_ref=a}else if(3===r)on(i=e.h(e.g),n,e.d);else{var i=e.f?Ue.createElementNS(e.f,e.c):Ue.createElement(e.c);He&&"a"==e.c&&i.addEventListener("click",He(i)),on(i,n,e.d);for(var c=e.e,l=0;l<c.length;l++)i.appendChild(tn(1===r?c[l]:c[l].b,n))}return i}function on(e,n,r){for(var t in r){var o=r[t];"a1"===t?function(e,n){var r,t=e.style;for(r in n)t[r]=n[r]}(e,o):"a0"===t?function(e,n,r){var t,o=e.elmFs||(e.elmFs={});for(t in r){var a=r[t],i=o[t];if(a){if(i){if(i.q.$===a.$){i.q=a;continue}e.removeEventListener(t,i)}i=function(l,e){function u(e){var n=u.q,r=h(n.a,e);if(T(r)){for(var t,n=qt(n),r=r.a,o=n?n<3?r.a:r.aK:r,a=1==n?r.b:3==n&&r.dq,i=(a&&e.stopPropagation(),(2==n?r.b:3==n&&r.dg)&&e.preventDefault(),l);t=i.j;){if("function"==typeof t)o=t(o);else for(var c=t.length;c--;)o=t[c](o);i=i.p}i(o,a)}}return u.q=e,u}(n,a),e.addEventListener(t,i,en&&{passive:qt(a)<2}),o[t]=i}else e.removeEventListener(t,i),o[t]=void 0}}(e,n,o):"a3"===t?function(e,n){for(var r in n){var t=n[r];void 0!==t?e.setAttribute(r,t):e.removeAttribute(r)}}(e,o):"a4"===t?function(e,n){for(var r in n){var t=n[r],o=t.f,t=t.o;void 0!==t?e.setAttributeNS(o,r,t):e.removeAttributeNS(o,r)}}(e,o):("value"!==t&&"checked"!==t||e[t]!==o)&&(e[t]=o)}}try{window.addEventListener("t",null,Object.defineProperty({},"passive",{get:function(){en=!0}}))}catch(e){}function an(e,n){var r=[];return A(e,n,r,0),r}function S(e,n,r,t){n={$:n,r:r,s:t,t:void 0,u:void 0};return e.push(n),n}function A(e,n,r,t){if(e!==n){var o=e.$,a=n.$;if(o!==a){if(1!==o||2!==a)return void S(r,0,t,n);n=function(e){for(var n=e.e,r=n.length,t=Array(r),o=0;o<r;o++)t[o]=n[o].b;return{$:1,c:e.c,d:e.d,e:t,f:e.f,b:e.b}}(n),a=1}switch(a){case 5:for(var i=e.l,c=n.l,l=i.length,u=l===c.length;u&&l--;)u=i[l]===c[l];if(u)return void(n.k=e.k);n.k=n.m();var s=[];return A(e.k,n.k,s,0),void(0<s.length&&S(r,1,t,s));case 4:for(var f=e.j,d=n.j,v=!1,m=e.k;4===m.$;)v=!0,"object"!=typeof f?f=[f,m.j]:f.push(m.j),m=m.k;for(var p=n.k;4===p.$;)v=!0,"object"!=typeof d?d=[d,p.j]:d.push(p.j),p=p.k;return v&&f.length!==d.length?void S(r,0,t,n):((v?function(e,n){for(var r=0;r<e.length;r++)if(e[r]!==n[r])return;return 1}(f,d):f===d)||S(r,2,t,d),void A(m,p,r,t+1));case 0:return void(e.a!==n.a&&S(r,3,t,n.a));case 1:return void cn(e,n,r,t,un);case 2:return void cn(e,n,r,t,sn);case 3:if(e.h!==n.h)return void S(r,0,t,n);s=ln(e.d,n.d),s=(s&&S(r,4,t,s),n.i(e.g,n.g));s&&S(r,5,t,s)}}}function cn(e,n,r,t,o){var a;e.c!==n.c||e.f!==n.f?S(r,0,t,n):((a=ln(e.d,n.d))&&S(r,4,t,a),o(e,n,r,t))}function ln(e,n,r){var t,o,a,i,c;for(o in e)"a1"===o||"a0"===o||"a3"===o||"a4"===o?(a=ln(e[o],n[o]||{},o))&&((t=t||{})[o]=a):o in n?(a=e[o])===(i=n[o])&&"value"!==o&&"checked"!==o||"a0"===r&&function(e,n){return e.$==n.$&&Te(e.a,n.a)}(a,i)||((t=t||{})[o]=i):(t=t||{})[o]=r?"a1"===r?"":"a0"===r||"a3"===r?void 0:{f:e[o].f,o:void 0}:"string"==typeof e[o]?"":null;for(c in n)c in e||((t=t||{})[c]=n[c]);return t}function un(e,n,r,t){var o=e.e,a=n.e,e=o.length,n=a.length;n<e?S(r,6,t,{v:n,i:e-n}):e<n&&S(r,7,t,{v:e,e:a});for(var i=e<n?e:n,c=0;c<i;c++){var l=o[c];A(l,a[c],r,++t),t+=l.b||0}}function sn(e,n,r,t){for(var o=[],a={},i=[],c=e.e,l=n.e,u=c.length,s=l.length,f=0,d=0,v=t;f<u&&d<s;){var m=c[f],p=l[d],g=m.a,h=p.a,b=m.b,x=p.b,C=void 0,y=void 0;if(g===h)A(b,x,o,++v),v+=b.b||0,f++,d++;else{var P,T,L,M,_=c[f+1],w=l[d+1];if(_&&(T=_.b,y=h===(P=_.a)),w&&(M=w.b,C=g===(L=w.a)),C&&y)A(b,M,o,++v),dn(a,o,g,x,d,i),v+=b.b||0,vn(a,o,g,T,++v),v+=T.b||0,f+=2,d+=2;else if(C)v++,dn(a,o,h,x,d,i),A(b,M,o,v),v+=b.b||0,f+=1,d+=2;else if(y)vn(a,o,g,b,++v),v+=b.b||0,A(T,x,o,++v),v+=T.b||0,f+=2,d+=1;else{if(!_||P!==L)break;vn(a,o,g,b,++v),dn(a,o,h,x,d,i),v+=b.b||0,A(T,M,o,++v),v+=T.b||0,f+=2,d+=2}}}for(;f<u;){b=(m=c[f]).b;vn(a,o,m.a,b,++v),v+=b.b||0,f++}for(;d<s;){var N=N||[];dn(a,o,(p=l[d]).a,p.b,void 0,N),d++}(0<o.length||0<i.length||N)&&S(r,8,t,{w:o,x:i,y:N})}var fn="_elmW6BL";function dn(e,n,r,t,o,a){var i,c=e[r];c?1===c.c?(a.push({r:o,A:c}),c.c=2,A(c.z,t,i=[],c.r),c.r=o,c.s.s={w:i,A:c}):dn(e,n,r+fn,t,o,a):(a.push({r:o,A:c={c:0,z:t,r:o,s:void 0}}),e[r]=c)}function vn(e,n,r,t,o){var a,i=e[r];i?0===i.c?(i.c=2,A(t,i.z,a=[],o),S(n,9,o,{w:a,A:i})):vn(e,n,r+fn,t,o):(a=S(n,9,o,void 0),e[r]={c:1,z:t,r:o,s:a})}function mn(e,n,r,t){!function e(n,r,t,o,a,i,c){var l=t[o];var u=l.r;for(;u===a;){var s,f=l.$;if(1===f?mn(n,r.k,l.s,c):8===f?(l.t=n,l.u=c,0<(s=l.s.w).length&&e(n,r,s,0,a,i,c)):9===f?(l.t=n,l.u=c,(f=l.s)&&(f.A.s=n,0<(s=f.w).length)&&e(n,r,s,0,a,i,c)):(l.t=n,l.u=c),!(l=t[++o])||(u=l.r)>i)return o}var d=r.$;if(4===d){for(var v=r.k;4===v.$;)v=v.k;return e(n,v,t,o,a+1,i,n.elm_event_node_ref)}var m=r.e;var p=n.childNodes;for(var g=0;g<m.length;g++){var h=1===d?m[g]:m[g].b,b=++a+(h.b||0);if(a<=u&&u<=b&&(o=e(p[g],h,t,o,a,b,c),!(l=t[o])||(u=l.r)>i))return o;a=b}return o}(e,n,r,0,0,n.b,t)}function pn(e,n,r,t){return 0===r.length?e:(mn(e,n,r,t),gn(e,r))}function gn(e,n){for(var r=0;r<n.length;r++){var t=n[r],o=t.t,t=function(e,n){switch(n.$){case 0:return function(e,n,r){var t=e.parentNode,n=tn(n,r);n.elm_event_node_ref||(n.elm_event_node_ref=e.elm_event_node_ref);t&&n!==e&&t.replaceChild(n,e);return n}(e,n.s,n.u);case 4:return on(e,n.u,n.s),e;case 3:return e.replaceData(0,e.length,n.s),e;case 1:return gn(e,n.s);case 2:return e.elm_event_node_ref?e.elm_event_node_ref.j=n.s:e.elm_event_node_ref={j:n.s,p:n.u},e;case 6:for(var r=n.s,t=0;t<r.i;t++)e.removeChild(e.childNodes[r.v]);return e;case 7:for(var o=(r=n.s).e,t=r.v,a=e.childNodes[t];t<o.length;t++)e.insertBefore(tn(o[t],n.u),a);return e;case 9:var i;return(r=n.s)?(void 0!==(i=r.A).r&&e.parentNode.removeChild(e),i.s=gn(e,r.w)):e.parentNode.removeChild(e),e;case 8:return function(e,n){for(var r=n.s,t=function(e,n){if(e){for(var r=Ue.createDocumentFragment(),t=0;t<e.length;t++){var o=e[t].A;r.appendChild(2===o.c?o.s:tn(o.z,n.u))}return r}}(r.y,n),o=(e=gn(e,r.w),r.x),a=0;a<o.length;a++){var i=o[a],c=i.A,c=2===c.c?c.s:tn(c.z,n.u);e.insertBefore(c,e.childNodes[i.r])}t&&e.appendChild(t);return e}(e,n);case 5:return n.s(e);default:ee(10)}}(o,t);o===e&&(e=t)}return e}function hn(e){if(3===e.nodeType)return{$:0,a:e.textContent};if(1!==e.nodeType)return{$:0,a:""};for(var n=p,r=e.attributes,t=r.length;t--;)var o=r[t],n={$:1,a:D(Xe,o.name,o.value),b:n};for(var a=e.tagName.toLowerCase(),i=p,c=e.childNodes,t=c.length;t--;)i={$:1,a:hn(c[t]),b:i};return z(Ye,a,n,i)}var bn=u(function(n,e,r,i){return qe(e,i,n.fT,n.gu,n.go,function(r,e){var t=n.gx,o=i.node,a=hn(o);return yn(e,function(e){var e=t(e),n=an(a,e);o=pn(o,a,n,r),a=e})})}),xn="undefined"!=typeof cancelAnimationFrame?cancelAnimationFrame:function(e){clearTimeout(e)},Cn="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:function(e){return setTimeout(e,1e3/60)};function yn(r,t){t(r);var o=0;function a(){o=1===o?0:(Cn(a),t(r),1)}return function(e,n){r=e,n?(t(r),2===o&&(o=1)):(0===o&&Cn(a),o=2)}}var Pn={addEventListener:function(){},removeEventListener:function(){}},Tn="undefined"!=typeof document?document:Pn,Ln="undefined"!=typeof window?window:Pn,Mn=d(function(r,t,o){return De({$:2,b:function(e){function n(e){Ne(o(e))}return r.addEventListener(t,n,en&&{passive:!0}),function(){r.removeEventListener(t,n)}},c:null})}),_n=f(function(e,n){e=h(e,n);return T(e)?C(e.a):y});Pn=f(function(r,t){return{$:2,b:function(e){var n=setInterval(function(){Ne(t)},r);return function(){clearInterval(n)}},c:null}});var wn=0;function Nn(e,n){for(;n.b;n=n.b)e(n.a)}function Dn(e){for(var n=0;e.b;e=e.b)n++;return n}function zn(e){e.scissor.enabled&&(e.gl.disable(e.gl.SCISSOR_TEST),e.scissor.enabled=!1)}function Vn(e){var n=e.colorMask;n.a&&n.b&&n.c&&n.d||(e.gl.colorMask(!0,!0,!0,!0),n.a=!0,n.b=!0,n.c=!0,n.d=!0)}var $n="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:function(e){setTimeout(e,1e3/60)},Sn=l(function(e,n,r,t,o){return{$:0,a:e,b:n,c:r,d:t,e:o}}),An=f(function(e,n){var r=e.blend;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.BLEND),r.enabled=!0),r.a===n.a&&r.d===n.d||(e.gl.blendEquationSeparate(n.a,n.d),r.a=n.a,r.d=n.d),r.b===n.b&&r.c===n.c&&r.e===n.e&&r.f===n.f||(e.gl.blendFuncSeparate(n.b,n.c,n.e,n.f),r.b=n.b,r.c=n.c,r.e=n.e,r.f=n.f),r.g===n.g&&r.h===n.h&&r.i===n.i&&r.j===n.j||(e.gl.blendColor(n.g,n.h,n.i,n.j),r.g=n.g,r.h=n.h,r.i=n.i,r.j=n.j)}),qn=f(function(e,n){var r=e.depthTest;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.DEPTH_TEST),r.enabled=!0),r.a!==n.a&&(e.gl.depthFunc(n.a),r.a=n.a),r.b!==n.b&&(e.gl.depthMask(n.b),r.b=n.b),r.c===n.c&&r.d===n.d||(e.gl.depthRange(n.c,n.d),r.c=n.c,r.d=n.d)}),kn=f(function(e,n){var r=e.stencilTest;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.STENCIL_TEST),r.enabled=!0),r.d===n.d&&r.a===n.a&&r.b===n.b||(e.gl.stencilFuncSeparate(e.gl.FRONT,n.d,n.a,n.b),r.d=n.d),r.e===n.e&&r.f===n.f&&r.g===n.g||(e.gl.stencilOpSeparate(e.gl.FRONT,n.e,n.f,n.g),r.e=n.e,r.f=n.f,r.g=n.g),r.c!==n.c&&(e.gl.stencilMask(n.c),r.c=n.c),r.h===n.h&&r.a===n.a&&r.b===n.b||(e.gl.stencilFuncSeparate(e.gl.BACK,n.h,n.a,n.b),r.h=n.h,r.a=n.a,r.b=n.b),r.i===n.i&&r.j===n.j&&r.k===n.k||(e.gl.stencilOpSeparate(e.gl.BACK,n.i,n.j,n.k),r.i=n.i,r.j=n.j,r.k=n.k)}),Zn=f(function(e,n){var r=e.scissor;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.SCISSOR_TEST),r.enabled=!0),r.a===n.a&&r.b===n.b&&r.c===n.c&&r.d===n.d||(e.gl.scissor(n.a,n.b,n.c,n.d),r.a=n.a,r.b=n.b,r.c=n.c,r.d=n.d)}),Rn=f(function(e,n){var r=e.colorMask;r.toggle=e.toggle,r.enabled=!0,r.a===n.a&&r.b===n.b&&r.c===n.c&&r.d===n.d||(e.gl.colorMask(n.a,n.b,n.c,n.d),r.a=n.a,r.b=n.b,r.c=n.c,r.d=n.d)}),Bn=f(function(e,n){var r=e.cullFace;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.CULL_FACE),r.enabled=!0),r.a!==n.a&&(e.gl.cullFace(n.a),r.a=n.a)}),Fn=f(function(e,n){var r=e.polygonOffset;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.POLYGON_OFFSET_FILL),r.enabled=!0),r.a===n.a&&r.b===n.b||(e.gl.polygonOffset(n.a,n.b),r.a=n.a,r.b=n.b)}),En=f(function(e,n){var r=e.sampleCoverage;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.SAMPLE_COVERAGE),r.enabled=!0),r.a===n.a&&r.b===n.b||(e.gl.sampleCoverage(n.a,n.b),r.a=n.a,r.b=n.b)}),Gn=["blend","depthTest","stencilTest","scissor","colorMask","cullFace","polygonOffset","sampleCoverage","sampleAlphaToCoverage"],jn=[function(e){e.blend.enabled&&(e.gl.disable(e.gl.BLEND),e.blend.enabled=!1)},function(e){e.depthTest.enabled&&(e.gl.disable(e.gl.DEPTH_TEST),e.depthTest.enabled=!1)},function(e){e.stencilTest.enabled&&(e.gl.disable(e.gl.STENCIL_TEST),e.stencilTest.enabled=!1)},zn,Vn,function(e){e.gl.disable(e.gl.CULL_FACE)},function(e){e.gl.disable(e.gl.POLYGON_OFFSET_FILL)},function(e){e.gl.disable(e.gl.SAMPLE_COVERAGE)},function(e){e.gl.disable(e.gl.SAMPLE_ALPHA_TO_COVERAGE)}];function In(e,n,r){r=e.createShader(r);return e.shaderSource(r,"#extension GL_OES_standard_derivatives : enable\n"+n),e.compileShader(r),r}function Hn(e,n){switch(n){case e.FLOAT:return{size:1,arraySize:1,type:Float32Array,baseType:e.FLOAT};case e.FLOAT_VEC2:return{size:2,arraySize:1,type:Float32Array,baseType:e.FLOAT};case e.FLOAT_VEC3:return{size:3,arraySize:1,type:Float32Array,baseType:e.FLOAT};case e.FLOAT_VEC4:return{size:4,arraySize:1,type:Float32Array,baseType:e.FLOAT};case e.FLOAT_MAT4:return{size:4,arraySize:4,type:Float32Array,baseType:e.FLOAT};case e.INT:return{size:1,arraySize:1,type:Int32Array,baseType:e.INT}}}function Un(e,n,r,t){for(var c=r.a.dN,l=[],o=0;o<c;o++)l.push(String.fromCharCode(97+o));var a=Hn(e,n.type);if(void 0===a)throw Error("No info available for: "+n.type);var i=0,u=a.size*a.arraySize*c,s=new a.type(Dn(r.b)*u),r=(Nn(function(e){!function(n,r,t,o,a){var i;if(1===c)for(i=0;i<r;i++)n[t++]=1===r?o[a]:o[a][i];else l.forEach(function(e){for(i=0;i<r;i++)n[t++]=1===r?o[e][a]:o[e][a][i]})}(s,a.size*a.arraySize,i,e,t[n.name]||n.name),i+=u},r.b),e.createBuffer());return e.bindBuffer(e.ARRAY_BUFFER,r),e.bufferData(e.ARRAY_BUFFER,s,e.STATIC_DRAW),r}function On(e,n){var r,t;return 0<n.a.dY?(r=e.createBuffer(),t=function(e,n){var r,t=new Uint32Array(Dn(e)*n),o=0;return Nn(function(e){if(1===n)t[o++]=e;else for(r=0;r<n;r++)t[o++]=e[String.fromCharCode(97+r)]},e),t}(n.c,n.a.dY),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,r),e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW),{numIndices:t.length,indexBuffer:r,buffers:{}}):{numIndices:n.a.dN*Dn(n.b),indexBuffer:null,buffers:{}}}var Yn=f(function(b,e){var x=b.f,C=x.gl;return C&&(C.viewport(0,0,C.drawingBufferWidth,C.drawingBufferHeight),x.depthTest.b||(C.depthMask(!0),x.depthTest.b=!0),x.stencilTest.c!==x.STENCIL_WRITEMASK&&(C.stencilMask(x.STENCIL_WRITEMASK),x.stencilTest.c=x.STENCIL_WRITEMASK),zn(x),Vn(x),C.clear(C.COLOR_BUFFER_BIT|C.DEPTH_BUFFER_BIT|C.STENCIL_BUFFER_BIT),Nn(function(e){if(e.d.b.b){var n,r,t;if(!(i=e.b.id&&e.c.id?x.programs[n=e.b.id+"#"+e.c.id]:i)){e.b.id?o=x.shaders[e.b.id]:e.b.id=wn++,o||(o=In(C,e.b.src,C.VERTEX_SHADER),x.shaders[e.b.id]=o),e.c.id?a=x.shaders[e.c.id]:e.c.id=wn++,a||(a=In(C,e.c.src,C.FRAGMENT_SHADER),x.shaders[e.c.id]=a);for(var o,a,i,c=function(e,n,r){var t=e.createProgram();if(e.attachShader(t,n),e.attachShader(t,r),e.linkProgram(t),e.getProgramParameter(t,e.LINK_STATUS))return t;throw"Link failed: "+e.getProgramInfoLog(t)+"\nvs info-log: "+e.getShaderInfoLog(n)+"\nfs info-log: "+e.getShaderInfoLog(r)}(C,o,a),l=((i={glProgram:c,attributes:Object.assign({},e.b.attributes,e.c.attributes),currentUniforms:{},activeAttributes:[],activeAttributeLocations:[]}).uniformSetters=function(a,e,n,r){var t=n.glProgram,i=n.currentUniforms,c=0,l=e.f;for(var o={},u=a.getProgramParameter(t,a.ACTIVE_UNIFORMS),s=0;s<u;s++){var f=a.getActiveUniform(t,s);o[r[f.name]||f.name]=function(e,n){var r=n.name,t=a.getUniformLocation(e,r);switch(n.type){case a.INT:return function(e){i[r]!==e&&(a.uniform1i(t,e),i[r]=e)};case a.FLOAT:return function(e){i[r]!==e&&(a.uniform1f(t,e),i[r]=e)};case a.FLOAT_VEC2:return function(e){i[r]!==e&&(a.uniform2f(t,e[0],e[1]),i[r]=e)};case a.FLOAT_VEC3:return function(e){i[r]!==e&&(a.uniform3f(t,e[0],e[1],e[2]),i[r]=e)};case a.FLOAT_VEC4:return function(e){i[r]!==e&&(a.uniform4f(t,e[0],e[1],e[2],e[3]),i[r]=e)};case a.FLOAT_MAT4:return function(e){i[r]!==e&&(a.uniformMatrix4fv(t,!1,new Float32Array(e)),i[r]=e)};case a.SAMPLER_2D:var o=c++;return function(e){a.activeTexture(a.TEXTURE0+o);var n=l.textures.get(e);n||(n=e.fq(a),l.textures.set(e,n)),a.bindTexture(a.TEXTURE_2D,n),i[r]!==e&&(a.uniform1i(t,o),i[r]=e)};case a.BOOL:return function(e){i[r]!==e&&(a.uniform1i(t,e),i[r]=e)};default:return function(){}}}(t,f)}return o}(C,b,i,Object.assign({},e.b.uniforms,e.c.uniforms)),C.getProgramParameter(c,C.ACTIVE_ATTRIBUTES)),u=0;u<l;u++){var s=C.getActiveAttrib(c,u),f=C.getAttribLocation(c,s.name);i.activeAttributes.push(s),i.activeAttributeLocations.push(f)}x.programs[n=e.b.id+"#"+e.c.id]=i}x.lastProgId!==n&&(C.useProgram(i.glProgram),x.lastProgId=n),r=i.uniformSetters,Object.keys(t=e.e).forEach(function(e){var n=r[e];n&&n(t[e])});var d=x.buffers.get(e.d);for(d||(d=On(C,e.d),x.buffers.set(e.d,d)),u=0;u<i.activeAttributes.length;u++){f=i.activeAttributeLocations[u],void 0===d.buffers[(s=i.activeAttributes[u]).name]&&(d.buffers[s.name]=Un(C,s,e.d,i.attributes)),C.bindBuffer(C.ARRAY_BUFFER,d.buffers[s.name]);var v=Hn(C,s.type);if(1===v.arraySize)C.enableVertexAttribArray(f),C.vertexAttribPointer(f,v.size,v.baseType,!1,0,0);else for(var m=4*v.size,p=m*v.arraySize,g=0;g<v.arraySize;g++)C.enableVertexAttribArray(f+g),C.vertexAttribPointer(f+g,v.size,v.baseType,!1,p,m*g)}for(x.toggle=!x.toggle,Nn(Hi(x),e.a),u=0;u<9;u++){var h=x[Gn[u]];h.toggle!==x.toggle&&h.enabled&&(jn[u](x),h.enabled=!1,h.toggle=x.toggle)}d.indexBuffer?(C.bindBuffer(C.ELEMENT_ARRAY_BUFFER,d.indexBuffer),C.drawElements(e.d.a.ew,d.numIndices,C.UNSIGNED_INT,0)):C.drawArrays(e.d.a.ew,0,d.numIndices)}},b.g)),e});var Wn=d(function(e,n,r){return function(e,n,r,t){return{$:3,d:nn(e),g:n,h:r,i:t}}(n,{g:r,f:{},h:e},Kn,Qn)});function Kn(e){var n={contextAttributes:{alpha:!1,depth:!1,stencil:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1},sceneSettings:[]},r=(Nn(function(e){},e.h),Ue.createElement("canvas")),t=r.getContext&&(r.getContext("webgl",n.contextAttributes)||r.getContext("experimental-webgl",n.contextAttributes));return t&&void 0!==WeakMap?(n.sceneSettings.forEach(function(e){e(t)}),t.getExtension("OES_standard_derivatives"),t.getExtension("OES_element_index_uint"),e.f.gl=t,e.f.toggle=!1,e.f.blend={enabled:!1,toggle:!1},e.f.depthTest={enabled:!1,toggle:!1},e.f.stencilTest={enabled:!1,toggle:!1},e.f.scissor={enabled:!1,toggle:!1},e.f.colorMask={enabled:!1,toggle:!1},e.f.cullFace={enabled:!1,toggle:!1},e.f.polygonOffset={enabled:!1,toggle:!1},e.f.sampleCoverage={enabled:!1,toggle:!1},e.f.sampleAlphaToCoverage={enabled:!1,toggle:!1},e.f.shaders=[],e.f.programs={},e.f.lastProgId=null,e.f.buffers=new WeakMap,e.f.textures=new WeakMap,e.f.STENCIL_WRITEMASK=t.getParameter(t.STENCIL_WRITEMASK),$n(function(){return D(Yn,e,r)})):(r=Ue.createElement("div")).innerHTML='<a href="https://get.webgl.org/">Enable WebGL</a> to see this content!',r}function Qn(e,n){return n.f=e.f,Yn(n)}var Xn=f(function(e,n){return new Float64Array([e,n])});new Float64Array(3),new Float64Array(3),new Float64Array(3);var Jn=d(function(e,n,r){return new Float64Array([e,n,r])});var er=f(function(e,n){return new Float64Array([n[0]*e,n[1]*e,n[2]*e])});var nr=u(function(e,n,r,t){return new Float64Array([e,n,r,t])});new Float64Array(16),new Float64Array(16),new Float64Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);function rr(e){return z(ft,f(function(e,n){return n+1}),0,e)}function tr(e){return e}function or(e){return e}function ar(e){return z(Zt,Bt(x),L(p),e)}function ir(e){return Xt(2*Qt*e)}function cr(e){return{$:0,a:e}}function lr(e){return{$:2,a:e}}function ur(e){return{$:3,a:e}}function sr(e){return{a:U(e.a?"w_":"d_",e.b),b:e}}function fr(e){return z(ft,f(function(e,n){return z(lo,e.a,e.b,n)}),Ot,e)}function dr(e){return e}function vr(e){return e}function mr(e){var n,r=D(P,N(e.Z),D(P,N(e._),N(e.e8)));return r?Yo((n=e.Z/r)*n+(n=e._/r)*n+(n=e.e8/r)*n)*r:Wo}function pr(e){return e}function gr(e){return e.b?C(e.a):y}function hr(e){return Xt(Qt*(e/180))}function br(e){return e.c6}function xr(e){return e.dA}function Cr(e){return e.fu}function b(e){return e}function yr(e){return function(e){return e}(e.fc)}function Pr(e){return e.ft}function Tr(e){return br(e)}function Lr(e){return{Z:-e.Z,_:-e._,e8:-e.e8}}function Mr(e){return Lr(xr(e))}function _r(e){var n=e.b;return D(hi,1664525*e.a+n>>>0,n)}function wr(e){return((e=277803737*((e=e.a)^e>>>4+(e>>>28)))>>>22^e)>>>0}function Nr(e){var n,r,t,o,a,i,c,l;return-1===e.$&&-1===e.d.$&&-1===e.e.$?-1!==e.e.d.$||e.e.d.a?(t=(l=e.e).b,o=l.c,a=l.d,l=l.e,$(w,1,e.b,e.c,$(w,0,(n=e.d).b,n.c,n.d,n.e),$(w,0,t,o,a,l))):(t=(r=e.e).b,o=r.c,i=(a=r.d).d,c=a.e,l=r.e,$(w,0,a.b,a.c,$(w,1,e.b,e.c,$(w,0,(n=e.d).b,n.c,n.d,n.e),i),$(w,1,t,o,c,l))):e}function Dr(e){var n,r,t,o,a,i,c,l,u;return-1===e.$&&-1===e.d.$&&-1===e.e.$?-1!==e.d.d.$||e.d.d.a?(i=(u=e.e).b,c=u.c,l=u.d,u=u.e,$(w,1,n=e.b,r=e.c,$(w,0,(o=e.d).b,o.c,o.d,o=o.e),$(w,0,i,c,l,u))):(n=e.b,r=e.c,o=(t=e.d).e,i=(a=e.e).b,c=a.c,l=a.d,u=a.e,$(w,0,t.b,t.c,$(w,1,(a=t.d).b,a.c,a.d,a.e),$(w,1,n,r,o,$(w,0,i,c,l,u)))):e}function zr(e){var n,r,t,o,a,i;return-1===e.$&&-1===e.d.$?(n=e.a,r=e.b,t=e.c,i=(o=e.d).d,a=e.e,1===o.a?-1!==i.$||i.a?-1===(i=Nr(e)).$?(e=i.e,$(io,i.a,i.b,i.c,zr(i.d),e)):Ut:$(w,n,r,t,zr(o),a):$(w,n,r,t,zr(o),a)):Ut}function Vr(e){return z(Zt,zi,p,e)}function $r(e){return We(function(e){return Je.test(e)?"p":e}(e))}function Sr(e){function n(e){return ei(1e4*e)/100}var r=e.b,t=e.c,o=e.d;return e=g(["rgba(",c(n(e.a)),"%,",c(n(r)),"%,",c(n(t)),"%,",c(ei(1e3*o)/1e3),")"]),D(st,"",e)}function Ar(e){return e}function qr(s){return function(u){return function(l){return function(c){return function(i){return function(a){return function(o){return function(t){return function(r){return function(n){return function(e){return{$:2,a:s,b:u,c:l,d:c,e:i,f:a,g:o,h:t,i:r,j:n,k:e}}}}}}}}}}}}function kr(e){return z(uc,{cY:e.cY,dj:e.dj,dx:e.dx},{bD:e.bD,bU:e.bU,b0:e.b0,b1:e.b1},{bD:e.bD,bU:e.bU,b0:e.b0,b1:e.b1})}function Zr(e){return $(R,g([kr(e),V(tc,!1,!1,!1,!1)]),lc,ic,cc,{})}function Rr(e){return Zr({bD:7680,cY:15,dj:8,bU:516,dx:D(fc,2,e+4),b0:5386,b1:5386})}function Br(e){return{a:D(ti,Cc(e),hc(e)),b:D(ti,yc(e),bc(e)),c:D(ti,Pc(e),xc(e))}}function Fr(e){return e}function Er(e){return e}function Gr(e){return kc(D(Zc,e,p))}function jr(e){return V(oc,515,e.at,e.ao,e.al)}function Ir(e){return e}function Hr(n){var e=function(e){return e.gy}(n.fk),r=pa({c6:Tr(e),dy:function(e){return ga(e)}(e),dz:function(e){return ha(e)}(e),dA:Lr(Mr(e))}),t=Gr(n.fC);if(1===(r=V($c,r,1,y,g([t]))).$)return p;var r=r.a,o=D(Yc,Oc,e),a=D(ka,.99,D(_c,q(n.fp),ia(xc(r)))),i=Br(r),i=mr(z(Ka,i.a,i.b,i.c)),r=D(ka,1.01,D(Dc,i,ia(Pc(r)))),e=(a=Uc(r=D(jc,n.fk,{fb:n.fb,fJ:r,f2:a})).en)?Er(Lr(Mr(e))):b(Tr(e)),c=(l=function(){var e=n.aO;switch(e.$){case 0:return{a:0,b:0};case 1:return{a:1,b:0};case 2:return{a:2,b:0};case 3:return{a:3,b:e.a};case 4:return{a:4,b:e.a};default:return{a:5,b:0}}}()).a,l=l.b,u=D(Xi,n.aG,n.aR),i=ec({d8:0,d9:e.Z,ea:Sc(u),eb:n.eZ,ec:0,ed:e._,ee:Ac(u),ef:vr(i),eg:0,eh:e.e8,ei:qc(u),ej:c,ek:0,el:a,em:0,en:l}),s=E(rc,i,o,r,Rc,t,{V:p,ah:p,aj:p}),f=n.aI;switch(f.$){case 0:var d=f.a;return Vr(g([z(Z,s.V,{a:d,b:Yi},gc),z(Z,s.ah,Fc,gc)]));case 1:d=f.a;return Vr(g([z(Z,s.V,Fc,gc),g([Bc]),z(Z,s.aj,d.bK,ac),g([Rr(0)]),z(Z,s.V,{a:d,b:Yi},Ec),z(Z,s.ah,Fc,gc)]));default:var d=f.a,v=f.b;return Vr(g([z(Z,s.V,{a:v,b:Yi},gc),g([Bc]),D(vc,s.aj,d),z(Hc,s.V,v,rr(d)),z(Z,s.ah,Fc,gc)]))}}function Ur(e){return D(hl,0,{$:0,a:function(e){e=bl(e);return z(Qi,e.di,e.cN,e.cH)}(e)})}function Or(e){return e}function Yr(e){return{$:5,a:e}}function Wr(e){var n=(t=Br(e)).a,r=t.b,t=t.c;return{fm:Ir(function(e){return z(nu,Xl(e),Jl(e),eu(e))}(e)),fM:n/2,fN:r/2,fO:t/2}}function Kr(e){return D(vu,e.dH,e.n)}var Qr,Xr=1,Jr=2,et=0,x=Y,nt=d(function(e,n,r){for(;;){if(-2===r.$)return n;var t=r.d,o=e,a=z(e,r.b,r.c,z(nt,e,n,r.e));e=o,n=a,r=t}}),rt=function(e){return z(nt,d(function(e,n,r){return D(x,{a:e,b:n},r)}),p,e)},tt=function(e){return{$:1,a:e}},ot=f(function(e,n){return{$:3,a:e,b:n}}),at=f(function(e,n){return{$:0,a:e,b:n}}),it=f(function(e,n){return{$:1,a:e,b:n}}),ct=function(e){return{$:0,a:e}},lt=function(e){return{$:2,a:e}},C=function(e){return{$:0,a:e}},y={$:1},ut=de,st=f(function(e,n){return D(fe,e,W(n))}),Y=f(function(e,n){return g(D(se,e,n))}),ft=d(function(e,n,r){for(;;){if(!r.b)return n;var t=r.b,o=e,a=D(e,r.a,n);e=o,n=a,r=t}}),dt=K,vt=d(function(e,n,r){for(;;){if(1<=v(e,n))return r;var t=e,o=n-1,a=D(x,n,r);e=t,n=o,r=a}}),mt=f(function(e,n){return z(vt,e,n,p)}),pt=f(function(e,n){return z(dt,e,D(mt,0,rr(n)-1),n)}),gt=function(e){return z(ft,x,p,e)},ht=u(function(e,n,r,t){return{$:0,a:e,b:n,c:r,d:t}}),bt=[],xt=ae,Ct=f(function(e,n){return ue(n)/ue(e)}),yt=xt(D(Ct,2,32)),Pt=V(ht,0,yt,bt,bt),Tt=X,Lt=ie,Mt=function(e){return e.length},P=f(function(e,n){return 0<v(e,n)?e:n}),_t=J,wt=f(function(e,n){for(;;){var r=D(_t,32,e),t=r.b,r=D(x,{$:0,a:r.a},n);if(!t.b)return gt(r);e=t,n=r}}),Nt=f(function(e,n){for(;;){var r=xt(n/32);if(1===r)return D(_t,32,e).a;e=D(wt,e,p),n=r}}),Dt=f(function(e,n){var r,t;return n.s?(t=Lt(D(Ct,32,(r=32*n.s)-1)),e=e?gt(n.F):n.F,e=D(Nt,e,n.s),V(ht,Mt(n.v)+r,D(P,5,t*yt),e,n.v)):V(ht,Mt(n.v),yt,bt,n.v)}),zt=l(function(e,n,r,t,o){for(;;){if(n<0)return D(Dt,!1,{F:t,s:r/32|0,v:o});var a={$:1,a:z(Tt,32,n,e)};e=e,n=n-32,r=r,t=D(x,a,t),o=o}}),Vt=f(function(e,n){var r;return 0<e?$(zt,n,e-(r=e%32)-32,e,p,z(Tt,r,e-r,n)):Pt}),T=function(e){return!e.$},$t=ge,St=he,At=function(e){return{$:0,a:e}},qt=function(e){switch(e.$){case 0:return 0;case 1:return 1;case 2:return 2;default:return 3}},L=Me,K=L(0),kt=u(function(e,n,r,t){var o,a,i,c;return t.b?(o=t.a,(t=t.b).b?(a=t.a,(t=t.b).b?(i=t.a,(t=t.b).b?(c=t.b,D(e,o,D(e,a,D(e,i,D(e,t.a,500<r?z(ft,e,n,gt(c)):V(kt,e,n,r+1,c)))))):D(e,o,D(e,a,D(e,i,n)))):D(e,o,D(e,a,n))):D(e,o,n)):n}),Zt=d(function(e,n,r){return V(kt,e,n,0,r)}),M=f(function(r,e){return z(Zt,f(function(e,n){return D(x,r(e),n)}),p,e)}),_=_e,Rt=f(function(n,e){return D(_,function(e){return L(n(e))},e)}),Bt=d(function(r,e,t){return D(_,function(n){return D(_,function(e){return L(D(r,n,e))},t)},e)}),Ft=Ze,Et=f(function(e,n){return De(D(_,Ft(e),n))}),ae=d(function(e,n,r){return D(Rt,function(e){return 0},ar(D(M,Et(e),n)))}),X=(ke.Task={b:K,c:ae,d:d(function(e,n,r){return L(0)}),e:f(function(e,n){return D(Rt,e,n)}),f:void 0},Be("Task"),bn),Gt=F(function(e,n,r,t,o,a,i){return{dH:r,am:o,N:i,bH:e,n:t,bM:a,ey:n}}),jt={$:0},It=u(function(e,n,r,t){return{$:0,a:e,b:n,c:r,d:t}}),Ht=V(It,92/255,53/255,.4,1),Ut={$:-2},Ot=Ut,Yt=Ot,Wt=d(function(e,n,r){return{Z:e,_:n,e8:r}}),Kt=Fe(p),Qt=3.141592653589793,Xt=function(e){return e},Jt={$:4},eo=Fe,no=d(function(e,n,r){return n(e(r))}),ro=f(function(e,n){return{$:0,a:e,b:n}}),to=f(function(e,n){return{eK:n,e_:e}}),ie=L(D(to,Ot,Ot)),oo=I,ao=f(function(e,n){for(;;){if(-2===n.$)return y;var r=n.c,t=n.d,o=n.e;switch(D(oo,e,n.b)){case 0:e=e,n=t;continue;case 1:return C(r);default:e=e,n=o;continue}}}),w=l(function(e,n,r,t,o){return{$:-1,a:e,b:n,c:r,d:t,e:o}}),io=l(function(e,n,r,t,o){var a,i,c,l;return-1!==o.$||o.a?-1!==t.$||t.a||-1!==t.d.$||t.d.a?$(w,e,n,r,t,o):(a=t.d,l=t.e,$(w,0,t.b,t.c,$(w,1,a.b,a.c,a.d,a.e),$(w,1,n,r,l,o))):(a=o.b,i=o.c,c=o.d,o=o.e,-1!==t.$||t.a?$(w,e,a,i,$(w,0,n,r,t,c),o):$(w,0,n,r,$(w,1,t.b,t.c,t.d,l=t.e),$(w,1,a,i,c,o)))}),co=d(function(e,n,r){if(-2===r.$)return $(w,0,e,n,Ut,Ut);var t=r.a,o=r.b,a=r.c,i=r.d,c=r.e;switch(D(oo,e,o)){case 0:return $(io,t,o,a,z(co,e,n,i),c);case 1:return $(w,t,o,n,i,c);default:return $(io,t,o,a,i,z(co,e,n,c))}}),lo=d(function(e,n,r){e=z(co,e,n,r);return-1!==e.$||e.a?e:$(w,1,e.b,e.c,e.d,e.e)}),uo=f(function(e,n){var r=e.a,e=e.b,t=D(ao,r,n);return z(lo,r,1===t.$?g([e]):D(x,e,t.a),n)}),so=function(r){return{$:2,b:function(e){var n=r.f;2===n.$&&n.c&&n.c(),r.f=null,e({$:0,a:H})},c:null}},fo=d(function(e,n,r){for(;;){if(-2===r.$)return n;var t=r.e,o=e,a=z(e,r.b,r.c,z(fo,e,n,r.d));e=o,n=a,r=t}}),vo=B(function(l,u,s,e,n,r){e=z(fo,d(function(e,n,r){for(;;){var t=r.a,o=r.b;if(!t.b)return{a:t,b:z(s,e,n,o)};var a=t.a,i=a.a,a=a.b,c=t.b;if(0<=v(i,e))return 0<v(i,e)?{a:t,b:z(s,e,n,o)}:{a:c,b:V(u,i,a,n,o)};e=e,n=n,r={a:c,b:z(l,i,a,o)}}}),{a:rt(e),b:r},n),r=e.a,n=e.b;return z(ft,f(function(e,n){return z(l,e.a,e.b,n)}),n,r)}),mo=Re,po=Pn,go=De,ho=d(function(n,e,r){var t,o;return e.b?(o=e.b,e=go(D(po,t=e.a,D(mo,n,t))),D(_,function(e){return z(ho,n,o,z(lo,t,e,r))},e)):L(r)}),J=d(function(n,e,r){var r=r.eK,t=d(function(e,n,r){var t=r.c;return{a:r.a,b:r.b,c:D(_,function(e){return t},so(n))}}),o=z(ft,uo,Ot,e),e=E(vo,d(function(e,n,r){var t=r.b,o=r.c;return{a:D(x,e,r.a),b:t,c:o}}),u(function(e,n,r,t){var o=t.c;return{a:t.a,b:z(lo,e,r,t.b),c:o}}),t,o,r,{a:p,b:Ot,c:L(0)}),a=e.a,i=e.b;return D(_,function(e){return L(D(to,o,e))},D(_,function(e){return z(ho,n,a,i)},e.c))}),bo=or,xo=(Qr=bo,{$:2,b:function(e){e({$:0,a:Qr(Date.now())})},c:null}),ge=d(function(r,e,n){var t,e=D(ao,e,n.e_);return 1===e.$?L(n):(t=e.a,D(_,function(e){return L(n)},D(_,function(n){return ar(D(M,function(e){return D(Ft,r,e(n))},t))},xo)))}),Co=d(function(e,n,r){return e(n(r))}),yo=(ke.Time={b:ie,c:J,d:ge,e:0,f:f(function(e,n){return D(ro,n.a,D(Co,e,n.b))})},Be("Time")),Po=f(function(e,n){return yo(D(ro,e,n))}),To=pe,Lo=ve,Mo=f(function(e,n){return!D(ao,e,n).$}),_o=f(function(e,n){return D(Mo,e,n)}),wo=d(function(e,n,r){return{c5:r,eO:n,eY:e}}),No=L(z(wo,p,y,0)),Do={$:2,b:function(e){e({$:0,a:Date.now()})},c:null},zo={$:2,b:function(e){var n=Cn(function(){e({$:0,a:Date.now()})});return function(){xn(n)}},c:null},he=d(function(e,r,n){var t=n.eO,n=n.c5,o={a:t,b:r};return 1===o.a.$?o.b.b?D(_,function(n){return D(_,function(e){return L(z(wo,r,C(n),e))},Do)},go(D(_,mo(e),zo))):No:o.b.b?L(z(wo,r,t,n)):D(_,function(e){return No},so(o.a.a))}),Ze=d(function(n,r,e){function t(e){return D(Ft,n,e.$?(0,e.a)(r-a):(0,e.a)(bo(r)))}var o=e.eY,a=e.c5;return D(_,function(n){return D(_,function(e){return L(z(wo,o,C(n),r))},ar(D(M,t,o)))},go(D(_,mo(n),zo)))}),Vo=(ke["Browser.AnimationManager"]={b:No,c:he,d:Ze,e:0,f:f(function(e,n){return n.$?{$:1,a:D(Co,e,n.a)}:{$:0,a:D(Co,e,n.a)}})},Be("Browser.AnimationManager")),$o=function(e){return Vo({$:0,a:e})},So=d(function(e,n,r){return{$:0,a:e,b:n,c:r}}),Ao=f(function(e,n){return{eG:n,eY:e}}),K=L(D(Ao,p,Ot)),qo=f(function(e,n){return{dQ:n,d$:e}}),ko=d(function(n,r,e){return D(Rt,function(e){return{a:r,b:e}},z(Mn,e.a?Ln:Tn,e.b,function(e){return D(mo,n,D(qo,r,e))}))}),Zo=f(function(e,n){return z(fo,lo,n,e)}),ae=d(function(o,e,n){var r=d(function(e,n,r){var t=r.c;return{a:r.a,b:r.b,c:D(x,z(ko,o,e,n),t)}}),t=d(function(e,n,r){var t=r.b,o=r.c;return{a:D(x,n,r.a),b:t,c:o}}),a=u(function(e,n,r,t){var o=t.c;return{a:t.a,b:z(lo,e,n,t.b),c:o}}),i=D(M,sr,e),e=E(vo,t,a,r,n.eG,fr(i),{a:p,b:Ot,c:p}),c=e.b,l=e.c;return D(_,function(e){return L(D(Ao,i,D(Zo,c,fr(e))))},D(_,function(e){return ar(l)},ar(D(M,so,e.a))))}),Ro=d(function(e,n,r){e=e(n);return e.$?r:D(x,e.a,r)}),Bo=f(function(e,n){return z(Zt,Ro(e),p,n)}),bn=d(function(e,n,r){var t=n.d$,o=n.dQ,n=D(Bo,function(e){var n=e.b,n=n.c;return s(e.a,t)?D(_n,n,o):y},r.eY);return D(_,function(e){return L(r)},ar(D(M,Ft(e),n)))}),Fo=(ke["Browser.Events"]={b:K,c:ae,d:bn,e:0,f:f(function(e,n){return z(So,n.a,n.b,D($t,e,n.c))})},Be("Browser.Events")),I=d(function(e,n,r){return Fo(z(So,e,n,r))}),Eo=D(I,0,"keydown"),Go=D(I,0,"keyup"),jo=D(I,0,"mousedown"),Io=f(function(e,n){return{Z:e,_:n}}),Ho=me,Uo=f(function(r,e){return z(Zt,f(function(e,n){return r(e)?D(x,e,n):n}),p,e)}),Oo=f(function(e,n){return{Z:n.Z-e.Z,_:n._-e._,e8:n.e8-e.e8}}),N=function(e){return e<0?-e:e},Yo=le,Wo=0,Ko=f(function(e,n){return v(e,n)<0?e:n}),Qo={Z:0,_:0,e8:0},Xo=f(function(e,n){return{Z:n.Z+e.Z,_:n._+e._,e8:n.e8+e.e8}}),Jo={Z:0,_:0,e8:0},ea=f(function(e,n){var r,t=D(P,N(n.Z),D(P,N(n._),N(n.e8)));return t?{Z:e*(r=n.Z/t)/(t=Yo(r*r+(r=n._/t)*r+(n=n.e8/t)*n)),_:e*r/t,e8:e*n/t}:Jo}),na=f(function(n,r){function e(e){return pr(D(Xo,D(Oo,Qo,r.n),(n=D(Ko,.05,vr(mr(e=D(Oo,r.n,e)))),D(ea,n,e))));var n}var t=f(function(e,n){return ir(e+n/(2*Qt))}),o=D(M,function(e){return m(e,{N:D(Uo,function(e){return 0<v(e.bA,n)},e.N)})},r.ag),a=D(Uo,function(e){return 0<v(e.bA,n)},r.N),i=(c=r.ak).b?(i=c.b,s(r.n,c=c.a)?i.b?{a:e(i.a),b:i}:{a:r.n,b:p}:{a:e(c),b:r.ak}):{a:r.n,b:r.ak},c=i.b,l=(l={a:c,b:r.Y}).a.b||1!==l.b.$?r.Y:{$:2,a:l.b.a},a=m(r,{N:a,n:i.a,ag:o,cm:n,Y:l,ak:c});return D(_o,"ArrowLeft",r.an)?m(a,{aW:D(t,-.005,r.aW)}):D(_o,"ArrowRight",r.an)?m(a,{aW:D(t,.005,r.aW)}):a}),ra=d(function(e,r,n){var t,o,a=n.Y;return 2===a.$?(t=a.a,o=n.cm+500,a=D(Bo,function(e){var n;return s(e.bH,t.bH)?0<(n=e.am-r)?C(m(e,{am:n,N:D(x,{b3:r,bA:o},e.N)})):y:C(e)},n.ag),m(n,{a6:n.av?n.a6:n.a6+r,a9:2===n.av?n.a9+r:n.a9,am:D(P,1,n.am-e),N:D(x,{b3:1===n.am?0:e,bA:o},n.N),ag:a,Y:1===(e=gr(D(Uo,function(e){return s(e.bH,t.bH)},a))).$?jt:{$:2,a:e.a},bn:1===n.av?n.bn+r:n.bn})):n}),ta=f(function(e,n){return D(oo,e,n)}),oa=f(function(e,n){var r=n.e8-e.e8,t=n._-e._,n=n.Z-e.Z,e=D(P,N(n),D(P,N(t),N(r)));return e?Yo((n=n/e)*n+(n=t/e)*n+(t=r/e)*t)*e:Wo}),aa=d(function(e,n,r){var t;return 0<e?(t=(r.Z-n.Z)/e)*t+(t=(r._-n._)/e)*t+(t=(r.e8-n.e8)/e)*t<=1:!e&&s(n.Z,r.Z)&&s(n._,r._)&&s(n.e8,r.e8)}),ia=function(e){return-e},ca=f(function(e,n){return{Z:e._*n.e8-e.e8*n._,_:e.e8*n.Z-e.Z*n.e8,e8:e.Z*n._-e._*n.Z}}),la=function(e){return e.dy},ua=function(e){return e.dz},sa=function(e){return D(ca,la(e),ua(e))},fa=re,da=te,va=d(function(e,n,r){var n=.5*n,t=fa(n),n=da(n),e=e.fu,o=e.Z*n,a=t*o,i=o*o,c=e._*n,l=t*c,u=o*c,s=c*c,e=e.e8*n,n=t*e,t=o*e,o=c*e,c=e*e;return{Z:(1-2*(s+c))*r.Z+2*(u-n)*r._+2*(t+l)*r.e8,_:2*(u+n)*r.Z+(1-2*(i+c))*r._+2*(o-a)*r.e8,e8:2*(t-l)*r.Z+2*(o+a)*r._+(1-2*(i+s))*r.e8}}),ma=d(function(e,n,r){var n=.5*n,t=fa(n),n=da(n),o=e.c6,a=r.Z-o.Z,i=r._-o._,r=r.e8-o.e8,e=e.fu,c=e.Z*n,l=t*c,u=c*c,s=e._*n,f=t*s,d=c*s,v=s*s,e=e.e8*n,n=t*e,t=c*e,c=s*e,s=e*e;return{Z:o.Z+(1-2*(v+s))*a+2*(d-n)*i+2*(t+f)*r,_:o._+2*(d+n)*a+(1-2*(u+s))*i+2*(c-l)*r,e8:o.e8+2*(t-f)*a+2*(c+l)*i+(1-2*(u+v))*r}}),pa=function(e){return e},ga=function(e){return e.dy},ha=function(e){return e.dz},ba=d(function(e,n,r){return pa({c6:z(ma,e,n,br(r)),dy:z(va,e,n,ga(r)),dz:z(va,e,n,ha(r)),dA:z(va,e,n,xr(r))})}),xa=d(function(e,n,r){return z(ba,e(r),n,r)}),Ca=f(function(e,n){return{Z:n.Z+e.Z,_:n._+e._,e8:n.e8+e.e8}}),ya=f(function(e,n){return pa({c6:D(Ca,e,br(n)),dy:ga(n),dz:ha(n),dA:xr(n)})}),Pa=f(function(e,n){return{Z:e*n.Z,_:e*n._,e8:e*n.e8}}),Ta=d(function(e,n,r){return D(ya,D(Pa,n,e),r)}),La=d(function(e,n,r){return z(Ta,Cr(e(r)),n,r)}),Ma=f(function(e,n){return{fu:n,c6:e}}),_a=function(e){return D(Ma,e.c6,e.dy)},wa=function(e){return D(Ma,e.c6,e.dz)},Na=function(e){return D(Ma,e.c6,e.dA)},Da=function(e){return{$:0,a:e}},q=function(e){return N(e)},za=function(e){return.5*e},Va=oe,$a=function(e){return Va(e)},Re={Z:1,_:0,e8:0},Pn={Z:0,_:1,e8:0},Sa=or({c6:Qo,dy:Re,dz:Pn}),Aa=function(e){return function(e){var n=za(q(e.gw)),n=$a(n);return{dh:Da(n),gy:e.gy}}({gw:hr(30),gy:(e={fd:e.aW,fv:15,fA:hr(30),fK:e.n,fL:Sa},n=pa({c6:e.fK,dy:ua(e.fL),dz:sa(e.fL),dA:la(e.fL)}),z(La,Na,e.fv,z(xa,_a,ia(e.fA),z(xa,wa,e.fd,n))))});var n},qa=f(function(e,n){return n.Z*e.Z+n._*e._+n.e8*e.e8}),ka=f(function(e,n){return e*n}),Za=f(function(e,n){var r=e.c6,e=e.ga;return(n.Z-r.Z)*e.Z+(n._-r._)*e._+(n.e8-r.e8)*e.e8}),Ra=d(function(e,n,r){return{Z:r.Z+n*e.Z,_:r._+n*e._,e8:r.e8+n*e.e8}}),Ba=f(function(e,n){var r=Cr(n),t=D(qa,e.ga,r);return t?(n=function(e){return e.c6}(n),C(z(Ra,r,D(ka,-1/t,D(Za,e,n)),n))):y}),Fa=f(function(e,n){return n.$?y:C(e(n.a))}),Ea=f(function(e,n){return n=b(n),r=n._,t=n.e8,{Z:e(n.Z),_:e(r),e8:e(t)};var r,t}),a=d(function(e,n,r){return{Z:e,_:n,e8:r}}),Ga=f(function(e,n){return pr(D(Xo,e,b(n)))}),ja=f(function(e,n){return e*n}),Ia=f(function(e,n){return n/e}),Ha={Z:0,_:0,e8:-1},Ua=f(function(e,n){return n/e}),Oa=f(function(e,n){var r=e.dA,t=e.dz,e=e.dy;return{Z:e.Z*n.Z+t.Z*n._+r.Z*n.e8,_:e._*n.Z+t._*n._+r._*n.e8,e8:e.e8*n.Z+t.e8*n._+r.e8*n.e8}}),Ya=f(function(e,n){return n.$?e:n.a}),Wa=f(function(e,n){var r=e.c6,e=e.dy;return(n.Z-r.Z)*e.Z+(n._-r._)*e._}),Ka=d(function(e,n,r){return{Z:e,_:n,e8:r}}),Qa=u(function(e,n,r,t){var o=e.c6,a=e.dA,i=e.dz,e=e.dy;return{Z:o.Z+n*e.Z+r*i.Z+t*a.Z,_:o._+n*e._+r*i._+t*a._,e8:o.e8+n*e.e8+r*i.e8+t*a.e8}}),Xa=f(function(e,n){var r=e.c6,e=e.dz;return(n.Z-r.Z)*e.Z+(n._-r._)*e._}),Ja=d(function(e,n,r){var t,o=D(Xa,yr(n),r),r=D(Wa,yr(n),r),a=e.gy,n=Pr(n),n=n.b,i=e.dh;return i.$?D(Ma,V(Qa,a,D(ja,t=D(Ua,n,i.a),r),D(ja,t,o),Wo),Mr(e.gy)):(t=ia(D(Ia,i.a,D(ka,.5,n))),i=D(Oa,a,D(Ya,Ha,function(e){var n,r,t=D(P,N(e.Z),D(P,N(e._),N(e.e8)));return t?(t=Yo((r=e.Z/t)*r+(n=e._/t)*n+(e=e.e8/t)*e),C({Z:r/t,_:n/t,e8:e/t})):y}(z(Ka,r,o,t)))),D(Ma,Tr(e.gy),i))}),ei=ce,ni=f(function(e,n){return-1<v(n,e)}),ri=f(function(e,n){return e+.5*(n-e)}),ti=f(function(e,n){return n-e}),oi={Z:-1,_:0},ai={Z:0,_:-1},ii={Z:1,_:0},ci={Z:0,_:1},li=f(function(e,n){return{Z:e,_:n}}),ui=V(u(function(e,n,r,t){var o=D(ni,n,t)?ci:ai,a=D(ni,e,r)?ii:oi,i={a:q(D(ti,e,r)),b:q(D(ti,n,t))};return{fc:{c6:D(li,D(ri,e,r),D(ri,n,t)),dy:a,dz:o},ft:i}}),(ie={gB:0,gC:800,gE:600,gF:0}).gB,ie.gE,ie.gC,ie.gF),si=d(function(e,n,r){return v(r,e)<0?e:0<v(r,n)?n:r}),fi=f(function(e,n){var r,t;return s(e,n)?p:(r=z(si,-1,1,b(n)._-b(e)._),t=z(si,-1,1,b(n).Z-b(e).Z),t=pr(D(Xo,D(Oo,Qo,z(Wt,t,r,0)),D(Oo,Qo,e))),D(x,t,D(fi,t,n)))}),di=Q,vi=function(e){return e},J={Z:0,_:0,e8:1},mi=D(f(function(e,n){return{ga:n,c6:e}}),Qo,J),pi=f(function(e,r){var n,t,o=z(Ja,Aa(r),ui,e),o=D(Fa,Ea(D(no,ei,tr)),D(Ba,mi,o));return 0<v(vi(e).Z,800)||0<v(vi(e)._,600)||1===o.$?r:(n=o.a,e=D(Ya,r.n,gr(r.ak)),(o=gr(D(Uo,function(e){return z(aa,.01,n,e.n)},r.ag))).$?m(r,{Y:jt,ak:(t=D(fi,e,n)).b?t:g([n])}):(t=o.a,o=D(Ya,D(Ga,z(a,1,0,0),n),gr(D(di,f(function(e,n){return D(ta,D(oa,r.n,e),D(oa,r.n,n))}),g([D(Ga,z(a,1,0,0),n),D(Ga,z(a,-1,0,0),n),D(Ga,z(a,0,1,0),n),D(Ga,z(a,0,-1,0),n)])))),m(r,{Y:{$:1,a:t},ak:D(Uo,function(e){return!s(e,r.n)},D(x,e,D(fi,e,o)))})))}),gi=f(function(e,n){return{$:5,a:e,b:n}}),hi=f(function(e,n){return{$:0,a:e,b:n}}),ge=D(_,function(e){return L((e=dr(e),n=_r(D(hi,0,1013904223)),_r(D(hi,n.a+e>>>0,n.b))));var n},xo),bi=f(function(e,n){return e(n)}),xi=d(function(n,e,r){var t,o;return e.b?(t=e.b,o=(e=D(bi,e.a,r)).b,D(_,function(e){return z(xi,n,t,o)},D(Ft,n,e.a))):L(r)}),pe=d(function(e,n,r){return L(r)}),Ci=f(function(r,e){var t=e;return function(e){var e=t(e),n=e.b;return{a:r(e.a),b:n}}}),yi=(ke.Random={b:ge,c:xi,d:pe,e:f(function(e,n){return D(Ci,e,n)}),f:void 0},Be("Random")),ve=f(function(e,n){return yi(D(Ci,e,n))}),he=f(function(l,u){return function(e){var n=v(l,u)<0?{a:l,b:u}:{a:u,b:l},r=n.a,t=n.b-r+1;if(!(t-1&t))return{a:((t-1&wr(e))>>>0)+r,b:_r(e)};for(var o=(-t>>>0)%t>>>0,a=e;;){var i=wr(a),c=_r(a);if(0<=v(i,o))return{a:i%t+r,b:c};a=c}}}),Pi=d(function(t,e,n){var o=e,a=n;return function(e){var e=o(e),n=e.a,e=a(e.b),r=e.b;return{a:D(t,n,e.a),b:r}}}),Ti=D(ve,function(e){return D(gi,e.a,e.b)},D(f(function(e,n){return z(Pi,f(function(e,n){return{a:e,b:n}}),e,n)}),D(he,0,1),D(he,0,1))),Li=f(function(e,n){return z(lo,e,0,n)}),Mi=F(function(e,n,r,t,o,a,i){if(-1!==a.$||a.a){for(;;){if(-1!==i.$||1!==i.a)break;if(-1!==i.d.$)return Dr(n);if(1===i.d.a)return Dr(n);break}return n}return $(w,r,a.b,a.c,a.d,$(w,0,t,o,a.e,i))}),_i=f(function(e,n){var r,t,o,a,i,c,l;return-2===n.$?Ut:(r=n.a,o=n.c,a=n.d,i=n.e,v(e,t=n.b)<0?-1===a.$&&1===a.a?-1!==(c=a.d).$||c.a?-1===(c=Nr(n)).$?(l=c.e,$(io,c.a,c.b,c.c,D(_i,e,c.d),l)):Ut:$(w,r,t,o,D(_i,e,a),i):$(w,r,t,o,D(_i,e,a),i):D(wi,e,G(Mi,e,n,r,t,o,a,i)))}),wi=f(function(e,n){var r,t,o,a,i;return-1===n.$?(r=n.a,t=n.c,o=n.d,a=n.e,s(e,n=n.b)?-1===(i=function(e){for(;;){if(-1!==e.$||-1!==e.d.$)return e;e=e.d}}(a)).$?$(io,r,i.b,i.c,o,zr(a)):Ut:$(io,r,n,t,o,D(_i,e,a))):Ut}),Ni=f(function(e,n){e=D(_i,e,n);return-1!==e.$||e.a?e:$(w,1,e.b,e.c,e.d,e.e)}),Di=f(function(e,n){return D(Ni,e,n)}),Ze=f(function(e,n){switch(e.$){case 0:return{a:D(na,e.a,n),b:Kt};case 1:return{a:D(pi,e.a,n),b:Kt};case 2:return{a:m(n,{an:D(Li,e.a,n.an)}),b:Kt};case 3:return{a:m(n,{an:D(Di,e.a,n.an)}),b:Kt};case 4:return{a:n,b:Ti};case 5:return{a:z(ra,e.a,e.b,n),b:Kt};default:return{a:m(n,{av:e.a}),b:Kt}}}),zi=f(function(e,n){return n.b?z(Zt,x,n,e):e}),Vi=V(It,186/255,189/255,182/255,1),$i=V(It,78/255,154/255,6/255,1),o=Ye("div"),K=f(function(e,n){switch(n){case"G":return 0;case"R":return 1;default:return e}}),Si=D(M,D(no,Y(""),M(K(0))),g(["GGGGRRGGGG","GGGGRRGGGG","GGGGRRGGGG","GGGGRRGGGG","GGGGRRGGGG","GGGGRRRRRR","GGGGRRRRRR","GGGGRRGGGG","GGGGRRGGGG","GGGGRRGGGG"])),Ai=rr(Si)/2,qi=V(It,52/255,101/255,164/255,1),ki=V(It,32/255,74/255,135/255,1),Zi=V(It,164/255,0,0,1),k=Qe,i=Oe,Ri=V(u(function(e,n,r,t){return V(It,e,n,r,t)}),0,0,0,0),Bi=function(e){return{$:0,a:e}},Fi={$:3},Ei=u(function(e,n,r,t){return{$:4,a:e,b:n,c:r,d:t}}),Gi=f(function(e,n){return Vr(D(M,e,n))}),ji=function(e){return{$:1,a:e}},Ii=function(e){return{$:2,a:e}},c=de,Hi=f(function(e,n){switch(n.$){case 0:return D(An,e,n);case 1:return D(qn,e,n);case 2:return D(kn,e,n);case 3:return D(Zn,e,n);case 4:return D(Rn,e,n);case 5:return D(Bn,e,n);case 6:return D(Fn,e,n);case 7:return D(En,e,n);default:return function(e){var n=e.sampleAlphaToCoverage;n.toggle=e.toggle,n.enabled||(e.gl.enable(e.gl.SAMPLE_ALPHA_TO_COVERAGE),n.enabled=!0)}(e)}}),Ui=d(function(e,n,r){return z(Wn,e,n,r)}),Oi=nr,Yi=V(Oi,1,1,1,1),Z=d(function(e,n,r){return D(M,function(e){return D(e,n,r)},e)}),Wi=d(function(e,n,r){return{$:0,a:e,b:n,c:r}}),Ki=f(function(e,n){var r=n.Z,n=n._;return z(Wi,e*r/n,e,e*(1-r-n)/n)}),Qi=Jn,Xi=f(function(e,n){return z(Qi,3.2406*(n=(e=D(Ki,e,n)).a)-1.5372*(r=e.b)-.4986*(e=e.c),-.9689*n+1.8758*r+.0415*e,.0557*n-.204*r+1.057*e);var r}),Ji=f(function(e,n){return{d_:s(e.d_,n.d_),w:e.w*n.w+e.x*n.z+e.y*n.C,x:e.w*n.x+e.x*n.A+e.y*n.D,y:e.w*n.y+e.x*n.B+e.y*n.E,z:e.z*n.w+e.A*n.z+e.B*n.C,A:e.z*n.x+e.A*n.A+e.B*n.D,B:e.z*n.y+e.A*n.B+e.B*n.E,C:e.C*n.w+e.D*n.z+e.E*n.C,D:e.C*n.x+e.D*n.A+e.E*n.D,E:e.C*n.y+e.D*n.B+e.E*n.E,O:n.O+(e.O*n.w+e.P*n.z+e.Q*n.C)*n.cy,P:n.P+(e.O*n.x+e.P*n.A+e.Q*n.D)*n.cy,Q:n.Q+(e.O*n.y+e.P*n.B+e.Q*n.E)*n.cy,cy:e.cy*n.cy}}),ec=function(e){var n=new Float64Array(16);return n[0]=e.d8,n[1]=e.ec,n[2]=e.eg,n[3]=e.ek,n[4]=e.d9,n[5]=e.ed,n[6]=e.eh,n[7]=e.el,n[8]=e.ea,n[9]=e.ee,n[10]=e.ei,n[11]=e.em,n[12]=e.eb,n[13]=e.ef,n[14]=e.ej,n[15]=e.en,n},nc=l(function(e,n,r,t,o){return E(o,e,V(Oi,t.cy,t.cy,t.cy,t.d_?1:-1),function(e){return ec({d8:e.w,d9:e.z,ea:e.C,eb:e.O,ec:e.x,ed:e.A,ee:e.D,ef:e.P,eg:e.y,eh:e.B,ei:e.E,ej:e.Q,ek:0,el:0,em:0,en:1})}(t),t.d_,n,r)}),rc=B(function(e,n,r,t,o,a){for(;;)switch(o.$){case 0:return a;case 5:var i=o.b;e=e,n=n,r=r,t=D(Ji,o.a,t),o=i,a=a;continue;case 1:return{V:D(x,$(nc,e,n,r,t,o.b),a.V),ah:a.ah,aj:a.aj};case 3:i=D(x,$(nc,e,n,r,t,o.b),a.ah);return{V:a.V,ah:i,aj:a.aj};case 2:var c=D(x,$(nc,e,n,r,t,o.a),a.aj);return{V:a.V,ah:a.ah,aj:c};default:c=o.a;return z(ft,V(rc,e,n,r,t),a,c)}}),tc=u(function(e,n,r,t){return{$:4,a:e,b:n,c:r,d:t}}),oc=u(function(e,n,r,t){return{$:1,a:e,b:n,c:r,d:t}}),ae=f(function(e,n){return{$:6,a:e,b:n}}),ac=g([function(e){return V(oc,518,e.at,e.ao,e.al)}({al:1,ao:0,at:!1}),V(tc,!1,!1,!1,!1),D(ae,0,1)]),ic={src:"\n        precision lowp float;\n\n        void main() {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n    ",attributes:{},uniforms:{}},R=Sn,bn=f(function(e,n){return{$:0,a:e,b:n}}),I=bn({dN:1,dY:0,ew:5}),r=Xn,cc=I(g([{cr:D(r,-1,-1)},{cr:D(r,1,-1)},{cr:D(r,-1,1)},{cr:D(r,1,1)}])),lc={src:"\n        precision lowp float;\n\n        attribute vec2 position;\n\n        void main() {\n            gl_Position = vec4(position, 0.0, 1.0);\n        }\n    ",attributes:{position:"cr"},uniforms:{}},uc=d(function(e,n,r){function t(e){return D(no,i(e.bU),D(no,c(e.bD),D(no,c(e.b0),c(e.b1))))}var o=e.dj,a=e.cY,e=e.dx,i=f(function(e,n){return n(e)}),c=f(function(e,n){return n(e)});return D(t,r,D(t,n,z(qr,o,a,e)))}),sc=Zr({bD:7681,cY:0,dj:8,bU:519,dx:15,b0:7681,b1:7681}),fc=ne,dc=d(function(e,n,r){return Vr(g([z(Z,e,r,ac),g([Rr(n),sc])]))}),vc=f(function(e,n){return Vr(D(pt,dc(e),n))}),me=function(e){return V(oc,513,e.at,e.ao,e.al)}({al:1,ao:0,at:!0}),mc=d(function(e,n,r){return{$:0,a:e,b:n,c:r}}),le=f(function(e,n){return z(mc,32774,e,n)}),pc=function(e){var a=e.ct,i=e.cc,c=e.b5,l=e.b2,n=e.dH,e=e.a7;return D(f(function(e,n){var r=e.c,t=n.a,o=n.b,n=n.c;return function(u){return function(l){return function(c){return function(i){return function(a){return function(o){return function(t){return function(r){return function(n){return function(e){return{$:0,a:u,b:l,c:c,d:i,e:a,f:o,g:t,h:r,i:n,j:e}}}}}}}}}}}(e.a)(e.b)(r)(t)(o)(n)(a)(i)(c)(l)}),n,e)}({b2:0,a7:D(le,1,771),b5:0,dH:D(le,770,771),cc:0,ct:0}),gc=g([me,pc]),hc=function(e){return e.ep},bc=function(e){return e.eq},xc=function(e){return e.er},Cc=function(e){return e.es},yc=function(e){return e.et},Pc=function(e){return e.eu},Tc=f(function(e,n){var r=e.dA,t=e.dz,e=e.dy;return{Z:n.Z*e.Z+n._*e._+n.e8*e.e8,_:n.Z*t.Z+n._*t._+n.e8*t.e8,e8:n.Z*r.Z+n._*r._+n.e8*r.e8}}),Lc=f(function(e,n){var r=e.c6,t=n.Z-r.Z,o=n._-r._,n=n.e8-r.e8,r=e.dA,a=e.dz,e=e.dy;return{Z:t*e.Z+o*e._+n*e.e8,_:t*a.Z+o*a._+n*a.e8,e8:t*r.Z+o*r._+n*r.e8}}),Mc=f(function(e,n){return{c6:D(Lc,e,br(n)),dy:D(Tc,e,ga(n)),dz:D(Tc,e,ha(n)),dA:D(Tc,e,xr(n))}}),_c=f(function(e,n){return D(P,e,n)}),wc=f(function(e,n){return D(Ko,e,n)}),Nc=f(function(e,n){n=Fr(n),e=Fr(e);return{ep:D(_c,e.ep,n.ep),eq:D(_c,e.eq,n.eq),er:D(_c,e.er,n.er),es:D(wc,e.es,n.es),et:D(wc,e.et,n.et),eu:D(wc,e.eu,n.eu)}}),Dc=f(function(e,n){return n+e}),zc=f(function(e,n){var r=e.a,t=e.c,e=za(q(e.b)),r=za(q(r)),t=za(q(t)),n=function(e){return{a:e.Z,b:e._,c:e.e8}}(n),o=n.a,a=n.b,n=n.c;return{ep:D(Dc,r,o),eq:D(Dc,e,a),er:D(Dc,t,n),es:D(ti,r,o),et:D(ti,e,a),eu:D(ti,t,n)}}),Vc=u(function(e,n,r,t){var o=r.fm,a=2*r.fO*n,i=2*r.fN*n,r=2*r.fM*n,c=o.e8*n,l=o._*n,o=o.Z*n,n=Er(xr(e)),n=N(r*n.Z)+N(i*n._)+N(a*n.e8),u=Er(ha(e)),u=N(r*u.Z)+N(i*u._)+N(a*u.e8),s=Er(ga(e)),r=N(r*s.Z)+N(i*s._)+N(a*s.e8),i=D(zc,{a:r,b:u,c:n},D(Lc,e,z(Wt,o,l,c)));return C(t.$?i:D(Nc,t.a,i))}),$c=u(function(e,n,r,t){for(;;){if(!t.b)return r;var o=t.a,a=t.b;switch(o.$){case 0:e=c=e,n=l=n,r=u=r,t=a;continue;case 1:var i=V(Vc,e,n,o.a,r);e=c=e,n=l=n,r=u=i,t=a;continue;case 2:e=c=e,n=l=n,r=u=r,t=a;continue;case 3:i=V(Vc,e,n,o.a,r);e=c=e,n=l=n,r=u=i,t=a;continue;case 4:var c=e,l=n,u=V($c,e,n,r,o.a);e=c,n=l,r=u,t=a;continue;default:var s=o.a,f=o.b,d=D(Mc,function(e){return pa({c6:{Z:e.O,_:e.P,e8:e.Q},dy:{Z:e.w,_:e.x,e8:e.y},dz:{Z:e.z,_:e.A,e8:e.B},dA:{Z:e.C,_:e.D,e8:e.E}})}(s),e),s=n*s.cy;e=c=e,n=l=n,r=u=V($c,d,s,r,g([f])),t=a;continue}}}),Sc=function(e){return e[0]},Ac=function(e){return e[1]},qc=function(e){return e[2]},kc=function(e){return{$:4,a:e}},Zc=f(function(e,n){for(;;){if(!e.b)return n;var r=e.a;e=e.b,n=D(x,r,n)}}),Rc={d_:!0,w:1,x:0,y:0,z:0,A:1,B:0,C:0,D:0,E:1,O:0,P:0,Q:0,cy:1},Bc=Zr({bD:7681,cY:0,dj:8,bU:519,dx:255,b0:7681,b1:7681}),re={b5:0,fl:!1,cc:0,df:0,ct:0,gt:0,Z:0,_:0,e8:0},te=f(function(e,n){return ec({d8:e.Z,d9:e.ct,ea:n.Z,eb:n.ct,ec:e._,ed:e.cc,ee:n._,ef:n.cc,eg:e.e8,eh:e.b5,ei:n.e8,ej:n.b5,ek:e.gt,el:e.df,em:n.gt,en:n.df})}),Fc={a:{bK:D(te,re,re),cg:D(te,re,re),ch:D(te,re,re),ci:D(te,re,re)},b:V(Oi,0,0,0,0)},Ec=g([jr({al:1,ao:0,at:!0}),kr({bD:7680,cY:240,dj:0,bU:514,dx:0,b0:7680,b1:7680}),pc]),Gc=function(e){return e===1/0||e===-1/0},jc=f(function(e,n){var r,t=n.fJ,o=n.fb,n=q(n.f2),t=q(t),e=e.dh;return e.$?(r=e.a,Gc(t)?ec({d8:2/(o*r),d9:0,ea:0,eb:0,ec:0,ed:2/r,ee:0,ef:0,eg:0,eh:0,ei:0,ej:-1,ek:0,el:0,em:0,en:1}):ec({d8:2/(o*r),d9:0,ea:0,eb:0,ec:0,ed:2/r,ee:0,ef:0,eg:0,eh:0,ei:-2/(t-n),ej:-(t+n)/(t-n),ek:0,el:0,em:0,en:1})):(r=e.a,Gc(t)?ec({d8:1/(o*r),d9:0,ea:0,eb:0,ec:0,ed:1/r,ee:0,ef:0,eg:0,eh:0,ei:-1,ej:-2*n,ek:0,el:0,em:-1,en:0}):ec({d8:1/(o*r),d9:0,ea:0,eb:0,ec:0,ed:1/r,ee:0,ef:0,eg:0,eh:0,ei:-(t+n)/(t-n),ej:-2*t*n/(t-n),ek:0,el:0,em:-1,en:0}))}),Ic=f(function(e,n){return 1==(1&e>>n)?0:1}),Hc=d(function(r,t,e){return Vr(D(M,function(e){var n=e<<4;return z(Z,r,{a:t,b:V(Oi,D(Ic,e,0),D(Ic,e,1),D(Ic,e,2),D(Ic,e,3))},function(e){return g([jr({al:1,ao:0,at:!0}),kr({bD:7680,cY:240,dj:e,bU:514,dx:0,b0:7680,b1:7680}),pc])}(n))},D(mt,1,D(fc,2,e)-1)))}),Uc=function(e){return{d8:e[0],ec:e[1],eg:e[2],ek:e[3],d9:e[4],ed:e[5],eh:e[6],el:e[7],ea:e[8],ee:e[9],ei:e[10],em:e[11],eb:e[12],ef:e[13],ej:e[14],en:e[15]}},Oc={c6:Qo,dy:Re,dz:Pn,dA:J},Yc=f(function(e,n){var r,t;return e=Ir(br(n=D(Mc,n,e))),r=Er(xr(n)),t=Er(ha(n)),n=Er(ga(n)),ec({d8:n.Z,d9:t.Z,ea:r.Z,eb:e.Z,ec:n._,ed:t._,ee:r._,ef:e._,eg:n.e8,eh:t.e8,ei:r.e8,ej:e.e8,ek:0,el:0,em:0,en:1})}),Wc=f(function(n,e){var r=g([ji(1),Ii(0),Bi(!0),V(Ei,0,0,0,0)]),t=function(){var e=n.a8;switch(e.$){case 0:return{a:r,b:"0",c:1};case 1:return{a:D(x,Fi,r),b:"1",c:1};default:return{a:r,b:"0",c:e.a}}}(),o=t.a,a=t.b,i=t.c,t=n.ft,c=t.a,t=Ar(t.b),l=D(k,"height",ut(t)+"px"),c=Ar(c),u=c/t,e=D(Gi,function(e){return Hr({fb:u,fk:n.fk,fp:n.fp,fC:e.fC,aG:e.aG,aI:e.aI,eZ:i,aO:e.aO,aR:e.aR})},e),s=D(k,"width",ut(c)+"px"),f=Sr(n.fe);return z($r,"div",g([D(k,"padding","0px"),s,l]),g([{a:a,b:z(Ui,o,g([(a=ei(c*i),D(Xe,"width",ut(a))),function(e){return D(Xe,"height",ut(e))}(ei(t*i)),s,l,D(k,"display","block"),D(k,"background-color",f)]),e)}]))}),Kc=function(e){return D(Wc,{a8:e.a8,fe:e.fe,fk:e.fk,fp:e.fp,ft:e.ft},g([{fC:e.fC,aG:e.aG,aI:e.aI,aO:e.aO,aR:e.aR}]))},Qc={Z:.31271,_:.32902},Xc=function(e){return q(e)},Jc={$:1},el=function(e){return e},nl={$:0,a:Fc.a},rl={$:0},tl=function(e){return{$:6,a:e}},ol=function(e){return e?D(k,"background-color","#d33030"):D(k,"","")},al=Ye("button"),il=Ke,cl=f(function(e,n){return D(il,e,{$:0,a:n})}),ll=function(e){return D(cl,"click",At(e))},ul=f(function(e,n){return e/n}),sl=f(function(e,n){var r=e.c6,e=e.dy;return(n.Z-r.Z)*e.Z+(n._-r._)*e._+(n.e8-r.e8)*e.e8}),fl=d(function(e,n,r){var t=e.c6,o=e.dz,e=e.dy;return{Z:t.Z+n*e.Z+r*o.Z,_:t._+n*e._+r*o._}}),dl=f(function(e,n){var r=e.c6,e=e.dz;return(n.Z-r.Z)*e.Z+(n._-r._)*e._+(n.e8-r.e8)*e.e8}),vl=f(function(e,n){var r=e.c6,e=e.dA;return(n.Z-r.Z)*e.Z+(n._-r._)*e._+(n.e8-r.e8)*e.e8}),ml=d(function(e,n,r){var t,o,a=e.gy,i=D(sl,a,r),c=D(dl,a,r),a=ia(D(vl,a,r)),r=Pr(n),l=r.a,r=r.b,u=D(ul,l,r),e=e.dh;return e.$?(o=D(ul,c,t=e.a),z(fl,yr(n),D(ka,D(ul,i,D(ka,u,t)),l),D(ka,o,r))):(t=e.a,o=D(ul,c,a)/t,z(fl,yr(n),D(ka,D(ul,i,a)/(u*t)/2,l),D(ka,o/2,r)))}),pl=u(function(e,n,r,t){e=vi(z(ml,e,ui,D(Ga,z(a,0,0,1.2),t)));return D(o,g([D(k,"position","absolute"),D(k,"left",c(e.Z-45)+"px"),D(k,"top",c(e._)+"px"),D(k,"width",c(90)+"px"),D(k,"height",c(15)+"px"),D(k,"background-color","#d33030")]),g([D(o,g([D(k,"position","absolute"),D(k,"left","0"),D(k,"top","0"),D(k,"width",c(n/r*100)+"%"),D(k,"height",c(15)+"px"),D(k,"background-color","lime")]),p)]))}),gl=d(function(e,n,r){var e=vi(z(ml,e,ui,r)),r=e.Z,e=e._,n=gr(n);return 1===n.$?i(""):(n=n.a.b3,D(o,g([D(k,"position","absolute"),D(k,"left",c(r-15)+"px"),D(k,"top",c(e-15)+"px"),D(k,"width",c(30)+"px"),D(k,"height",c(30)+"px"),D(k,"background-color","#d33030"),D(k,"color","white"),D(k,"display","flex"),D(k,"justify-content","center"),D(k,"align-items","center"),D(k,"border-radius","100%"),D(k,"font-weight","bold")]),g([D(o,p,g([i(ut(n))]))])))}),hl=f(function(e,n){return{$:0,a:e,b:n}}),bl=function(e){return{a7:e.d,cH:e.c,cN:e.b,di:e.a}},xl={$:0},Cl=f(function(e,n){return{$:1,a:e,b:n}}),yl={src:"\n        precision mediump float;\n        \n        uniform mediump sampler2D colorTexture;\n        \n        varying mediump vec2 interpolatedUv;\n        \n        void main () {\n            gl_FragColor = texture2D(colorTexture, interpolatedUv);\n        }\n    ",attributes:{},uniforms:{colorTexture:"b8"}},Pl={src:"\n        precision lowp float;\n        \n        uniform lowp vec3 constantColor;\n        \n        void main () {\n            gl_FragColor = vec4(constantColor, 1.0);\n        }\n    ",attributes:{},uniforms:{constantColor:"aX"}},Tl={src:"\n        precision mediump float;\n        \n        uniform mediump vec3 emissiveColor;\n        uniform highp mat4 sceneProperties;\n        \n        float gammaCorrect(float u) {\n            if (u <= 0.0031308) {\n                return 12.92 * u;\n            } else {\n                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;\n            }\n        }\n        \n        vec3 gammaCorrectedColor(vec3 color) {\n            float red = gammaCorrect(color.r);\n            float green = gammaCorrect(color.g);\n            float blue = gammaCorrect(color.b);\n            return vec3(red, green, blue);\n        }\n        \n        vec3 reinhardLuminanceToneMap(vec3 color) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scale = 1.0 / (1.0 + luminance);\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 reinhardPerChannelToneMap(vec3 color) {\n            return gammaCorrectedColor(color / (color + 1.0));\n        }\n        \n        float extendedReinhardToneMap(float x, float xMax) {\n            return x * (1.0 + (x / (xMax * xMax))) / (1.0 + x);\n        }\n        \n        vec3 extendedReinhardLuminanceToneMap(vec3 color, float overexposureLimit) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scaledLuminance = extendedReinhardToneMap(luminance, overexposureLimit);\n            float scale = scaledLuminance / luminance;\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 extendedReinhardPerChannelToneMap(vec3 color, float overexposureLimit) {\n            float red = extendedReinhardToneMap(color.r, overexposureLimit);\n            float green = extendedReinhardToneMap(color.g, overexposureLimit);\n            float blue = extendedReinhardToneMap(color.b, overexposureLimit);\n            return gammaCorrectedColor(vec3(red, green, blue));\n        }\n        \n        vec3 hableFilmicHelper(vec3 color) {\n            float a = 0.15;\n            float b = 0.5;\n            float c = 0.1;\n            float d = 0.2;\n            float e = 0.02;\n            float f = 0.3;\n            return (color * (a * color + c * b) + d * e) / (color * (a * color + b) + d * f) - e / f;\n        }\n        \n        vec3 hableFilmicToneMap(vec3 color) {\n            float exposureBias = 2.0;\n            vec3 unscaled = hableFilmicHelper(exposureBias * color);\n            vec3 scale = 1.0 / hableFilmicHelper(vec3(11.2));\n            return gammaCorrectedColor(scale * unscaled);\n        }\n        \n        vec3 toneMap(vec3 color, float toneMapType, float toneMapParam) {\n            if (toneMapType == 0.0) {\n                return gammaCorrectedColor(color);\n            } else if (toneMapType == 1.0) {\n                return reinhardLuminanceToneMap(color);\n            } else if (toneMapType == 2.0) {\n                return reinhardPerChannelToneMap(color);\n            } else if (toneMapType == 3.0) {\n                return extendedReinhardLuminanceToneMap(color, toneMapParam);\n            } else if (toneMapType == 4.0) {\n                return extendedReinhardPerChannelToneMap(color, toneMapParam);\n            } else if (toneMapType == 5.0) {\n                return hableFilmicToneMap(color);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {\n            vec3 referenceWhite = sceneProperties[2].rgb;\n            float unitR = linearColor.r / referenceWhite.r;\n            float unitG = linearColor.g / referenceWhite.g;\n            float unitB = linearColor.b / referenceWhite.b;\n            float toneMapType = sceneProperties[3][2];\n            float toneMapParam = sceneProperties[3][3];\n            vec3 toneMapped = toneMap(vec3(unitR, unitG, unitB), toneMapType, toneMapParam);\n            return vec4(toneMapped, 1.0);\n        }\n        \n        void main () {\n            gl_FragColor = toSrgb(emissiveColor, sceneProperties);\n        }\n    ",attributes:{},uniforms:{emissiveColor:"bb",sceneProperties:"g"}},Ll={src:"\n        precision mediump float;\n        \n        uniform mediump sampler2D colorTexture;\n        uniform mediump float backlight;\n        uniform highp mat4 sceneProperties;\n        \n        varying mediump vec2 interpolatedUv;\n        \n        float inverseGamma(float u) {\n            if (u <= 0.04045) {\n                return clamp(u / 12.92, 0.0, 1.0);\n            } else {\n                return clamp(pow((u + 0.055) / 1.055, 2.4), 0.0, 1.0);\n            }\n        }\n        \n        vec3 fromSrgb(vec3 srgbColor) {\n            return vec3(\n                inverseGamma(srgbColor.r),\n                inverseGamma(srgbColor.g),\n                inverseGamma(srgbColor.b)\n            );\n        }\n        \n        float gammaCorrect(float u) {\n            if (u <= 0.0031308) {\n                return 12.92 * u;\n            } else {\n                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;\n            }\n        }\n        \n        vec3 gammaCorrectedColor(vec3 color) {\n            float red = gammaCorrect(color.r);\n            float green = gammaCorrect(color.g);\n            float blue = gammaCorrect(color.b);\n            return vec3(red, green, blue);\n        }\n        \n        vec3 reinhardLuminanceToneMap(vec3 color) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scale = 1.0 / (1.0 + luminance);\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 reinhardPerChannelToneMap(vec3 color) {\n            return gammaCorrectedColor(color / (color + 1.0));\n        }\n        \n        float extendedReinhardToneMap(float x, float xMax) {\n            return x * (1.0 + (x / (xMax * xMax))) / (1.0 + x);\n        }\n        \n        vec3 extendedReinhardLuminanceToneMap(vec3 color, float overexposureLimit) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scaledLuminance = extendedReinhardToneMap(luminance, overexposureLimit);\n            float scale = scaledLuminance / luminance;\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 extendedReinhardPerChannelToneMap(vec3 color, float overexposureLimit) {\n            float red = extendedReinhardToneMap(color.r, overexposureLimit);\n            float green = extendedReinhardToneMap(color.g, overexposureLimit);\n            float blue = extendedReinhardToneMap(color.b, overexposureLimit);\n            return gammaCorrectedColor(vec3(red, green, blue));\n        }\n        \n        vec3 hableFilmicHelper(vec3 color) {\n            float a = 0.15;\n            float b = 0.5;\n            float c = 0.1;\n            float d = 0.2;\n            float e = 0.02;\n            float f = 0.3;\n            return (color * (a * color + c * b) + d * e) / (color * (a * color + b) + d * f) - e / f;\n        }\n        \n        vec3 hableFilmicToneMap(vec3 color) {\n            float exposureBias = 2.0;\n            vec3 unscaled = hableFilmicHelper(exposureBias * color);\n            vec3 scale = 1.0 / hableFilmicHelper(vec3(11.2));\n            return gammaCorrectedColor(scale * unscaled);\n        }\n        \n        vec3 toneMap(vec3 color, float toneMapType, float toneMapParam) {\n            if (toneMapType == 0.0) {\n                return gammaCorrectedColor(color);\n            } else if (toneMapType == 1.0) {\n                return reinhardLuminanceToneMap(color);\n            } else if (toneMapType == 2.0) {\n                return reinhardPerChannelToneMap(color);\n            } else if (toneMapType == 3.0) {\n                return extendedReinhardLuminanceToneMap(color, toneMapParam);\n            } else if (toneMapType == 4.0) {\n                return extendedReinhardPerChannelToneMap(color, toneMapParam);\n            } else if (toneMapType == 5.0) {\n                return hableFilmicToneMap(color);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {\n            vec3 referenceWhite = sceneProperties[2].rgb;\n            float unitR = linearColor.r / referenceWhite.r;\n            float unitG = linearColor.g / referenceWhite.g;\n            float unitB = linearColor.b / referenceWhite.b;\n            float toneMapType = sceneProperties[3][2];\n            float toneMapParam = sceneProperties[3][3];\n            vec3 toneMapped = toneMap(vec3(unitR, unitG, unitB), toneMapType, toneMapParam);\n            return vec4(toneMapped, 1.0);\n        }\n        \n        void main () {\n            vec3 emissiveColor = fromSrgb(texture2D(colorTexture, interpolatedUv).rgb) * backlight;\n            gl_FragColor = toSrgb(emissiveColor, sceneProperties);\n        }\n    ",attributes:{},uniforms:{backlight:"cD",colorTexture:"b8",sceneProperties:"g"}},Ml=F(function(e,n,r,t,o,a,i){for(;;){if(!i.b)return{ep:n,eq:t,er:a,es:e,et:r,eu:o};var c=i.a,l=i.b,u=c.Z,s=c._,c=c.e8;e=D(Ko,u,e),n=D(P,u,n),r=D(Ko,s,r),t=D(P,s,t),o=D(Ko,c,o),a=D(P,c,a),i=l}}),_l=f(function(e,n){var r=e.Z,t=e._,e=e.e8;return G(Ml,r,r,t,t,e,e,n)}),wl={src:"\n        precision highp float;\n        \n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 lights12;\n        uniform highp mat4 lights34;\n        uniform highp mat4 lights56;\n        uniform highp mat4 lights78;\n        uniform lowp vec4 enabledLights;\n        uniform lowp vec3 materialColor;\n        uniform highp mat4 viewMatrix;\n        \n        varying highp vec3 interpolatedPosition;\n        varying highp vec3 interpolatedNormal;\n        \n        const lowp float kPerspectiveProjection = 0.0;\n        const lowp float kOrthographicProjection = 1.0;\n        const lowp float kDirectionalLight = 1.0;\n        const lowp float kPointLight = 2.0;\n        const highp float kPi = 3.14159265359;\n        const lowp float kDisabledLight = 0.0;\n        const lowp float kSoftLighting = 3.0;\n        \n        float getNormalSign() {\n            return 2.0 * float(gl_FrontFacing) - 1.0;\n        }\n        \n        vec3 getDirectionToCamera(vec3 surfacePosition, mat4 sceneProperties) {\n            float projectionType = sceneProperties[1].w;\n            if (projectionType == kPerspectiveProjection) {\n                vec3 cameraPoint = sceneProperties[1].xyz;\n                return normalize(cameraPoint - surfacePosition);\n            } else if (projectionType == kOrthographicProjection) {\n                return sceneProperties[1].xyz;\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        void getDirectionToLightAndNormalIlluminance(\n            vec4 xyz_type,\n            vec4 rgb_parameter,\n            vec3 surfacePosition,\n            out vec3 directionToLight,\n            out vec3 normalIlluminance\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDirectionalLight) {\n                directionToLight = xyz_type.xyz;\n                normalIlluminance = rgb_parameter.rgb;\n            } else if (lightType == kPointLight) {\n                vec3 lightPosition = xyz_type.xyz;\n                vec3 displacement = lightPosition - surfacePosition;\n                float distance = length(displacement);\n                directionToLight = displacement / distance;\n                normalIlluminance = rgb_parameter.rgb / (4.0 * kPi * distance * distance);\n            }\n        }\n        \n        float positiveDotProduct(vec3 v1, vec3 v2) {\n            return clamp(dot(v1, v2), 0.0, 1.0);\n        }\n        \n        vec3 softLightingLuminance(\n            vec3 aboveLuminance,\n            vec3 belowLuminance,\n            vec3 localUpDirection,\n            vec3 localLightDirection\n        ) {\n            float sinElevation = dot(localLightDirection, localUpDirection);\n            float t = (sinElevation + 1.0) / 2.0;\n            return aboveLuminance * t + belowLuminance * (1.0 - t);\n        }\n        \n        vec3 lambertianLight(\n            vec3 surfacePosition,\n            vec3 surfaceNormal,\n            vec3 materialColor,\n            vec4 xyz_type,\n            vec4 rgb_parameter\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDisabledLight) {\n                return vec3(0.0, 0.0, 0.0);\n            } else if (lightType == kSoftLighting) {\n                vec3 upDirection = xyz_type.xyz;\n                vec3 aboveLuminance = rgb_parameter.rgb;\n                vec3 belowLuminance = rgb_parameter.a * aboveLuminance;\n                vec3 luminance = softLightingLuminance(aboveLuminance, belowLuminance, upDirection, surfaceNormal);\n                return luminance * materialColor;\n            }\n        \n            vec3 directionToLight = vec3(0.0, 0.0, 0.0);\n            vec3 normalIlluminance = vec3(0.0, 0.0, 0.0);\n            getDirectionToLightAndNormalIlluminance(\n                xyz_type,\n                rgb_parameter,\n                surfacePosition,\n                directionToLight,\n                normalIlluminance\n            );\n        \n            float dotNL = positiveDotProduct(directionToLight, surfaceNormal);\n            return (normalIlluminance * dotNL) * (materialColor / kPi);\n        }\n        \n        vec3 lambertianLighting(\n            vec3 surfacePosition,\n            vec3 surfaceNormal,\n            vec3 materialColor,\n            mat4 lights12,\n            mat4 lights34,\n            mat4 lights56,\n            mat4 lights78,\n            vec4 enabledLights\n        ) {\n            vec3 litColor1 = enabledLights[0] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights12[0], lights12[1]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor2 = enabledLights[1] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights12[2], lights12[3]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor3 = enabledLights[2] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights34[0], lights34[1]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor4 = enabledLights[3] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights34[2], lights34[3]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor5 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights56[0], lights56[1]);\n            vec3 litColor6 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights56[2], lights56[3]);\n            vec3 litColor7 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights78[0], lights78[1]);\n            vec3 litColor8 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights78[2], lights78[3]);\n            return litColor1 + litColor2 + litColor3 + litColor4 + litColor5 + litColor6 + litColor7 + litColor8;\n        }\n        \n        float gammaCorrect(float u) {\n            if (u <= 0.0031308) {\n                return 12.92 * u;\n            } else {\n                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;\n            }\n        }\n        \n        vec3 gammaCorrectedColor(vec3 color) {\n            float red = gammaCorrect(color.r);\n            float green = gammaCorrect(color.g);\n            float blue = gammaCorrect(color.b);\n            return vec3(red, green, blue);\n        }\n        \n        vec3 reinhardLuminanceToneMap(vec3 color) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scale = 1.0 / (1.0 + luminance);\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 reinhardPerChannelToneMap(vec3 color) {\n            return gammaCorrectedColor(color / (color + 1.0));\n        }\n        \n        float extendedReinhardToneMap(float x, float xMax) {\n            return x * (1.0 + (x / (xMax * xMax))) / (1.0 + x);\n        }\n        \n        vec3 extendedReinhardLuminanceToneMap(vec3 color, float overexposureLimit) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scaledLuminance = extendedReinhardToneMap(luminance, overexposureLimit);\n            float scale = scaledLuminance / luminance;\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 extendedReinhardPerChannelToneMap(vec3 color, float overexposureLimit) {\n            float red = extendedReinhardToneMap(color.r, overexposureLimit);\n            float green = extendedReinhardToneMap(color.g, overexposureLimit);\n            float blue = extendedReinhardToneMap(color.b, overexposureLimit);\n            return gammaCorrectedColor(vec3(red, green, blue));\n        }\n        \n        vec3 hableFilmicHelper(vec3 color) {\n            float a = 0.15;\n            float b = 0.5;\n            float c = 0.1;\n            float d = 0.2;\n            float e = 0.02;\n            float f = 0.3;\n            return (color * (a * color + c * b) + d * e) / (color * (a * color + b) + d * f) - e / f;\n        }\n        \n        vec3 hableFilmicToneMap(vec3 color) {\n            float exposureBias = 2.0;\n            vec3 unscaled = hableFilmicHelper(exposureBias * color);\n            vec3 scale = 1.0 / hableFilmicHelper(vec3(11.2));\n            return gammaCorrectedColor(scale * unscaled);\n        }\n        \n        vec3 toneMap(vec3 color, float toneMapType, float toneMapParam) {\n            if (toneMapType == 0.0) {\n                return gammaCorrectedColor(color);\n            } else if (toneMapType == 1.0) {\n                return reinhardLuminanceToneMap(color);\n            } else if (toneMapType == 2.0) {\n                return reinhardPerChannelToneMap(color);\n            } else if (toneMapType == 3.0) {\n                return extendedReinhardLuminanceToneMap(color, toneMapParam);\n            } else if (toneMapType == 4.0) {\n                return extendedReinhardPerChannelToneMap(color, toneMapParam);\n            } else if (toneMapType == 5.0) {\n                return hableFilmicToneMap(color);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {\n            vec3 referenceWhite = sceneProperties[2].rgb;\n            float unitR = linearColor.r / referenceWhite.r;\n            float unitG = linearColor.g / referenceWhite.g;\n            float unitB = linearColor.b / referenceWhite.b;\n            float toneMapType = sceneProperties[3][2];\n            float toneMapParam = sceneProperties[3][3];\n            vec3 toneMapped = toneMap(vec3(unitR, unitG, unitB), toneMapType, toneMapParam);\n            return vec4(toneMapped, 1.0);\n        }\n        \n        void main() {\n            vec3 normalDirection = normalize(interpolatedNormal) * getNormalSign();\n            vec3 directionToCamera = getDirectionToCamera(interpolatedPosition, sceneProperties);\n        \n            vec3 linearColor = lambertianLighting(\n                interpolatedPosition,\n                normalDirection,\n                materialColor,\n                lights12,\n                lights34,\n                lights56,\n                lights78,\n                enabledLights\n            );\n        \n            gl_FragColor = toSrgb(linearColor, sceneProperties);\n        }\n    ",attributes:{},uniforms:{enabledLights:"ab",lights12:"bK",lights34:"cg",lights56:"ch",lights78:"ci",materialColor:"cZ",sceneProperties:"g",viewMatrix:"h"}},Nl={src:"\n        precision highp float;\n        \n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 lights12;\n        uniform highp mat4 lights34;\n        uniform highp mat4 lights56;\n        uniform highp mat4 lights78;\n        uniform lowp vec4 enabledLights;\n        uniform mediump sampler2D materialColorTexture;\n        uniform mediump sampler2D normalMapTexture;\n        uniform lowp float useNormalMap;\n        uniform highp mat4 viewMatrix;\n        \n        varying highp vec3 interpolatedPosition;\n        varying highp vec3 interpolatedNormal;\n        varying mediump vec2 interpolatedUv;\n        varying highp vec3 interpolatedTangent;\n        \n        const lowp float kPerspectiveProjection = 0.0;\n        const lowp float kOrthographicProjection = 1.0;\n        const lowp float kDirectionalLight = 1.0;\n        const lowp float kPointLight = 2.0;\n        const highp float kPi = 3.14159265359;\n        const lowp float kDisabledLight = 0.0;\n        const lowp float kSoftLighting = 3.0;\n        \n        vec3 getLocalNormal(sampler2D normalMap, float useNormalMap, vec2 uv) {\n            vec3 rgb = useNormalMap * texture2D(normalMap, uv).rgb + (1.0 - useNormalMap) * vec3(0.5, 0.5, 1.0);\n            float x = 2.0 * (rgb.r - 0.5);\n            float y = 2.0 * (rgb.g - 0.5);\n            float z = 2.0 * (rgb.b - 0.5);\n            return normalize(vec3(-x, -y, z));\n        }\n        \n        float getNormalSign() {\n            return 2.0 * float(gl_FrontFacing) - 1.0;\n        }\n        \n        vec3 getMappedNormal(vec3 normal, vec3 tangent, float normalSign, vec3 localNormal) {\n            vec3 bitangent = cross(normal, tangent) * normalSign;\n            return normalize(localNormal.x * tangent + localNormal.y * bitangent + localNormal.z * normal);\n        }\n        \n        vec3 getDirectionToCamera(vec3 surfacePosition, mat4 sceneProperties) {\n            float projectionType = sceneProperties[1].w;\n            if (projectionType == kPerspectiveProjection) {\n                vec3 cameraPoint = sceneProperties[1].xyz;\n                return normalize(cameraPoint - surfacePosition);\n            } else if (projectionType == kOrthographicProjection) {\n                return sceneProperties[1].xyz;\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        void getDirectionToLightAndNormalIlluminance(\n            vec4 xyz_type,\n            vec4 rgb_parameter,\n            vec3 surfacePosition,\n            out vec3 directionToLight,\n            out vec3 normalIlluminance\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDirectionalLight) {\n                directionToLight = xyz_type.xyz;\n                normalIlluminance = rgb_parameter.rgb;\n            } else if (lightType == kPointLight) {\n                vec3 lightPosition = xyz_type.xyz;\n                vec3 displacement = lightPosition - surfacePosition;\n                float distance = length(displacement);\n                directionToLight = displacement / distance;\n                normalIlluminance = rgb_parameter.rgb / (4.0 * kPi * distance * distance);\n            }\n        }\n        \n        float positiveDotProduct(vec3 v1, vec3 v2) {\n            return clamp(dot(v1, v2), 0.0, 1.0);\n        }\n        \n        vec3 softLightingLuminance(\n            vec3 aboveLuminance,\n            vec3 belowLuminance,\n            vec3 localUpDirection,\n            vec3 localLightDirection\n        ) {\n            float sinElevation = dot(localLightDirection, localUpDirection);\n            float t = (sinElevation + 1.0) / 2.0;\n            return aboveLuminance * t + belowLuminance * (1.0 - t);\n        }\n        \n        vec3 lambertianLight(\n            vec3 surfacePosition,\n            vec3 surfaceNormal,\n            vec3 materialColor,\n            vec4 xyz_type,\n            vec4 rgb_parameter\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDisabledLight) {\n                return vec3(0.0, 0.0, 0.0);\n            } else if (lightType == kSoftLighting) {\n                vec3 upDirection = xyz_type.xyz;\n                vec3 aboveLuminance = rgb_parameter.rgb;\n                vec3 belowLuminance = rgb_parameter.a * aboveLuminance;\n                vec3 luminance = softLightingLuminance(aboveLuminance, belowLuminance, upDirection, surfaceNormal);\n                return luminance * materialColor;\n            }\n        \n            vec3 directionToLight = vec3(0.0, 0.0, 0.0);\n            vec3 normalIlluminance = vec3(0.0, 0.0, 0.0);\n            getDirectionToLightAndNormalIlluminance(\n                xyz_type,\n                rgb_parameter,\n                surfacePosition,\n                directionToLight,\n                normalIlluminance\n            );\n        \n            float dotNL = positiveDotProduct(directionToLight, surfaceNormal);\n            return (normalIlluminance * dotNL) * (materialColor / kPi);\n        }\n        \n        vec3 lambertianLighting(\n            vec3 surfacePosition,\n            vec3 surfaceNormal,\n            vec3 materialColor,\n            mat4 lights12,\n            mat4 lights34,\n            mat4 lights56,\n            mat4 lights78,\n            vec4 enabledLights\n        ) {\n            vec3 litColor1 = enabledLights[0] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights12[0], lights12[1]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor2 = enabledLights[1] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights12[2], lights12[3]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor3 = enabledLights[2] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights34[0], lights34[1]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor4 = enabledLights[3] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights34[2], lights34[3]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor5 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights56[0], lights56[1]);\n            vec3 litColor6 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights56[2], lights56[3]);\n            vec3 litColor7 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights78[0], lights78[1]);\n            vec3 litColor8 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights78[2], lights78[3]);\n            return litColor1 + litColor2 + litColor3 + litColor4 + litColor5 + litColor6 + litColor7 + litColor8;\n        }\n        \n        float inverseGamma(float u) {\n            if (u <= 0.04045) {\n                return clamp(u / 12.92, 0.0, 1.0);\n            } else {\n                return clamp(pow((u + 0.055) / 1.055, 2.4), 0.0, 1.0);\n            }\n        }\n        \n        vec3 fromSrgb(vec3 srgbColor) {\n            return vec3(\n                inverseGamma(srgbColor.r),\n                inverseGamma(srgbColor.g),\n                inverseGamma(srgbColor.b)\n            );\n        }\n        \n        float gammaCorrect(float u) {\n            if (u <= 0.0031308) {\n                return 12.92 * u;\n            } else {\n                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;\n            }\n        }\n        \n        vec3 gammaCorrectedColor(vec3 color) {\n            float red = gammaCorrect(color.r);\n            float green = gammaCorrect(color.g);\n            float blue = gammaCorrect(color.b);\n            return vec3(red, green, blue);\n        }\n        \n        vec3 reinhardLuminanceToneMap(vec3 color) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scale = 1.0 / (1.0 + luminance);\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 reinhardPerChannelToneMap(vec3 color) {\n            return gammaCorrectedColor(color / (color + 1.0));\n        }\n        \n        float extendedReinhardToneMap(float x, float xMax) {\n            return x * (1.0 + (x / (xMax * xMax))) / (1.0 + x);\n        }\n        \n        vec3 extendedReinhardLuminanceToneMap(vec3 color, float overexposureLimit) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scaledLuminance = extendedReinhardToneMap(luminance, overexposureLimit);\n            float scale = scaledLuminance / luminance;\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 extendedReinhardPerChannelToneMap(vec3 color, float overexposureLimit) {\n            float red = extendedReinhardToneMap(color.r, overexposureLimit);\n            float green = extendedReinhardToneMap(color.g, overexposureLimit);\n            float blue = extendedReinhardToneMap(color.b, overexposureLimit);\n            return gammaCorrectedColor(vec3(red, green, blue));\n        }\n        \n        vec3 hableFilmicHelper(vec3 color) {\n            float a = 0.15;\n            float b = 0.5;\n            float c = 0.1;\n            float d = 0.2;\n            float e = 0.02;\n            float f = 0.3;\n            return (color * (a * color + c * b) + d * e) / (color * (a * color + b) + d * f) - e / f;\n        }\n        \n        vec3 hableFilmicToneMap(vec3 color) {\n            float exposureBias = 2.0;\n            vec3 unscaled = hableFilmicHelper(exposureBias * color);\n            vec3 scale = 1.0 / hableFilmicHelper(vec3(11.2));\n            return gammaCorrectedColor(scale * unscaled);\n        }\n        \n        vec3 toneMap(vec3 color, float toneMapType, float toneMapParam) {\n            if (toneMapType == 0.0) {\n                return gammaCorrectedColor(color);\n            } else if (toneMapType == 1.0) {\n                return reinhardLuminanceToneMap(color);\n            } else if (toneMapType == 2.0) {\n                return reinhardPerChannelToneMap(color);\n            } else if (toneMapType == 3.0) {\n                return extendedReinhardLuminanceToneMap(color, toneMapParam);\n            } else if (toneMapType == 4.0) {\n                return extendedReinhardPerChannelToneMap(color, toneMapParam);\n            } else if (toneMapType == 5.0) {\n                return hableFilmicToneMap(color);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {\n            vec3 referenceWhite = sceneProperties[2].rgb;\n            float unitR = linearColor.r / referenceWhite.r;\n            float unitG = linearColor.g / referenceWhite.g;\n            float unitB = linearColor.b / referenceWhite.b;\n            float toneMapType = sceneProperties[3][2];\n            float toneMapParam = sceneProperties[3][3];\n            vec3 toneMapped = toneMap(vec3(unitR, unitG, unitB), toneMapType, toneMapParam);\n            return vec4(toneMapped, 1.0);\n        }\n        \n        void main() {\n            vec3 localNormal = getLocalNormal(normalMapTexture, useNormalMap, interpolatedUv);\n            float normalSign = getNormalSign();\n            vec3 originalNormal = normalize(interpolatedNormal) * normalSign;\n            vec3 normalDirection = getMappedNormal(originalNormal, interpolatedTangent, normalSign, localNormal);\n            vec3 directionToCamera = getDirectionToCamera(interpolatedPosition, sceneProperties);\n            vec3 materialColor = fromSrgb(texture2D(materialColorTexture, interpolatedUv).rgb);\n        \n            vec3 linearColor = lambertianLighting(\n                interpolatedPosition,\n                normalDirection,\n                materialColor,\n                lights12,\n                lights34,\n                lights56,\n                lights78,\n                enabledLights\n            );\n        \n            gl_FragColor = toSrgb(linearColor, sceneProperties);\n        }\n    ",attributes:{},uniforms:{enabledLights:"ab",lights12:"bK",lights34:"cg",lights56:"ch",lights78:"ci",materialColorTexture:"c_",normalMapTexture:"bj",sceneProperties:"g",useNormalMap:"bp",viewMatrix:"h"}},Dl=Yr(1029),zl=Yr(1028),Vl=d(function(e,n,r){return 1===n?D(x,e?Dl:zl,r):r}),$l={src:"\n        precision highp float;\n        \n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 lights12;\n        uniform highp mat4 lights34;\n        uniform highp mat4 lights56;\n        uniform highp mat4 lights78;\n        uniform lowp vec4 enabledLights;\n        uniform lowp vec3 baseColor;\n        uniform lowp float roughness;\n        uniform lowp float metallic;\n        \n        varying highp vec3 interpolatedPosition;\n        varying highp vec3 interpolatedNormal;\n        \n        const lowp float kPerspectiveProjection = 0.0;\n        const lowp float kOrthographicProjection = 1.0;\n        const lowp float kDirectionalLight = 1.0;\n        const lowp float kPointLight = 2.0;\n        const highp float kPi = 3.14159265359;\n        const mediump float kMediumpFloatMax = 65504.0;\n        const lowp float kDisabledLight = 0.0;\n        const lowp float kSoftLighting = 3.0;\n        \n        float getNormalSign() {\n            return 2.0 * float(gl_FrontFacing) - 1.0;\n        }\n        \n        vec3 getDirectionToCamera(vec3 surfacePosition, mat4 sceneProperties) {\n            float projectionType = sceneProperties[1].w;\n            if (projectionType == kPerspectiveProjection) {\n                vec3 cameraPoint = sceneProperties[1].xyz;\n                return normalize(cameraPoint - surfacePosition);\n            } else if (projectionType == kOrthographicProjection) {\n                return sceneProperties[1].xyz;\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        void getDirectionToLightAndNormalIlluminance(\n            vec4 xyz_type,\n            vec4 rgb_parameter,\n            vec3 surfacePosition,\n            out vec3 directionToLight,\n            out vec3 normalIlluminance\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDirectionalLight) {\n                directionToLight = xyz_type.xyz;\n                normalIlluminance = rgb_parameter.rgb;\n            } else if (lightType == kPointLight) {\n                vec3 lightPosition = xyz_type.xyz;\n                vec3 displacement = lightPosition - surfacePosition;\n                float distance = length(displacement);\n                directionToLight = displacement / distance;\n                normalIlluminance = rgb_parameter.rgb / (4.0 * kPi * distance * distance);\n            }\n        }\n        \n        float positiveDotProduct(vec3 v1, vec3 v2) {\n            return clamp(dot(v1, v2), 0.0, 1.0);\n        }\n        \n        // Adapted from https://google.github.io/filament/Filament.md.html#materialsystem/specularbrdf/normaldistributionfunction(speculard)\n        float specularD(float alpha, float dotNH, vec3 normalDirection, vec3 halfDirection) {\n            vec3 crossNH = cross(normalDirection, halfDirection);\n            float a = dotNH * alpha;\n            float k = alpha / (dot(crossNH, crossNH) + a * a);\n            float d = k * k * (1.0 / kPi);\n            return min(d, kMediumpFloatMax);\n        }\n        \n        float safeQuotient(float numerator, float denominator) {\n            if (denominator == 0.0) {\n                return 0.0;\n            } else {\n                return numerator / denominator;\n            }\n        }\n        \n        float g1(float dotNV, float alphaSquared) {\n            return safeQuotient(2.0 * dotNV, dotNV + sqrt(alphaSquared + (1.0 - alphaSquared) * dotNV * dotNV));\n        }\n        \n        float specularG(float dotNL, float dotNV, float alphaSquared) {\n            return g1(dotNV, alphaSquared) * g1(dotNL, alphaSquared);\n        }\n        \n        vec3 fresnelColor(vec3 specularBaseColor, float dotVH) {\n            vec3 one = vec3(1.0, 1.0, 1.0);\n            float scale = exp2((-5.55473 * dotVH - 6.98316) * dotVH);\n            return specularBaseColor + (one - specularBaseColor) * scale;\n        }\n        \n        vec3 brdf(vec3 normalDirection, vec3 directionToCamera, vec3 directionToLight, float alpha, float dotNV, float dotNL, vec3 specularBaseColor, vec3 normalIlluminance) {\n            vec3 halfDirection = normalize(directionToCamera + directionToLight);\n            float dotVH = positiveDotProduct(directionToCamera, halfDirection);\n            float dotNH = positiveDotProduct(normalDirection, halfDirection);\n            float dotNHSquared = dotNH * dotNH;\n        \n            float d = specularD(alpha, dotNH, normalDirection, halfDirection);\n            float g = specularG(dotNL, dotNV, alpha * alpha);\n            vec3 f = fresnelColor(specularBaseColor, dotVH);\n            return safeQuotient(d * g, 4.0 * dotNL * dotNV) * f;\n        }\n        \n        vec3 sampleFacetNormal(vec3 vH, vec3 vT1, vec3 vT2, float s, float alpha) {\n            float t2 = (1.0 - s);\n            vec3 vNh = t2 * vT2 + sqrt(max(0.0, 1.0 - t2 * t2)) * vH;\n            return normalize(vec3(alpha * vNh.x, alpha * vNh.y, max(0.0, vNh.z)));\n        }\n        \n        vec3 softLightingLuminance(\n            vec3 aboveLuminance,\n            vec3 belowLuminance,\n            vec3 localUpDirection,\n            vec3 localLightDirection\n        ) {\n            float sinElevation = dot(localLightDirection, localUpDirection);\n            float t = (sinElevation + 1.0) / 2.0;\n            return aboveLuminance * t + belowLuminance * (1.0 - t);\n        }\n        \n        vec3 softLightingSpecularSample(\n            vec3 aboveLuminance,\n            vec3 belowLuminance,\n            vec3 localUpDirection,\n            vec3 localViewDirection,\n            vec3 localLightDirection,\n            vec3 localHalfDirection,\n            float alphaSquared,\n            vec3 specularBaseColor\n        ) {\n            vec3 luminance = softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection);\n            float dotVH = positiveDotProduct(localViewDirection, localHalfDirection);\n            float dotNL = localLightDirection.z;\n            return luminance * (fresnelColor(specularBaseColor, dotVH) * g1(dotNL, alphaSquared));\n        }\n        \n        vec3 softLighting(\n            vec3 normalDirection,\n            vec3 diffuseBaseColor,\n            vec3 specularBaseColor,\n            float alpha,\n            vec3 directionToCamera,\n            vec3 viewY,\n            vec4 xyz_type,\n            vec4 rgb_parameter\n        ) {\n            float alphaSquared = alpha * alpha;\n            vec3 upDirection = xyz_type.xyz;\n            vec3 luminanceAbove = rgb_parameter.rgb;\n            vec3 luminanceBelow = rgb_parameter.a * luminanceAbove;\n            vec3 crossProduct = cross(normalDirection, directionToCamera);\n            float crossMagnitude = length(crossProduct);\n            vec3 xDirection = vec3(0.0, 0.0, 0.0);\n            vec3 yDirection = vec3(0.0, 0.0, 0.0);\n            if (crossMagnitude > 1.0e-6) {\n                yDirection = (1.0 / crossMagnitude) * crossProduct;\n                xDirection = cross(yDirection, normalDirection);\n            } else {\n                vec3 viewY = vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]);\n                xDirection = normalize(cross(viewY, normalDirection));\n                yDirection = cross(normalDirection, xDirection);\n            }\n            float localViewX = dot(directionToCamera, xDirection);\n            float localViewZ = dot(directionToCamera, normalDirection);\n            vec3 localViewDirection = vec3(localViewX, 0, localViewZ);\n            float localUpX = dot(upDirection, xDirection);\n            float localUpY = dot(upDirection, yDirection);\n            float localUpZ = dot(upDirection, normalDirection);\n            vec3 localUpDirection = vec3(localUpX, localUpY, localUpZ);\n        \n            vec3 vH = normalize(vec3(alpha * localViewX, 0.0, localViewZ));\n            vec3 vT1 = vec3(0.0, 1.0, 0.0);\n            vec3 vT2 = cross(vH, vT1);\n            float s = 0.5 * (1.0 + vH.z);\n            \n            vec3 localHalfDirection = sampleFacetNormal(vH, vT1, vT2, s, alpha);\n            vec3 localLightDirection = vec3(0.0, 0.0, 0.0);\n            \n            localLightDirection = -reflect(localViewDirection, localHalfDirection);\n            vec3 specular = softLightingSpecularSample(luminanceAbove, luminanceBelow, localUpDirection, localViewDirection, localLightDirection, localHalfDirection, alphaSquared, specularBaseColor);\n            \n            localLightDirection = vec3(0.000000, 0.000000, 1.000000);\n            vec3 diffuse = softLightingLuminance(luminanceAbove, luminanceBelow, localUpDirection, localLightDirection) * localLightDirection.z;\n            \n            return specular + diffuse * diffuseBaseColor;\n        }\n        \n        vec3 physicalLight(\n            vec4 xyz_type,\n            vec4 rgb_parameter,\n            vec3 surfacePosition,\n            vec3 normalDirection,\n            vec3 directionToCamera,\n            vec3 viewY,\n            float dotNV,\n            vec3 diffuseBaseColor,\n            vec3 specularBaseColor,\n            float alpha\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDisabledLight) {\n                return vec3(0.0, 0.0, 0.0);\n            } else if (lightType == kSoftLighting) {\n                return softLighting(normalDirection, diffuseBaseColor, specularBaseColor, alpha, directionToCamera, viewY, xyz_type, rgb_parameter);\n            }\n        \n            vec3 directionToLight = vec3(0.0, 0.0, 0.0);\n            vec3 normalIlluminance = vec3(0.0, 0.0, 0.0);\n            getDirectionToLightAndNormalIlluminance(xyz_type, rgb_parameter, surfacePosition, directionToLight, normalIlluminance);\n        \n            float dotNL = positiveDotProduct(normalDirection, directionToLight);\n            vec3 specularColor = brdf(normalDirection, directionToCamera, directionToLight, alpha, dotNV, dotNL, specularBaseColor, normalIlluminance);\n            return (normalIlluminance * dotNL) * ((diffuseBaseColor / kPi) + specularColor);\n        }\n        \n        vec3 physicalLighting(\n            vec3 surfacePosition,\n            vec3 surfaceNormal,\n            vec3 baseColor,\n            vec3 directionToCamera,\n            mat4 viewMatrix,\n            float roughness,\n            float metallic,\n            mat4 lights12,\n            mat4 lights34,\n            mat4 lights56,\n            mat4 lights78,\n            vec4 enabledLights\n        ) {\n            float dotNV = positiveDotProduct(surfaceNormal, directionToCamera);\n            float alpha = roughness * roughness;\n            float nonmetallic = 1.0 - metallic;\n            vec3 diffuseBaseColor = nonmetallic * 0.96 * baseColor;\n            vec3 specularBaseColor = nonmetallic * 0.04 * vec3(1.0, 1.0, 1.0) + metallic * baseColor;\n            vec3 viewY = vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]);\n        \n            vec3 litColor1 = enabledLights[0] == 1.0 ? physicalLight(lights12[0], lights12[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor2 = enabledLights[1] == 1.0 ? physicalLight(lights12[2], lights12[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor3 = enabledLights[2] == 1.0 ? physicalLight(lights34[0], lights34[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor4 = enabledLights[3] == 1.0 ? physicalLight(lights34[2], lights34[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor5 = physicalLight(lights56[0], lights56[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            vec3 litColor6 = physicalLight(lights56[2], lights56[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            vec3 litColor7 = physicalLight(lights78[0], lights78[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            vec3 litColor8 = physicalLight(lights78[2], lights78[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            return litColor1 + litColor2 + litColor3 + litColor4 + litColor5 + litColor6 + litColor7 + litColor8;\n        }\n        \n        float gammaCorrect(float u) {\n            if (u <= 0.0031308) {\n                return 12.92 * u;\n            } else {\n                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;\n            }\n        }\n        \n        vec3 gammaCorrectedColor(vec3 color) {\n            float red = gammaCorrect(color.r);\n            float green = gammaCorrect(color.g);\n            float blue = gammaCorrect(color.b);\n            return vec3(red, green, blue);\n        }\n        \n        vec3 reinhardLuminanceToneMap(vec3 color) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scale = 1.0 / (1.0 + luminance);\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 reinhardPerChannelToneMap(vec3 color) {\n            return gammaCorrectedColor(color / (color + 1.0));\n        }\n        \n        float extendedReinhardToneMap(float x, float xMax) {\n            return x * (1.0 + (x / (xMax * xMax))) / (1.0 + x);\n        }\n        \n        vec3 extendedReinhardLuminanceToneMap(vec3 color, float overexposureLimit) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scaledLuminance = extendedReinhardToneMap(luminance, overexposureLimit);\n            float scale = scaledLuminance / luminance;\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 extendedReinhardPerChannelToneMap(vec3 color, float overexposureLimit) {\n            float red = extendedReinhardToneMap(color.r, overexposureLimit);\n            float green = extendedReinhardToneMap(color.g, overexposureLimit);\n            float blue = extendedReinhardToneMap(color.b, overexposureLimit);\n            return gammaCorrectedColor(vec3(red, green, blue));\n        }\n        \n        vec3 hableFilmicHelper(vec3 color) {\n            float a = 0.15;\n            float b = 0.5;\n            float c = 0.1;\n            float d = 0.2;\n            float e = 0.02;\n            float f = 0.3;\n            return (color * (a * color + c * b) + d * e) / (color * (a * color + b) + d * f) - e / f;\n        }\n        \n        vec3 hableFilmicToneMap(vec3 color) {\n            float exposureBias = 2.0;\n            vec3 unscaled = hableFilmicHelper(exposureBias * color);\n            vec3 scale = 1.0 / hableFilmicHelper(vec3(11.2));\n            return gammaCorrectedColor(scale * unscaled);\n        }\n        \n        vec3 toneMap(vec3 color, float toneMapType, float toneMapParam) {\n            if (toneMapType == 0.0) {\n                return gammaCorrectedColor(color);\n            } else if (toneMapType == 1.0) {\n                return reinhardLuminanceToneMap(color);\n            } else if (toneMapType == 2.0) {\n                return reinhardPerChannelToneMap(color);\n            } else if (toneMapType == 3.0) {\n                return extendedReinhardLuminanceToneMap(color, toneMapParam);\n            } else if (toneMapType == 4.0) {\n                return extendedReinhardPerChannelToneMap(color, toneMapParam);\n            } else if (toneMapType == 5.0) {\n                return hableFilmicToneMap(color);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {\n            vec3 referenceWhite = sceneProperties[2].rgb;\n            float unitR = linearColor.r / referenceWhite.r;\n            float unitG = linearColor.g / referenceWhite.g;\n            float unitB = linearColor.b / referenceWhite.b;\n            float toneMapType = sceneProperties[3][2];\n            float toneMapParam = sceneProperties[3][3];\n            vec3 toneMapped = toneMap(vec3(unitR, unitG, unitB), toneMapType, toneMapParam);\n            return vec4(toneMapped, 1.0);\n        }\n        \n        void main() {\n            vec3 normalDirection = normalize(interpolatedNormal) * getNormalSign();\n            vec3 directionToCamera = getDirectionToCamera(interpolatedPosition, sceneProperties);\n        \n            vec3 linearColor = physicalLighting(\n                interpolatedPosition,\n                normalDirection,\n                baseColor,\n                directionToCamera,\n                viewMatrix,\n                roughness,\n                metallic,\n                lights12,\n                lights34,\n                lights56,\n                lights78,\n                enabledLights\n            );\n        \n            gl_FragColor = toSrgb(linearColor, sceneProperties);\n        }\n    ",attributes:{},uniforms:{baseColor:"cF",enabledLights:"ab",lights12:"bK",lights34:"cg",lights56:"ch",lights78:"ci",metallic:"c0",roughness:"dm",sceneProperties:"g",viewMatrix:"h"}},Sl={src:"\n        precision highp float;\n        \n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 lights12;\n        uniform highp mat4 lights34;\n        uniform highp mat4 lights56;\n        uniform highp mat4 lights78;\n        uniform lowp vec4 enabledLights;\n        uniform mediump sampler2D baseColorTexture;\n        uniform lowp vec4 constantBaseColor;\n        uniform mediump sampler2D roughnessTexture;\n        uniform lowp vec2 constantRoughness;\n        uniform mediump sampler2D metallicTexture;\n        uniform lowp vec2 constantMetallic;\n        uniform mediump sampler2D normalMapTexture;\n        uniform lowp float useNormalMap;\n        \n        varying highp vec3 interpolatedPosition;\n        varying highp vec3 interpolatedNormal;\n        varying mediump vec2 interpolatedUv;\n        varying highp vec3 interpolatedTangent;\n        \n        const lowp float kPerspectiveProjection = 0.0;\n        const lowp float kOrthographicProjection = 1.0;\n        const lowp float kDirectionalLight = 1.0;\n        const lowp float kPointLight = 2.0;\n        const highp float kPi = 3.14159265359;\n        const mediump float kMediumpFloatMax = 65504.0;\n        const lowp float kDisabledLight = 0.0;\n        const lowp float kSoftLighting = 3.0;\n        \n        float getFloatValue(sampler2D texture, vec2 uv, vec2 constantValue) {\n            if (constantValue.y == 1.0) {\n                return constantValue.x;\n            } else {\n                vec4 textureColor = texture2D(texture, uv);\n                return dot(textureColor, vec4(0.2126, 0.7152, 0.0722, 0.0));\n            }\n        }\n        \n        vec3 getLocalNormal(sampler2D normalMap, float useNormalMap, vec2 uv) {\n            vec3 rgb = useNormalMap * texture2D(normalMap, uv).rgb + (1.0 - useNormalMap) * vec3(0.5, 0.5, 1.0);\n            float x = 2.0 * (rgb.r - 0.5);\n            float y = 2.0 * (rgb.g - 0.5);\n            float z = 2.0 * (rgb.b - 0.5);\n            return normalize(vec3(-x, -y, z));\n        }\n        \n        float getNormalSign() {\n            return 2.0 * float(gl_FrontFacing) - 1.0;\n        }\n        \n        vec3 getMappedNormal(vec3 normal, vec3 tangent, float normalSign, vec3 localNormal) {\n            vec3 bitangent = cross(normal, tangent) * normalSign;\n            return normalize(localNormal.x * tangent + localNormal.y * bitangent + localNormal.z * normal);\n        }\n        \n        vec3 getDirectionToCamera(vec3 surfacePosition, mat4 sceneProperties) {\n            float projectionType = sceneProperties[1].w;\n            if (projectionType == kPerspectiveProjection) {\n                vec3 cameraPoint = sceneProperties[1].xyz;\n                return normalize(cameraPoint - surfacePosition);\n            } else if (projectionType == kOrthographicProjection) {\n                return sceneProperties[1].xyz;\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        void getDirectionToLightAndNormalIlluminance(\n            vec4 xyz_type,\n            vec4 rgb_parameter,\n            vec3 surfacePosition,\n            out vec3 directionToLight,\n            out vec3 normalIlluminance\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDirectionalLight) {\n                directionToLight = xyz_type.xyz;\n                normalIlluminance = rgb_parameter.rgb;\n            } else if (lightType == kPointLight) {\n                vec3 lightPosition = xyz_type.xyz;\n                vec3 displacement = lightPosition - surfacePosition;\n                float distance = length(displacement);\n                directionToLight = displacement / distance;\n                normalIlluminance = rgb_parameter.rgb / (4.0 * kPi * distance * distance);\n            }\n        }\n        \n        float positiveDotProduct(vec3 v1, vec3 v2) {\n            return clamp(dot(v1, v2), 0.0, 1.0);\n        }\n        \n        // Adapted from https://google.github.io/filament/Filament.md.html#materialsystem/specularbrdf/normaldistributionfunction(speculard)\n        float specularD(float alpha, float dotNH, vec3 normalDirection, vec3 halfDirection) {\n            vec3 crossNH = cross(normalDirection, halfDirection);\n            float a = dotNH * alpha;\n            float k = alpha / (dot(crossNH, crossNH) + a * a);\n            float d = k * k * (1.0 / kPi);\n            return min(d, kMediumpFloatMax);\n        }\n        \n        float safeQuotient(float numerator, float denominator) {\n            if (denominator == 0.0) {\n                return 0.0;\n            } else {\n                return numerator / denominator;\n            }\n        }\n        \n        float g1(float dotNV, float alphaSquared) {\n            return safeQuotient(2.0 * dotNV, dotNV + sqrt(alphaSquared + (1.0 - alphaSquared) * dotNV * dotNV));\n        }\n        \n        float specularG(float dotNL, float dotNV, float alphaSquared) {\n            return g1(dotNV, alphaSquared) * g1(dotNL, alphaSquared);\n        }\n        \n        vec3 fresnelColor(vec3 specularBaseColor, float dotVH) {\n            vec3 one = vec3(1.0, 1.0, 1.0);\n            float scale = exp2((-5.55473 * dotVH - 6.98316) * dotVH);\n            return specularBaseColor + (one - specularBaseColor) * scale;\n        }\n        \n        vec3 brdf(vec3 normalDirection, vec3 directionToCamera, vec3 directionToLight, float alpha, float dotNV, float dotNL, vec3 specularBaseColor, vec3 normalIlluminance) {\n            vec3 halfDirection = normalize(directionToCamera + directionToLight);\n            float dotVH = positiveDotProduct(directionToCamera, halfDirection);\n            float dotNH = positiveDotProduct(normalDirection, halfDirection);\n            float dotNHSquared = dotNH * dotNH;\n        \n            float d = specularD(alpha, dotNH, normalDirection, halfDirection);\n            float g = specularG(dotNL, dotNV, alpha * alpha);\n            vec3 f = fresnelColor(specularBaseColor, dotVH);\n            return safeQuotient(d * g, 4.0 * dotNL * dotNV) * f;\n        }\n        \n        vec3 sampleFacetNormal(vec3 vH, vec3 vT1, vec3 vT2, float s, float alpha) {\n            float t2 = (1.0 - s);\n            vec3 vNh = t2 * vT2 + sqrt(max(0.0, 1.0 - t2 * t2)) * vH;\n            return normalize(vec3(alpha * vNh.x, alpha * vNh.y, max(0.0, vNh.z)));\n        }\n        \n        vec3 softLightingLuminance(\n            vec3 aboveLuminance,\n            vec3 belowLuminance,\n            vec3 localUpDirection,\n            vec3 localLightDirection\n        ) {\n            float sinElevation = dot(localLightDirection, localUpDirection);\n            float t = (sinElevation + 1.0) / 2.0;\n            return aboveLuminance * t + belowLuminance * (1.0 - t);\n        }\n        \n        vec3 softLightingSpecularSample(\n            vec3 aboveLuminance,\n            vec3 belowLuminance,\n            vec3 localUpDirection,\n            vec3 localViewDirection,\n            vec3 localLightDirection,\n            vec3 localHalfDirection,\n            float alphaSquared,\n            vec3 specularBaseColor\n        ) {\n            vec3 luminance = softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection);\n            float dotVH = positiveDotProduct(localViewDirection, localHalfDirection);\n            float dotNL = localLightDirection.z;\n            return luminance * (fresnelColor(specularBaseColor, dotVH) * g1(dotNL, alphaSquared));\n        }\n        \n        vec3 softLighting(\n            vec3 normalDirection,\n            vec3 diffuseBaseColor,\n            vec3 specularBaseColor,\n            float alpha,\n            vec3 directionToCamera,\n            vec3 viewY,\n            vec4 xyz_type,\n            vec4 rgb_parameter\n        ) {\n            float alphaSquared = alpha * alpha;\n            vec3 upDirection = xyz_type.xyz;\n            vec3 luminanceAbove = rgb_parameter.rgb;\n            vec3 luminanceBelow = rgb_parameter.a * luminanceAbove;\n            vec3 crossProduct = cross(normalDirection, directionToCamera);\n            float crossMagnitude = length(crossProduct);\n            vec3 xDirection = vec3(0.0, 0.0, 0.0);\n            vec3 yDirection = vec3(0.0, 0.0, 0.0);\n            if (crossMagnitude > 1.0e-6) {\n                yDirection = (1.0 / crossMagnitude) * crossProduct;\n                xDirection = cross(yDirection, normalDirection);\n            } else {\n                vec3 viewY = vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]);\n                xDirection = normalize(cross(viewY, normalDirection));\n                yDirection = cross(normalDirection, xDirection);\n            }\n            float localViewX = dot(directionToCamera, xDirection);\n            float localViewZ = dot(directionToCamera, normalDirection);\n            vec3 localViewDirection = vec3(localViewX, 0, localViewZ);\n            float localUpX = dot(upDirection, xDirection);\n            float localUpY = dot(upDirection, yDirection);\n            float localUpZ = dot(upDirection, normalDirection);\n            vec3 localUpDirection = vec3(localUpX, localUpY, localUpZ);\n        \n            vec3 vH = normalize(vec3(alpha * localViewX, 0.0, localViewZ));\n            vec3 vT1 = vec3(0.0, 1.0, 0.0);\n            vec3 vT2 = cross(vH, vT1);\n            float s = 0.5 * (1.0 + vH.z);\n            \n            vec3 localHalfDirection = sampleFacetNormal(vH, vT1, vT2, s, alpha);\n            vec3 localLightDirection = vec3(0.0, 0.0, 0.0);\n            \n            localLightDirection = -reflect(localViewDirection, localHalfDirection);\n            vec3 specular = softLightingSpecularSample(luminanceAbove, luminanceBelow, localUpDirection, localViewDirection, localLightDirection, localHalfDirection, alphaSquared, specularBaseColor);\n            \n            localLightDirection = vec3(0.000000, 0.000000, 1.000000);\n            vec3 diffuse = softLightingLuminance(luminanceAbove, luminanceBelow, localUpDirection, localLightDirection) * localLightDirection.z;\n            \n            return specular + diffuse * diffuseBaseColor;\n        }\n        \n        vec3 physicalLight(\n            vec4 xyz_type,\n            vec4 rgb_parameter,\n            vec3 surfacePosition,\n            vec3 normalDirection,\n            vec3 directionToCamera,\n            vec3 viewY,\n            float dotNV,\n            vec3 diffuseBaseColor,\n            vec3 specularBaseColor,\n            float alpha\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDisabledLight) {\n                return vec3(0.0, 0.0, 0.0);\n            } else if (lightType == kSoftLighting) {\n                return softLighting(normalDirection, diffuseBaseColor, specularBaseColor, alpha, directionToCamera, viewY, xyz_type, rgb_parameter);\n            }\n        \n            vec3 directionToLight = vec3(0.0, 0.0, 0.0);\n            vec3 normalIlluminance = vec3(0.0, 0.0, 0.0);\n            getDirectionToLightAndNormalIlluminance(xyz_type, rgb_parameter, surfacePosition, directionToLight, normalIlluminance);\n        \n            float dotNL = positiveDotProduct(normalDirection, directionToLight);\n            vec3 specularColor = brdf(normalDirection, directionToCamera, directionToLight, alpha, dotNV, dotNL, specularBaseColor, normalIlluminance);\n            return (normalIlluminance * dotNL) * ((diffuseBaseColor / kPi) + specularColor);\n        }\n        \n        vec3 physicalLighting(\n            vec3 surfacePosition,\n            vec3 surfaceNormal,\n            vec3 baseColor,\n            vec3 directionToCamera,\n            mat4 viewMatrix,\n            float roughness,\n            float metallic,\n            mat4 lights12,\n            mat4 lights34,\n            mat4 lights56,\n            mat4 lights78,\n            vec4 enabledLights\n        ) {\n            float dotNV = positiveDotProduct(surfaceNormal, directionToCamera);\n            float alpha = roughness * roughness;\n            float nonmetallic = 1.0 - metallic;\n            vec3 diffuseBaseColor = nonmetallic * 0.96 * baseColor;\n            vec3 specularBaseColor = nonmetallic * 0.04 * vec3(1.0, 1.0, 1.0) + metallic * baseColor;\n            vec3 viewY = vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]);\n        \n            vec3 litColor1 = enabledLights[0] == 1.0 ? physicalLight(lights12[0], lights12[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor2 = enabledLights[1] == 1.0 ? physicalLight(lights12[2], lights12[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor3 = enabledLights[2] == 1.0 ? physicalLight(lights34[0], lights34[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor4 = enabledLights[3] == 1.0 ? physicalLight(lights34[2], lights34[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor5 = physicalLight(lights56[0], lights56[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            vec3 litColor6 = physicalLight(lights56[2], lights56[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            vec3 litColor7 = physicalLight(lights78[0], lights78[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            vec3 litColor8 = physicalLight(lights78[2], lights78[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            return litColor1 + litColor2 + litColor3 + litColor4 + litColor5 + litColor6 + litColor7 + litColor8;\n        }\n        \n        float inverseGamma(float u) {\n            if (u <= 0.04045) {\n                return clamp(u / 12.92, 0.0, 1.0);\n            } else {\n                return clamp(pow((u + 0.055) / 1.055, 2.4), 0.0, 1.0);\n            }\n        }\n        \n        vec3 fromSrgb(vec3 srgbColor) {\n            return vec3(\n                inverseGamma(srgbColor.r),\n                inverseGamma(srgbColor.g),\n                inverseGamma(srgbColor.b)\n            );\n        }\n        \n        float gammaCorrect(float u) {\n            if (u <= 0.0031308) {\n                return 12.92 * u;\n            } else {\n                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;\n            }\n        }\n        \n        vec3 gammaCorrectedColor(vec3 color) {\n            float red = gammaCorrect(color.r);\n            float green = gammaCorrect(color.g);\n            float blue = gammaCorrect(color.b);\n            return vec3(red, green, blue);\n        }\n        \n        vec3 reinhardLuminanceToneMap(vec3 color) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scale = 1.0 / (1.0 + luminance);\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 reinhardPerChannelToneMap(vec3 color) {\n            return gammaCorrectedColor(color / (color + 1.0));\n        }\n        \n        float extendedReinhardToneMap(float x, float xMax) {\n            return x * (1.0 + (x / (xMax * xMax))) / (1.0 + x);\n        }\n        \n        vec3 extendedReinhardLuminanceToneMap(vec3 color, float overexposureLimit) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scaledLuminance = extendedReinhardToneMap(luminance, overexposureLimit);\n            float scale = scaledLuminance / luminance;\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 extendedReinhardPerChannelToneMap(vec3 color, float overexposureLimit) {\n            float red = extendedReinhardToneMap(color.r, overexposureLimit);\n            float green = extendedReinhardToneMap(color.g, overexposureLimit);\n            float blue = extendedReinhardToneMap(color.b, overexposureLimit);\n            return gammaCorrectedColor(vec3(red, green, blue));\n        }\n        \n        vec3 hableFilmicHelper(vec3 color) {\n            float a = 0.15;\n            float b = 0.5;\n            float c = 0.1;\n            float d = 0.2;\n            float e = 0.02;\n            float f = 0.3;\n            return (color * (a * color + c * b) + d * e) / (color * (a * color + b) + d * f) - e / f;\n        }\n        \n        vec3 hableFilmicToneMap(vec3 color) {\n            float exposureBias = 2.0;\n            vec3 unscaled = hableFilmicHelper(exposureBias * color);\n            vec3 scale = 1.0 / hableFilmicHelper(vec3(11.2));\n            return gammaCorrectedColor(scale * unscaled);\n        }\n        \n        vec3 toneMap(vec3 color, float toneMapType, float toneMapParam) {\n            if (toneMapType == 0.0) {\n                return gammaCorrectedColor(color);\n            } else if (toneMapType == 1.0) {\n                return reinhardLuminanceToneMap(color);\n            } else if (toneMapType == 2.0) {\n                return reinhardPerChannelToneMap(color);\n            } else if (toneMapType == 3.0) {\n                return extendedReinhardLuminanceToneMap(color, toneMapParam);\n            } else if (toneMapType == 4.0) {\n                return extendedReinhardPerChannelToneMap(color, toneMapParam);\n            } else if (toneMapType == 5.0) {\n                return hableFilmicToneMap(color);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {\n            vec3 referenceWhite = sceneProperties[2].rgb;\n            float unitR = linearColor.r / referenceWhite.r;\n            float unitG = linearColor.g / referenceWhite.g;\n            float unitB = linearColor.b / referenceWhite.b;\n            float toneMapType = sceneProperties[3][2];\n            float toneMapParam = sceneProperties[3][3];\n            vec3 toneMapped = toneMap(vec3(unitR, unitG, unitB), toneMapType, toneMapParam);\n            return vec4(toneMapped, 1.0);\n        }\n        \n        void main() {\n            vec3 baseColor = fromSrgb(texture2D(baseColorTexture, interpolatedUv).rgb) * (1.0 - constantBaseColor.w) + constantBaseColor.rgb * constantBaseColor.w;\n            float roughness = getFloatValue(roughnessTexture, interpolatedUv, constantRoughness);\n            float metallic = getFloatValue(metallicTexture, interpolatedUv, constantMetallic);\n        \n            vec3 localNormal = getLocalNormal(normalMapTexture, useNormalMap, interpolatedUv);\n            float normalSign = getNormalSign();\n            vec3 originalNormal = normalize(interpolatedNormal) * normalSign;\n            vec3 normalDirection = getMappedNormal(originalNormal, interpolatedTangent, normalSign, localNormal);\n            vec3 directionToCamera = getDirectionToCamera(interpolatedPosition, sceneProperties);\n        \n            vec3 linearColor = physicalLighting(\n                interpolatedPosition,\n                normalDirection,\n                baseColor,\n                directionToCamera,\n                viewMatrix,\n                roughness,\n                metallic,\n                lights12,\n                lights34,\n                lights56,\n                lights78,\n                enabledLights\n            );\n        \n            gl_FragColor = toSrgb(linearColor, sceneProperties);\n        }\n    ",attributes:{},uniforms:{baseColorTexture:"cG",constantBaseColor:"cI",constantMetallic:"cJ",constantRoughness:"cK",enabledLights:"ab",lights12:"bK",lights34:"cg",lights56:"ch",lights78:"ci",metallicTexture:"c1",normalMapTexture:"bj",roughnessTexture:"dn",sceneProperties:"g",useNormalMap:"bp",viewMatrix:"h"}},Al={src:"\n        precision highp float;\n        \n        attribute highp vec3 quadVertex;\n        \n        uniform highp vec4 modelScale;\n        uniform highp mat4 modelMatrix;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 projectionMatrix;\n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 quadVertexPositions;\n        \n        void getQuadVertex(int quadVertexIndex, mat4 quadVertexPositions, out vec3 position, out vec3 normal, out vec3 tangent) {\n            vec3 next = vec3(0.0, 0.0, 0.0);\n            vec3 prev = vec3(0.0, 0.0, 0.0);\n            if (quadVertexIndex == 0) {\n                prev = quadVertexPositions[3].xyz;\n                position = quadVertexPositions[0].xyz;\n                next = quadVertexPositions[1].xyz;\n                tangent = normalize(next - position);\n            } else if (quadVertexIndex == 1) {\n                prev = quadVertexPositions[0].xyz;\n                position = quadVertexPositions[1].xyz;\n                next = quadVertexPositions[2].xyz;\n                tangent = normalize(position - prev);\n            } else if (quadVertexIndex == 2) {\n                prev = quadVertexPositions[1].xyz;\n                position = quadVertexPositions[2].xyz;\n                next = quadVertexPositions[3].xyz;\n                tangent = normalize(position - next);\n            } else {\n                prev = quadVertexPositions[2].xyz;\n                position = quadVertexPositions[3].xyz;\n                next = quadVertexPositions[0].xyz;\n                tangent = normalize(prev - position);\n            }\n            normal = normalize(cross(next - position, prev - position));\n        }\n        \n        vec4 getWorldPosition(vec3 modelPosition, vec4 modelScale, mat4 modelMatrix) {\n            vec4 scaledPosition = vec4(modelScale.xyz * modelPosition, 1.0);\n            return modelMatrix * scaledPosition;\n        }\n        \n        void main() {\n            vec3 position = vec3(0.0, 0.0, 0.0);\n            vec3 normal = vec3(0.0, 0.0, 0.0);\n            vec3 tangent = vec3(0.0, 0.0, 0.0);\n            getQuadVertex(int(quadVertex.z), quadVertexPositions, position, normal, tangent);\n            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);\n            gl_Position = projectionMatrix * (viewMatrix * worldPosition);\n        }\n    ",attributes:{quadVertex:"cs"},uniforms:{modelMatrix:"d",modelScale:"e",projectionMatrix:"f",quadVertexPositions:"ay",sceneProperties:"g",viewMatrix:"h"}},ql=u(function(e,n,r,t){t=b(t),r=b(r),n=b(n),e=b(e);return ec({d8:e.Z,d9:n.Z,ea:r.Z,eb:t.Z,ec:e._,ed:n._,ee:r._,ef:t._,eg:e.e8,eh:n.e8,ei:r.e8,ej:t.e8,ek:0,el:0,em:0,en:0})}),kl=bn({dN:1,dY:0,ew:6})(g([{cs:z(Qi,0,0,0)},{cs:z(Qi,1,0,1)},{cs:z(Qi,1,1,2)},{cs:z(Qi,0,1,3)}])),Zl=f(function(e,n){return{$:1,a:e,b:n}}),Rl=f(function(e,n){return n.$?{a:n.a.q,b:1}:{a:e,b:0}}),Bl=V(Oi,0,0,0,0),Fl=f(function(e,n){return n.$?{a:n.a.q,b:Bl}:{a:e,b:V(Oi,Sc(e=n.a),Ac(e),qc(e),1)}}),El=f(function(e,n){var r,t={a:e,b:n};return t.a.$?D(Zl,{a:r=t.a.a.q,b:Bl},D(Rl,r,n)):t.b.$?D(Zl,D(Fl,r=t.b.a.q,e),D(Rl,r,n)):{$:0,a:t.a.a}}),Gl=d(function(e,n,r){return{$:0,a:e,b:n,c:r}}),jl=u(function(e,n,r,t){return{$:1,a:e,b:n,c:r,d:t}}),Il=u(function(e,n,r,t){return{$:0,a:e,b:n,c:r,d:t}}),Hl=D(r,0,0),Ul=f(function(e,n){return n.$?{a:n.a.q,b:Hl}:{a:e,b:D(r,n.a,1)}}),Ol=u(function(e,n,r,t){var o,a=V(Il,e,n,r,t);return a.a.$?V(jl,{a:o=a.a.a.q,b:Bl},D(Ul,o,n),D(Ul,o,r),D(Rl,o,t)):a.b.$?V(jl,D(Fl,o=a.b.a.q,e),{a:o,b:Hl},D(Ul,o,r),D(Rl,o,t)):a.c.$?V(jl,D(Fl,o=a.c.a.q,e),D(Ul,o,n),{a:o,b:Hl},D(Rl,o,t)):a.d.$?V(jl,D(Fl,o=a.d.a.q,e),D(Ul,o,n),D(Ul,o,r),{a:o,b:1}):z(Gl,a.a.a,a.b.a,a.c.a)}),Yl=er,Wl={src:"\n        precision highp float;\n        \n        attribute highp vec3 quadVertex;\n        \n        uniform highp vec4 modelScale;\n        uniform highp mat4 modelMatrix;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 projectionMatrix;\n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 quadVertexPositions;\n        \n        varying highp vec3 interpolatedPosition;\n        varying highp vec3 interpolatedNormal;\n        \n        void getQuadVertex(int quadVertexIndex, mat4 quadVertexPositions, out vec3 position, out vec3 normal, out vec3 tangent) {\n            vec3 next = vec3(0.0, 0.0, 0.0);\n            vec3 prev = vec3(0.0, 0.0, 0.0);\n            if (quadVertexIndex == 0) {\n                prev = quadVertexPositions[3].xyz;\n                position = quadVertexPositions[0].xyz;\n                next = quadVertexPositions[1].xyz;\n                tangent = normalize(next - position);\n            } else if (quadVertexIndex == 1) {\n                prev = quadVertexPositions[0].xyz;\n                position = quadVertexPositions[1].xyz;\n                next = quadVertexPositions[2].xyz;\n                tangent = normalize(position - prev);\n            } else if (quadVertexIndex == 2) {\n                prev = quadVertexPositions[1].xyz;\n                position = quadVertexPositions[2].xyz;\n                next = quadVertexPositions[3].xyz;\n                tangent = normalize(position - next);\n            } else {\n                prev = quadVertexPositions[2].xyz;\n                position = quadVertexPositions[3].xyz;\n                next = quadVertexPositions[0].xyz;\n                tangent = normalize(prev - position);\n            }\n            normal = normalize(cross(next - position, prev - position));\n        }\n        \n        vec4 getWorldPosition(vec3 modelPosition, vec4 modelScale, mat4 modelMatrix) {\n            vec4 scaledPosition = vec4(modelScale.xyz * modelPosition, 1.0);\n            return modelMatrix * scaledPosition;\n        }\n        \n        vec3 safeNormalize(vec3 vector) {\n            if (vector == vec3(0.0, 0.0, 0.0)) {\n                return vector;\n            } else {\n                return normalize(vector);\n            }\n        }\n        \n        vec3 getWorldNormal(vec3 modelNormal, vec4 modelScale, mat4 modelMatrix) {\n            vec3 normalScale = vec3(modelScale.w / modelScale.x, modelScale.w / modelScale.y, modelScale.w / modelScale.z);\n            return (modelMatrix * vec4(safeNormalize(normalScale * modelNormal), 0.0)).xyz;\n        }\n        \n        void main() {\n            vec3 position = vec3(0.0, 0.0, 0.0);\n            vec3 normal = vec3(0.0, 0.0, 0.0);\n            vec3 tangent = vec3(0.0, 0.0, 0.0);\n            getQuadVertex(int(quadVertex.z), quadVertexPositions, position, normal, tangent);\n            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);\n            gl_Position = projectionMatrix * (viewMatrix * worldPosition);\n            interpolatedPosition = worldPosition.xyz;\n            interpolatedNormal = getWorldNormal(normal, modelScale, modelMatrix);\n        }\n    ",attributes:{quadVertex:"cs"},uniforms:{modelMatrix:"d",modelScale:"e",projectionMatrix:"f",quadVertexPositions:"ay",sceneProperties:"g",viewMatrix:"h"}},Kl={src:"\n        precision highp float;\n        \n        attribute highp vec3 quadVertex;\n        \n        uniform highp vec4 modelScale;\n        uniform highp mat4 modelMatrix;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 projectionMatrix;\n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 quadVertexPositions;\n        \n        varying highp vec3 interpolatedPosition;\n        varying highp vec3 interpolatedNormal;\n        varying mediump vec2 interpolatedUv;\n        varying highp vec3 interpolatedTangent;\n        \n        void getQuadVertex(int quadVertexIndex, mat4 quadVertexPositions, out vec3 position, out vec3 normal, out vec3 tangent) {\n            vec3 next = vec3(0.0, 0.0, 0.0);\n            vec3 prev = vec3(0.0, 0.0, 0.0);\n            if (quadVertexIndex == 0) {\n                prev = quadVertexPositions[3].xyz;\n                position = quadVertexPositions[0].xyz;\n                next = quadVertexPositions[1].xyz;\n                tangent = normalize(next - position);\n            } else if (quadVertexIndex == 1) {\n                prev = quadVertexPositions[0].xyz;\n                position = quadVertexPositions[1].xyz;\n                next = quadVertexPositions[2].xyz;\n                tangent = normalize(position - prev);\n            } else if (quadVertexIndex == 2) {\n                prev = quadVertexPositions[1].xyz;\n                position = quadVertexPositions[2].xyz;\n                next = quadVertexPositions[3].xyz;\n                tangent = normalize(position - next);\n            } else {\n                prev = quadVertexPositions[2].xyz;\n                position = quadVertexPositions[3].xyz;\n                next = quadVertexPositions[0].xyz;\n                tangent = normalize(prev - position);\n            }\n            normal = normalize(cross(next - position, prev - position));\n        }\n        \n        vec4 getWorldPosition(vec3 modelPosition, vec4 modelScale, mat4 modelMatrix) {\n            vec4 scaledPosition = vec4(modelScale.xyz * modelPosition, 1.0);\n            return modelMatrix * scaledPosition;\n        }\n        \n        vec3 safeNormalize(vec3 vector) {\n            if (vector == vec3(0.0, 0.0, 0.0)) {\n                return vector;\n            } else {\n                return normalize(vector);\n            }\n        }\n        \n        vec3 getWorldNormal(vec3 modelNormal, vec4 modelScale, mat4 modelMatrix) {\n            vec3 normalScale = vec3(modelScale.w / modelScale.x, modelScale.w / modelScale.y, modelScale.w / modelScale.z);\n            return (modelMatrix * vec4(safeNormalize(normalScale * modelNormal), 0.0)).xyz;\n        }\n        \n        void main() {\n            vec3 position = vec3(0.0, 0.0, 0.0);\n            vec3 normal = vec3(0.0, 0.0, 0.0);\n            vec3 tangent = vec3(0.0, 0.0, 0.0);\n            getQuadVertex(int(quadVertex.z), quadVertexPositions, position, normal, tangent);\n            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);\n            gl_Position = projectionMatrix * (viewMatrix * worldPosition);\n            interpolatedPosition = worldPosition.xyz;\n            interpolatedNormal = getWorldNormal(normal, modelScale, modelMatrix);\n            interpolatedUv = quadVertex.xy;\n            interpolatedTangent = tangent;\n        }\n    ",attributes:{quadVertex:"cs"},uniforms:{modelMatrix:"d",modelScale:"e",projectionMatrix:"f",quadVertexPositions:"ay",sceneProperties:"g",viewMatrix:"h"}},Ql=d(function(e,n,r){return.5<r?n+(1-r)*(e-n):e+r*(n-e)}),Xl=function(e){return z(Ql,e.es,e.ep,.5)},Jl=function(e){return z(Ql,e.et,e.eq,.5)},eu=function(e){return z(Ql,e.eu,e.er,.5)},nu=d(function(e,n,r){return{Z:e,_:n,e8:r}}),ru={src:"\n        precision highp float;\n        \n        attribute highp vec3 quadVertex;\n        \n        uniform highp vec4 modelScale;\n        uniform highp mat4 modelMatrix;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 projectionMatrix;\n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 quadVertexPositions;\n        \n        varying mediump vec2 interpolatedUv;\n        \n        void getQuadVertex(int quadVertexIndex, mat4 quadVertexPositions, out vec3 position, out vec3 normal, out vec3 tangent) {\n            vec3 next = vec3(0.0, 0.0, 0.0);\n            vec3 prev = vec3(0.0, 0.0, 0.0);\n            if (quadVertexIndex == 0) {\n                prev = quadVertexPositions[3].xyz;\n                position = quadVertexPositions[0].xyz;\n                next = quadVertexPositions[1].xyz;\n                tangent = normalize(next - position);\n            } else if (quadVertexIndex == 1) {\n                prev = quadVertexPositions[0].xyz;\n                position = quadVertexPositions[1].xyz;\n                next = quadVertexPositions[2].xyz;\n                tangent = normalize(position - prev);\n            } else if (quadVertexIndex == 2) {\n                prev = quadVertexPositions[1].xyz;\n                position = quadVertexPositions[2].xyz;\n                next = quadVertexPositions[3].xyz;\n                tangent = normalize(position - next);\n            } else {\n                prev = quadVertexPositions[2].xyz;\n                position = quadVertexPositions[3].xyz;\n                next = quadVertexPositions[0].xyz;\n                tangent = normalize(prev - position);\n            }\n            normal = normalize(cross(next - position, prev - position));\n        }\n        \n        vec4 getWorldPosition(vec3 modelPosition, vec4 modelScale, mat4 modelMatrix) {\n            vec4 scaledPosition = vec4(modelScale.xyz * modelPosition, 1.0);\n            return modelMatrix * scaledPosition;\n        }\n        \n        void main() {\n            vec3 position = vec3(0.0, 0.0, 0.0);\n            vec3 normal = vec3(0.0, 0.0, 0.0);\n            vec3 tangent = vec3(0.0, 0.0, 0.0);\n            getQuadVertex(int(quadVertex.z), quadVertexPositions, position, normal, tangent);\n            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);\n            gl_Position = projectionMatrix * (viewMatrix * worldPosition);\n            interpolatedUv = quadVertex.xy;\n        }\n    ",attributes:{quadVertex:"cs"},uniforms:{modelMatrix:"d",modelScale:"e",projectionMatrix:"f",quadVertexPositions:"ay",sceneProperties:"g",viewMatrix:"h"}},tu=l(function(r,M,_,w,N){var e=D(_l,M,g([_,w,N])),e=Wr(e);return D(Cl,e,function(){switch(r.$){case 0:var l;return r.b.$?(u=r.b.a.q,t(function(e,n,r,t,o,a,i,c){return $(R,z(Vl,t,0,c),ru,yl,kl,{b8:u,d:r,e:n,f:a,ay:V(ql,M,_,w,N),g:e,h:o})})):(l=r.b.a,t(function(e,n,r,t,o,a,i,c){return $(R,z(Vl,t,0,c),Al,Pl,kl,{aX:l,d:r,e:n,f:a,ay:V(ql,M,_,w,N),g:e,h:o})}));case 1:var u,s,f;return r.b.$?(u=r.b.a.q,f=r.c,t(function(e,n,r,t,o,a,i,c){return $(R,z(Vl,t,0,c),ru,Ll,kl,{cD:Or(f),b8:u,d:r,e:n,f:a,ay:V(ql,M,_,w,N),g:e,h:o})})):(s=r.b.a,f=r.c,t(function(e,n,r,t,o,a,i,c){return $(R,z(Vl,t,0,c),Al,Tl,kl,{cD:f,bb:D(Yl,Or(f),s),d:r,e:n,f:a,ay:V(ql,M,_,w,N),g:e,h:o})}));case 2:var d,v,e=D(El,r.b,r.c);return e.$?(d=e.a.a,C=(n=e.b).a,y=n.b,t(function(e,n,r,t,o,a,i,c){var l=i.a,i=i.b;return $(R,z(Vl,t,0,c),Kl,Nl,kl,{ab:i,bK:l.bK,cg:l.cg,ch:l.ch,ci:l.ci,c_:d,d:r,e:n,bj:C,f:a,ay:V(ql,M,_,w,N),g:e,bp:y,h:o})})):(v=e.a,t(function(e,n,r,t,o,a,i,c){var l=i.a,i=i.b;return $(R,z(Vl,t,0,c),Wl,wl,kl,{ab:i,bK:l.bK,cg:l.cg,ch:l.ch,ci:l.ci,cZ:v,d:r,e:n,f:a,ay:V(ql,M,_,w,N),g:e,h:o})}));default:var m,p,g,h,b,x,C,y,P,T,L,n=V(Ol,r.b,r.c,r.d,r.e);return n.$?(m=(e=n.a).a,p=e.b,g=(e=n.b).a,h=e.b,b=(e=n.c).a,x=e.b,C=(e=n.d).a,y=e.b,t(function(e,n,r,t,o,a,i,c){var l=i.a,i=i.b;return $(R,z(Vl,t,0,c),Kl,Sl,kl,{cG:m,cI:p,cJ:x,cK:h,ab:i,bK:l.bK,cg:l.cg,ch:l.ch,ci:l.ci,c1:b,d:r,e:n,bj:C,f:a,ay:V(ql,M,_,w,N),dn:g,g:e,bp:y,h:o})})):(P=n.a,T=n.b,L=n.c,t(function(e,n,r,t,o,a,i,c){var l=i.a,i=i.b;return $(R,z(Vl,t,0,c),Wl,$l,kl,{cF:P,ab:i,bK:l.bK,cg:l.cg,ch:l.ch,ci:l.ci,c0:L,d:r,e:n,f:a,ay:V(ql,M,_,w,N),dm:T,g:e,h:o})}))}}())}),oe=d(function(e,n,r){return{$:3,a:e,b:n,c:r}})({dN:1,dY:3,ew:4}),ou=(ce=g([{aN:D(r,0,1)},{aN:D(r,1,1)},{aN:D(r,2,1)},{aN:D(r,3,1)},{aN:D(r,0,-1)},{aN:D(r,1,-1)},{aN:D(r,2,-1)},{aN:D(r,3,-1)}]),ie=g([{a:0,b:1,c:2},{a:0,b:2,c:3},{a:4,b:6,c:5},{a:4,b:7,c:6},{a:4,b:5,c:1},{a:1,b:0,c:4},{a:5,b:6,c:2},{a:2,b:1,c:5},{a:6,b:7,c:3},{a:3,b:2,c:6},{a:7,b:4,c:0},{a:0,b:3,c:7}]),D(oe,ce,ie)),au={src:"\n        precision highp float;\n        \n        attribute highp vec2 quadShadowVertex;\n        \n        uniform highp vec4 modelScale;\n        uniform highp mat4 modelMatrix;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 projectionMatrix;\n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 shadowLight;\n        uniform highp mat4 quadVertexPositions;\n        \n        const lowp float kDirectionalLight = 1.0;\n        const lowp float kPointLight = 2.0;\n        \n        void getQuadVertex(int quadVertexIndex, mat4 quadVertexPositions, out vec3 position, out vec3 normal, out vec3 tangent) {\n            vec3 next = vec3(0.0, 0.0, 0.0);\n            vec3 prev = vec3(0.0, 0.0, 0.0);\n            if (quadVertexIndex == 0) {\n                prev = quadVertexPositions[3].xyz;\n                position = quadVertexPositions[0].xyz;\n                next = quadVertexPositions[1].xyz;\n                tangent = normalize(next - position);\n            } else if (quadVertexIndex == 1) {\n                prev = quadVertexPositions[0].xyz;\n                position = quadVertexPositions[1].xyz;\n                next = quadVertexPositions[2].xyz;\n                tangent = normalize(position - prev);\n            } else if (quadVertexIndex == 2) {\n                prev = quadVertexPositions[1].xyz;\n                position = quadVertexPositions[2].xyz;\n                next = quadVertexPositions[3].xyz;\n                tangent = normalize(position - next);\n            } else {\n                prev = quadVertexPositions[2].xyz;\n                position = quadVertexPositions[3].xyz;\n                next = quadVertexPositions[0].xyz;\n                tangent = normalize(prev - position);\n            }\n            normal = normalize(cross(next - position, prev - position));\n        }\n        \n        vec4 getWorldPosition(vec3 modelPosition, vec4 modelScale, mat4 modelMatrix) {\n            vec4 scaledPosition = vec4(modelScale.xyz * modelPosition, 1.0);\n            return modelMatrix * scaledPosition;\n        }\n        \n        vec3 safeNormalize(vec3 vector) {\n            if (vector == vec3(0.0, 0.0, 0.0)) {\n                return vector;\n            } else {\n                return normalize(vector);\n            }\n        }\n        \n        vec3 getWorldNormal(vec3 modelNormal, vec4 modelScale, mat4 modelMatrix) {\n            vec3 normalScale = vec3(modelScale.w / modelScale.x, modelScale.w / modelScale.y, modelScale.w / modelScale.z);\n            return (modelMatrix * vec4(safeNormalize(normalScale * modelNormal), 0.0)).xyz;\n        }\n        \n        vec3 getDirectionToLight(vec3 surfacePosition, vec4 xyz_type, vec4 rgb_parameter) {\n            float lightType = xyz_type.w;\n            if (lightType == kDirectionalLight) {\n                return xyz_type.xyz;\n            } else if (lightType == kPointLight) {\n                vec3 lightPosition = xyz_type.xyz;\n                return normalize(lightPosition - surfacePosition);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 shadowVertexPosition(vec3 position, vec3 normal, mat4 shadowLight, vec4 modelScale, mat4 modelMatrix, mat4 viewMatrix, mat4 projectionMatrix, mat4 sceneProperties) {\n            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);\n            vec3 worldNormal = getWorldNormal(normal, vec4(modelScale.xyz, 1.0), modelMatrix);\n            vec4 xyz_type = shadowLight[0];\n            vec4 rgb_parameter = shadowLight[1];\n            vec3 directionToLight = getDirectionToLight(worldPosition.xyz, xyz_type, rgb_parameter);\n            vec3 offset = vec3(0.0, 0.0, 0.0);\n            float sceneDiameter = sceneProperties[3][1];\n            if (dot(directionToLight, worldNormal) <= 0.0) {\n                offset = -sceneDiameter * directionToLight;\n            } else {\n                offset = -0.001 * sceneDiameter * directionToLight;\n            }\n            vec4 offsetPosition = worldPosition + vec4(offset, 0.0);\n            return projectionMatrix * (viewMatrix * offsetPosition);\n        }\n        \n        void main () {\n            vec3 position = vec3(0.0, 0.0, 0.0);\n            vec3 normal = vec3(0.0, 0.0, 0.0);\n            vec3 tangent = vec3(0.0, 0.0, 0.0);\n            getQuadVertex(int(quadShadowVertex.x), quadVertexPositions, position, normal, tangent);\n            normal *= quadShadowVertex.y;\n            gl_Position = shadowVertexPosition(\n                position,\n                normal,\n                shadowLight,\n                modelScale,\n                modelMatrix,\n                viewMatrix,\n                projectionMatrix,\n                sceneProperties\n            );\n        }\n    ",attributes:{quadShadowVertex:"aN"},uniforms:{modelMatrix:"d",modelScale:"e",projectionMatrix:"f",quadVertexPositions:"ay",sceneProperties:"g",shadowLight:"cz",viewMatrix:"h"}},iu={src:"\n        precision lowp float;\n        \n        void main () {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    ",attributes:{},uniforms:{}},cu=z(uc,{cY:0,dj:0,dx:15},{bD:7680,bU:519,b0:7680,b1:7683},{bD:7680,bU:519,b0:7680,b1:7682}),lu=z(uc,{cY:0,dj:0,dx:15},{bD:7680,bU:519,b0:7680,b1:7682},{bD:7680,bU:519,b0:7680,b1:7683}),uu=f(function(e,n){return D(x,e?lu:cu,n)}),su=u(function(l,u,s,f){return{$:2,a:t(function(e,n,r,t,o,a,i,c){return $(R,D(uu,t,c),au,iu,ou,{d:r,e:n,f:a,ay:V(ql,l,u,s,f),g:e,cz:i,h:o})})}}),fu=F(function(e,n,r,t,o,a,i){r=$(tu,r,t,o,a,i),e={a:e,b:n};return e.a?e.b?Gr(g([r,V(su,t,o,a,i)])):r:e.b?V(su,t,o,a,i):xl}),du=l(function(e,n,r,t,o){return G(fu,!0,!1,e,n,r,t,o)}),vu=f(function(e,n){return $(du,Ur(e),D(Ca,z(a,-.5,-.5,0),n),D(Ca,z(a,.5,-.5,0),n),D(Ca,z(a,.5,.5,0),n),D(Ca,z(a,-.5,.5,0),n))}),mu=function(e){return c(e)+"px"},pu=f(function(e,n){e=m(e=vi(z(ml,e,ui,n.n)),{Z:e.Z-75,_:e._-10});return D(o,g([D(k,"position","absolute"),D(k,"left",mu(e.Z)),D(k,"top",mu(e._)),D(k,"width",mu(150)),D(k,"text-align","center"),D(k,"color","white"),D(k,"font-size","12px"),D(k,"font-weight","bold")]),g([i(n.ey)]))}),gu=function(e){switch(e.Y.$){case 0:return e.ak.b?"Walking":"Standing";case 1:return"Attacking";default:return"Fighting"}},hu=f(function(e,n){return D(o,p,g([i(e+(" XP: "+ut(n)))]))}),Q=X({fT:function(e){return{a:{a6:0,av:0,aW:ir(0),a9:0,am:10,N:p,an:Yt,n:z(Wt,0,0,0),bM:10,ag:D(pt,f(function(e,n){return G(Gt,e,"Goblin (level 2)",Ht,n,3,3,p)}),g([z(Wt,-3,3,0),z(Wt,-3,-3,0),z(Wt,3,3,0),z(Wt,3,-3,0)])),cm:-1,Y:jt,bn:0,ak:p},b:Kt}},go:function(e){return eo(U(g([Eo(D($t,lr,D(To,"key",Ho))),Go(D($t,ur,D(To,"key",Ho))),jo(z(St,f(function(e,n){return{$:1,a:D(Io,e,n)}}),D(To,"clientX",Lo),D(To,"clientY",Lo)))]),U(e.ak.b||D(_o,"ArrowLeft",e.an)||D(_o,"ArrowRight",e.an)||function(){switch(e.Y.$){case 1:case 2:return 1;default:return}}()||0<rr(e.N)?g([$o(D(no,dr,cr))]):p,2===e.Y.$?g([D(Po,1e3,function(e){return Jt})]):p)))},gu:Ze,gx:function(n){return D(o,p,g([D(o,g([D(k,"border","1px solid white"),D(k,"display","inline-block"),D(k,"position","relative"),D(k,"overflow","hidden")]),g([(e={fe:Ri,fk:Aa(n),fp:1,ft:{a:ei(800),b:ei(600)},fC:U(Vr(D(pt,f(function(r,e){return D(pt,f(function(e,n){return D(vu,n?Vi:$i,z(Wt,e-Ai,r-Ai,-.01))}),e)}),Si)),D(x,D(vu,function(e){switch(e.$){case 0:return qi;case 1:return ki;default:return Zi}}(n.Y),n.n),D(M,Kr,n.ag)))},Kc({a8:Jc,fe:e.fe,fk:e.fk,fp:e.fp,ft:e.ft,fC:e.fC,aG:Xc(el(80)),aI:nl,aO:rl,aR:Qc})),D(o,p,D(M,function(e){return V(pl,Aa(n),e.am,e.bM,e.n)},n.ag)),function(e){var n=m(n=vi(z(ml,Aa(e),ui,e.n)),{Z:n.Z-75,_:n._-10});return D(o,g([D(k,"position","absolute"),D(k,"left",mu(n.Z)),D(k,"top",mu(n._)),D(k,"width",mu(150)),D(k,"text-align","center"),D(k,"color","white"),D(k,"font-size","12px"),D(k,"font-weight","bold")]),g([i(gu(e))]))}(n),V(pl,Aa(n),n.am,n.bM,n.n),z(gl,Aa(n),n.N,n.n),D(o,p,D(M,pu(Aa(n)),n.ag)),D(o,p,D(M,function(e){return z(gl,Aa(n),e.N,e.n)},n.ag))])),D(o,g([D(k,"margin-bottom","20px")]),g([function(e){return D(o,p,g([D(al,g([ll(tl(0)),ol(!e.av)]),g([i("Accuracy")])),D(al,g([ll(tl(1)),ol(1===e.av)]),g([i("Strength")])),D(al,g([ll(tl(2)),ol(2===e.av)]),g([i("Defense")]))]))}(n),function(e){return D(o,p,g([D(hu,"Accuracy",e.a6),D(hu,"Strength",e.bn),D(hu,"Defense",e.a9)]))}(n)])),D(o,p,g([i("Use left and right arrow keys to rotate the screen.")])),D(o,p,g([i("Click on the screen to move to that location.")])),D(o,p,g([i("Click on a monster to attack it.")]))]));var e}});ge={Main:{init:Q(At(0))(0)}},e.Elm?function e(n,r){for(var t in r)t in n?"init"==t?ee(6):e(n[t],r[t]):n[t]=r[t]}(e.Elm,ge):e.Elm=ge}(this);